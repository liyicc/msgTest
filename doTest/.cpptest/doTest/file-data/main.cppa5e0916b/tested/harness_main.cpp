#line 1 "C:\\gitfile\\msgTest\\doTest\\.cpptest\\doTest\\file-data\\main.cppa5e0916b\\bundled_main.cpp"

#define CPPTEST_INSTRUMENTATION

#include "cpptest_coverage.h"
#include "cpptest_runtime_i.h"
#include "cpptest_i.h"
#include "C:\gitfile\msgTest\doTest\.cpptest\doTest\unit-data\current_tubf179707\cpptest_stubconfig.h"
#include "C:\gitfile\msgTest\doTest\.cpptest\doTest\unit-data\current_tubf179707\cpptest_stubconfig.h"


struct __CPTR_Dummy_Type {
    char nonEmpty;
};

CppTestTranslationUnitInfo __CPTR_tui_4214813832_1736_1590018006 = 
{
    0U, 
    "C:\\gitfile\\msgTest\\doTest\\.cpptest\\doTest\\file-data\\main.cppa5e0916b\\tested\\harness_main.ildb"
};

#define __CPTR_tui &__CPTR_tui_4214813832_1736_1590018006



#include "cpptest_runtime_i.h"

#ifdef __cplusplus
extern "C" void __CPTR_Initialize(void);
extern "C" void __CPTR_Finalize(void);

struct __CPTR_Initializer_4214813832_1736_1590018006 {
    __CPTR_Initializer_4214813832_1736_1590018006()
    {
        CPPTEST_INITIALIZE_RUNTIME();
    }
    ~__CPTR_Initializer_4214813832_1736_1590018006()
    {
        CPPTEST_FINALIZE_RUNTIME();
    }
};

#if CPPTEST_USE_GLOBAL_OBJECTS_TO_INIT_RUNTIME
static struct __CPTR_Initializer_4214813832_1736_1590018006 __CPTR_initializer_4214813832_1736_1590018006;
#endif

#define CPPTEST_ENTER_MAIN_ROUTINE() __CPTR_Initializer_4214813832_1736_1590018006 __CPTR_main_initializer

#define CPPTEST_EXIT_MAIN_ROUTINE()

#else
extern void __CPTR_Initialize(void);
extern void __CPTR_Finalize(void);

#define CPPTEST_ENTER_MAIN_ROUTINE() CPPTEST_INITIALIZE_RUNTIME()

#define CPPTEST_EXIT_MAIN_ROUTINE() CPPTEST_FINALIZE_RUNTIME()

#endif



#define _coverage_data_unit_size 0
    


#define _coverage_code_size (1 + 10 / (sizeof(unsigned char) * 8))

static unsigned char _coverage_code[_coverage_code_size];



#define _coverage_func_size (1 + 2 / (sizeof(unsigned char) * 8))

static unsigned char _coverage_func_code[_coverage_func_size];

CppTestCoverageInfo __CPTR_cui_4214813832_1736_1590018006 = 
{ 
    0, 
    _coverage_data_unit_size,
    (unsigned char*)_coverage_code, 
    _coverage_code_size, 
    (unsigned char*)_coverage_func_code,
    _coverage_func_size,
    0U,
    0U,
    0U,
    0
};

#define __CPTR_cui &__CPTR_cui_4214813832_1736_1590018006
#define __CPTR_fid(ID) ID + __CPTR_cui_4214813832_1736_1590018006.funcIdOffset



#define _cpptest_strdata_var(id, bogus) _cpptest_strdata[id]
static 
const char* _cpptest_strdata[] = {
    0,
    "",
    "_ZN5CTest3addEii",
    "main",
    "TestSuite_main_cpp_50199427",
    "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp",
    "test_add_1",
    "test_add_10",
    "test_add_2",
    "test_add_3",
    "test_add_4",
    "test_add_5",
    "test_add_6",
    "test_add_7",
    "test_add_8",
    "test_add_9",
    "test_main_1",
    0
};

#if defined(CPPTEST_STUB__ZN5CTest3addEii) || CPPTEST_ENABLE_ALL_STUBS
# if defined(CPPTEST_SAFE_STUB__ZN5CTest3addEii)
#  define CppTest_Stub__Call_add__ZN5CTest3addEii CppTest_Safe_Stub_add__ZN5CTest3addEii
#  if defined(CPPTEST_UNDEFINED__ZN5CTest3addEii)
#   define CppTest_Safe_Stub_add__ZN5CTest3addEii add
#  endif
# elif defined(CPPTEST_AUTO_STUB__ZN5CTest3addEii)
#  define CppTest_Stub__Call_add__ZN5CTest3addEii CppTest_Auto_Stub_add__ZN5CTest3addEii
#  if defined(CPPTEST_UNDEFINED__ZN5CTest3addEii)
#   define CppTest_Auto_Stub_add__ZN5CTest3addEii add
#  endif
# else
#  define CppTest_Stub__Call_add__ZN5CTest3addEii CppTest_Stub_add__ZN5CTest3addEii
#  if defined(CPPTEST_UNDEFINED__ZN5CTest3addEii)
#   define CppTest_Stub_add__ZN5CTest3addEii add
#  endif
#  define CPPTEST_USER_STUB__ZN5CTest3addEii
# endif
#else
# define CppTest_Stub__Call_add__ZN5CTest3addEii add
#endif

#if defined(CPPTEST_STUB_system) || CPPTEST_ENABLE_ALL_STUBS
# if defined(CPPTEST_SAFE_STUB_system)
#  define CppTest_Stub__Call_system_system CppTest_Safe_Stub_system_system
#  if defined(CPPTEST_UNDEFINED_system)
#   define CppTest_Safe_Stub_system_system system
#  endif
# elif defined(CPPTEST_AUTO_STUB_system)
#  define CppTest_Stub__Call_system_system CppTest_Auto_Stub_system_system
#  if defined(CPPTEST_UNDEFINED_system)
#   define CppTest_Auto_Stub_system_system system
#  endif
# else
#  define CppTest_Stub__Call_system_system CppTest_Stub_system_system
#  if defined(CPPTEST_UNDEFINED_system)
#   define CppTest_Stub_system_system system
#  endif
#  define CPPTEST_USER_STUB_system
# endif
#else
# define CppTest_Stub__Call_system_system system
#endif

#if defined(CPPTEST_STUB__ZSt15make_error_codeNSt7io_errc7io_errcE) || CPPTEST_ENABLE_ALL_STUBS
# if defined(CPPTEST_SAFE_STUB__ZSt15make_error_codeNSt7io_errc7io_errcE)
#  define CppTest_Stub__Call_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE CppTest_Safe_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE
#  if defined(CPPTEST_UNDEFINED__ZSt15make_error_codeNSt7io_errc7io_errcE)
#   define CppTest_Safe_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE make_error_code
#  endif
# elif defined(CPPTEST_AUTO_STUB__ZSt15make_error_codeNSt7io_errc7io_errcE)
#  define CppTest_Stub__Call_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE CppTest_Auto_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE
#  if defined(CPPTEST_UNDEFINED__ZSt15make_error_codeNSt7io_errc7io_errcE)
#   define CppTest_Auto_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE make_error_code
#  endif
# else
#  define CppTest_Stub__Call_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE CppTest_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE
#  if defined(CPPTEST_UNDEFINED__ZSt15make_error_codeNSt7io_errc7io_errcE)
#   define CppTest_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE make_error_code
#  endif
#  define CPPTEST_USER_STUB__ZSt15make_error_codeNSt7io_errc7io_errcE
# endif
#else
# define CppTest_Stub__Call_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE make_error_code
#endif

#if defined(CPPTEST_STUB__ZSt4endlRSo) || CPPTEST_ENABLE_ALL_STUBS
# if defined(CPPTEST_SAFE_STUB__ZSt4endlRSo)
#  define CppTest_Stub__Call_endl__ZSt4endlRSo CppTest_Safe_Stub_endl__ZSt4endlRSo
#  if defined(CPPTEST_UNDEFINED__ZSt4endlRSo)
#   define CppTest_Safe_Stub_endl__ZSt4endlRSo endl
#  endif
# elif defined(CPPTEST_AUTO_STUB__ZSt4endlRSo)
#  define CppTest_Stub__Call_endl__ZSt4endlRSo CppTest_Auto_Stub_endl__ZSt4endlRSo
#  if defined(CPPTEST_UNDEFINED__ZSt4endlRSo)
#   define CppTest_Auto_Stub_endl__ZSt4endlRSo endl
#  endif
# else
#  define CppTest_Stub__Call_endl__ZSt4endlRSo CppTest_Stub_endl__ZSt4endlRSo
#  if defined(CPPTEST_UNDEFINED__ZSt4endlRSo)
#   define CppTest_Stub_endl__ZSt4endlRSo endl
#  endif
#  define CPPTEST_USER_STUB__ZSt4endlRSo
# endif
#else
# define CppTest_Stub__Call_endl__ZSt4endlRSo endl
#endif


#ifndef CPPTEST_IMP_system
#if defined(CPPTEST_UNDEFINED_system)
# define CPPTEST_IMP_system
#else
# define CPPTEST_IMP_system __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP_free
#if defined(CPPTEST_UNDEFINED_free)
# define CPPTEST_IMP_free
#else
# define CPPTEST_IMP_free __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP_memchr
#if defined(CPPTEST_UNDEFINED_memchr)
# define CPPTEST_IMP_memchr
#else
# define CPPTEST_IMP_memchr __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP_memmove_s
#if defined(CPPTEST_UNDEFINED_memmove_s)
# define CPPTEST_IMP_memmove_s
#else
# define CPPTEST_IMP_memmove_s __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP_memmove
#if defined(CPPTEST_UNDEFINED_memmove)
# define CPPTEST_IMP_memmove
#else
# define CPPTEST_IMP_memmove __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP_strcspn
#if defined(CPPTEST_UNDEFINED_strcspn)
# define CPPTEST_IMP_strcspn
#else
# define CPPTEST_IMP_strcspn __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP_sprintf_s
#if defined(CPPTEST_UNDEFINED_sprintf_s)
# define CPPTEST_IMP_sprintf_s
#else
# define CPPTEST_IMP_sprintf_s __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__free_dbg
#if defined(CPPTEST_UNDEFINED__free_dbg)
# define CPPTEST_IMP__free_dbg
#else
# define CPPTEST_IMP__free_dbg __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP_localeconv
#if defined(CPPTEST_UNDEFINED_localeconv)
# define CPPTEST_IMP_localeconv
#else
# define CPPTEST_IMP_localeconv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__Getcvt
#if defined(CPPTEST_UNDEFINED__Getcvt)
# define CPPTEST_IMP__Getcvt
#else
# define CPPTEST_IMP__Getcvt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZnwjRKSt15_DebugHeapTag_tPci
#if defined(CPPTEST_UNDEFINED__ZnwjRKSt15_DebugHeapTag_tPci)
# define CPPTEST_IMP__ZnwjRKSt15_DebugHeapTag_tPci
#else
# define CPPTEST_IMP__ZnwjRKSt15_DebugHeapTag_tPci __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZnajRKSt15_DebugHeapTag_tPci
#if defined(CPPTEST_UNDEFINED__ZnajRKSt15_DebugHeapTag_tPci)
# define CPPTEST_IMP__ZnajRKSt15_DebugHeapTag_tPci
#else
# define CPPTEST_IMP__ZnajRKSt15_DebugHeapTag_tPci __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7_LockitC9Ei
#if defined(CPPTEST_UNDEFINED__ZNSt7_LockitC9Ei)
# define CPPTEST_IMP__ZNSt7_LockitC9Ei
#else
# define CPPTEST_IMP__ZNSt7_LockitC9Ei __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7_LockitD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt7_LockitD9Ev)
# define CPPTEST_IMP__ZNSt7_LockitD9Ev
#else
# define CPPTEST_IMP__ZNSt7_LockitD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6_MutexC9ESt14_Uninitialized
#if defined(CPPTEST_UNDEFINED__ZNSt6_MutexC9ESt14_Uninitialized)
# define CPPTEST_IMP__ZNSt6_MutexC9ESt14_Uninitialized
#else
# define CPPTEST_IMP__ZNSt6_MutexC9ESt14_Uninitialized __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt9exceptionC9ERKPKc
#if defined(CPPTEST_UNDEFINED__ZNSt9exceptionC9ERKPKc)
# define CPPTEST_IMP__ZNSt9exceptionC9ERKPKc
#else
# define CPPTEST_IMP__ZNSt9exceptionC9ERKPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt9exceptionC9ERKS_
#if defined(CPPTEST_UNDEFINED__ZNSt9exceptionC9ERKS_)
# define CPPTEST_IMP__ZNSt9exceptionC9ERKS_
#else
# define CPPTEST_IMP__ZNSt9exceptionC9ERKS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt9exceptionD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt9exceptionD9Ev)
# define CPPTEST_IMP__ZNSt9exceptionD9Ev
#else
# define CPPTEST_IMP__ZNSt9exceptionD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt9exception4whatEv
#if defined(CPPTEST_UNDEFINED__ZNKSt9exception4whatEv)
# define CPPTEST_IMP__ZNKSt9exception4whatEv
#else
# define CPPTEST_IMP__ZNKSt9exception4whatEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale5facet7_GetcatEPPKS0_PKS_
#if defined(CPPTEST_UNDEFINED__ZNSt6locale5facet7_GetcatEPPKS0_PKS_)
# define CPPTEST_IMP__ZNSt6locale5facet7_GetcatEPPKS0_PKS_
#else
# define CPPTEST_IMP__ZNSt6locale5facet7_GetcatEPPKS0_PKS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale5facet7_IncrefEv
#if defined(CPPTEST_UNDEFINED__ZNSt6locale5facet7_IncrefEv)
# define CPPTEST_IMP__ZNSt6locale5facet7_IncrefEv
#else
# define CPPTEST_IMP__ZNSt6locale5facet7_IncrefEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale5facet7_DecrefEv
#if defined(CPPTEST_UNDEFINED__ZNSt6locale5facet7_DecrefEv)
# define CPPTEST_IMP__ZNSt6locale5facet7_DecrefEv
#else
# define CPPTEST_IMP__ZNSt6locale5facet7_DecrefEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale5facetnwEj
#if defined(CPPTEST_UNDEFINED__ZNSt6locale5facetnwEj)
# define CPPTEST_IMP__ZNSt6locale5facetnwEj
#else
# define CPPTEST_IMP__ZNSt6locale5facetnwEj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale5facetnwEjRKSt15_DebugHeapTag_tPci
#if defined(CPPTEST_UNDEFINED__ZNSt6locale5facetnwEjRKSt15_DebugHeapTag_tPci)
# define CPPTEST_IMP__ZNSt6locale5facetnwEjRKSt15_DebugHeapTag_tPci
#else
# define CPPTEST_IMP__ZNSt6locale5facetnwEjRKSt15_DebugHeapTag_tPci __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale5facetdlEPvRKSt15_DebugHeapTag_tPci
#if defined(CPPTEST_UNDEFINED__ZNSt6locale5facetdlEPvRKSt15_DebugHeapTag_tPci)
# define CPPTEST_IMP__ZNSt6locale5facetdlEPvRKSt15_DebugHeapTag_tPci
#else
# define CPPTEST_IMP__ZNSt6locale5facetdlEPvRKSt15_DebugHeapTag_tPci __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale5facetdlEPv
#if defined(CPPTEST_UNDEFINED__ZNSt6locale5facetdlEPv)
# define CPPTEST_IMP__ZNSt6locale5facetdlEPv
#else
# define CPPTEST_IMP__ZNSt6locale5facetdlEPv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale5facetD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt6locale5facetD9Ev)
# define CPPTEST_IMP__ZNSt6locale5facetD9Ev
#else
# define CPPTEST_IMP__ZNSt6locale5facetD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale5facetC9Ej
#if defined(CPPTEST_UNDEFINED__ZNSt6locale5facetC9Ej)
# define CPPTEST_IMP__ZNSt6locale5facetC9Ej
#else
# define CPPTEST_IMP__ZNSt6locale5facetC9Ej __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale7_LocimpD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt6locale7_LocimpD9Ev)
# define CPPTEST_IMP__ZNSt6locale7_LocimpD9Ev
#else
# define CPPTEST_IMP__ZNSt6locale7_LocimpD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale7_LocimpC9Eb
#if defined(CPPTEST_UNDEFINED__ZNSt6locale7_LocimpC9Eb)
# define CPPTEST_IMP__ZNSt6locale7_LocimpC9Eb
#else
# define CPPTEST_IMP__ZNSt6locale7_LocimpC9Eb __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale7_LocimpC9ERKS0_
#if defined(CPPTEST_UNDEFINED__ZNSt6locale7_LocimpC9ERKS0_)
# define CPPTEST_IMP__ZNSt6locale7_LocimpC9ERKS0_
#else
# define CPPTEST_IMP__ZNSt6locale7_LocimpC9ERKS0_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale7_Locimp7_AddfacEPNS_5facetEj
#if defined(CPPTEST_UNDEFINED__ZNSt6locale7_Locimp7_AddfacEPNS_5facetEj)
# define CPPTEST_IMP__ZNSt6locale7_Locimp7_AddfacEPNS_5facetEj
#else
# define CPPTEST_IMP__ZNSt6locale7_Locimp7_AddfacEPNS_5facetEj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_TimevecC9EPv
#if defined(CPPTEST_UNDEFINED__ZNSt8_TimevecC9EPv)
# define CPPTEST_IMP__ZNSt8_TimevecC9EPv
#else
# define CPPTEST_IMP__ZNSt8_TimevecC9EPv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_TimevecC9ERKS_
#if defined(CPPTEST_UNDEFINED__ZNSt8_TimevecC9ERKS_)
# define CPPTEST_IMP__ZNSt8_TimevecC9ERKS_
#else
# define CPPTEST_IMP__ZNSt8_TimevecC9ERKS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_TimevecD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt8_TimevecD9Ev)
# define CPPTEST_IMP__ZNSt8_TimevecD9Ev
#else
# define CPPTEST_IMP__ZNSt8_TimevecD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_TimevecaSERKS_
#if defined(CPPTEST_UNDEFINED__ZNSt8_TimevecaSERKS_)
# define CPPTEST_IMP__ZNSt8_TimevecaSERKS_
#else
# define CPPTEST_IMP__ZNSt8_TimevecaSERKS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Timevec7_GetptrEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Timevec7_GetptrEv)
# define CPPTEST_IMP__ZNKSt8_Timevec7_GetptrEv
#else
# define CPPTEST_IMP__ZNKSt8_Timevec7_GetptrEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_Locinfo13_Locinfo_ctorEPS_PKc
#if defined(CPPTEST_UNDEFINED__ZNSt8_Locinfo13_Locinfo_ctorEPS_PKc)
# define CPPTEST_IMP__ZNSt8_Locinfo13_Locinfo_ctorEPS_PKc
#else
# define CPPTEST_IMP__ZNSt8_Locinfo13_Locinfo_ctorEPS_PKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_Locinfo13_Locinfo_dtorEPS_
#if defined(CPPTEST_UNDEFINED__ZNSt8_Locinfo13_Locinfo_dtorEPS_)
# define CPPTEST_IMP__ZNSt8_Locinfo13_Locinfo_dtorEPS_
#else
# define CPPTEST_IMP__ZNSt8_Locinfo13_Locinfo_dtorEPS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_LocinfoC9EPKc
#if defined(CPPTEST_UNDEFINED__ZNSt8_LocinfoC9EPKc)
# define CPPTEST_IMP__ZNSt8_LocinfoC9EPKc
#else
# define CPPTEST_IMP__ZNSt8_LocinfoC9EPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_LocinfoC9EiPKc
#if defined(CPPTEST_UNDEFINED__ZNSt8_LocinfoC9EiPKc)
# define CPPTEST_IMP__ZNSt8_LocinfoC9EiPKc
#else
# define CPPTEST_IMP__ZNSt8_LocinfoC9EiPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_LocinfoD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt8_LocinfoD9Ev)
# define CPPTEST_IMP__ZNSt8_LocinfoD9Ev
#else
# define CPPTEST_IMP__ZNSt8_LocinfoD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8_Locinfo8_AddcatsEiPKc
#if defined(CPPTEST_UNDEFINED__ZNSt8_Locinfo8_AddcatsEiPKc)
# define CPPTEST_IMP__ZNSt8_Locinfo8_AddcatsEiPKc
#else
# define CPPTEST_IMP__ZNSt8_Locinfo8_AddcatsEiPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo8_GetnameEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo8_GetnameEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo8_GetnameEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo8_GetnameEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo8_GetcollEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo8_GetcollEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo8_GetcollEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo8_GetcollEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo9_GetctypeEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo9_GetctypeEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo9_GetctypeEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo9_GetctypeEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo7_GetcvtEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo7_GetcvtEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo7_GetcvtEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo7_GetcvtEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo9_GetlconvEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo9_GetlconvEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo9_GetlconvEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo9_GetlconvEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo10_GettnamesEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo10_GettnamesEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo10_GettnamesEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo10_GettnamesEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo8_GetdaysEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo8_GetdaysEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo8_GetdaysEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo8_GetdaysEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo10_GetmonthsEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo10_GetmonthsEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo10_GetmonthsEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo10_GetmonthsEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo9_GetfalseEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo9_GetfalseEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo9_GetfalseEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo9_GetfalseEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo8_GettrueEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo8_GettrueEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo8_GettrueEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo8_GettrueEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8_Locinfo13_GetdateorderEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8_Locinfo13_GetdateorderEv)
# define CPPTEST_IMP__ZNKSt8_Locinfo13_GetdateorderEv
#else
# define CPPTEST_IMP__ZNKSt8_Locinfo13_GetdateorderEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale2idC9Ej
#if defined(CPPTEST_UNDEFINED__ZNSt6locale2idC9Ej)
# define CPPTEST_IMP__ZNSt6locale2idC9Ej
#else
# define CPPTEST_IMP__ZNSt6locale2idC9Ej __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale2idcvjEv
#if defined(CPPTEST_UNDEFINED__ZNSt6locale2idcvjEv)
# define CPPTEST_IMP__ZNSt6locale2idcvjEv
#else
# define CPPTEST_IMP__ZNSt6locale2idcvjEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt17_Container_base12C9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt17_Container_base12C9Ev)
# define CPPTEST_IMP__ZNSt17_Container_base12C9Ev
#else
# define CPPTEST_IMP__ZNSt17_Container_base12C9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt17_Container_base12C9ERKS_
#if defined(CPPTEST_UNDEFINED__ZNSt17_Container_base12C9ERKS_)
# define CPPTEST_IMP__ZNSt17_Container_base12C9ERKS_
#else
# define CPPTEST_IMP__ZNSt17_Container_base12C9ERKS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt17_Container_base12aSERKS_
#if defined(CPPTEST_UNDEFINED__ZNSt17_Container_base12aSERKS_)
# define CPPTEST_IMP__ZNSt17_Container_base12aSERKS_
#else
# define CPPTEST_IMP__ZNSt17_Container_base12aSERKS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt17_Container_base12D9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt17_Container_base12D9Ev)
# define CPPTEST_IMP__ZNSt17_Container_base12D9Ev
#else
# define CPPTEST_IMP__ZNSt17_Container_base12D9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt17_Container_base1210_GetpfirstEv
#if defined(CPPTEST_UNDEFINED__ZNKSt17_Container_base1210_GetpfirstEv)
# define CPPTEST_IMP__ZNKSt17_Container_base1210_GetpfirstEv
#else
# define CPPTEST_IMP__ZNKSt17_Container_base1210_GetpfirstEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt17_Container_base1211_Orphan_allEv
#if defined(CPPTEST_UNDEFINED__ZNSt17_Container_base1211_Orphan_allEv)
# define CPPTEST_IMP__ZNSt17_Container_base1211_Orphan_allEv
#else
# define CPPTEST_IMP__ZNSt17_Container_base1211_Orphan_allEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt17_Container_base129_Swap_allERS_
#if defined(CPPTEST_UNDEFINED__ZNSt17_Container_base129_Swap_allERS_)
# define CPPTEST_IMP__ZNSt17_Container_base129_Swap_allERS_
#else
# define CPPTEST_IMP__ZNSt17_Container_base129_Swap_allERS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt6locale16_GetgloballocaleEv
#if defined(CPPTEST_UNDEFINED__ZNSt6locale16_GetgloballocaleEv)
# define CPPTEST_IMP__ZNSt6locale16_GetgloballocaleEv
#else
# define CPPTEST_IMP__ZNSt6locale16_GetgloballocaleEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base4InitC9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base4InitC9Ev)
# define CPPTEST_IMP__ZNSt8ios_base4InitC9Ev
#else
# define CPPTEST_IMP__ZNSt8ios_base4InitC9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base4InitD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base4InitD9Ev)
# define CPPTEST_IMP__ZNSt8ios_base4InitD9Ev
#else
# define CPPTEST_IMP__ZNSt8ios_base4InitD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_baseaSERKS_
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_baseaSERKS_)
# define CPPTEST_IMP__ZNSt8ios_baseaSERKS_
#else
# define CPPTEST_IMP__ZNSt8ios_baseaSERKS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_basecvPvEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_basecvPvEv)
# define CPPTEST_IMP__ZNKSt8ios_basecvPvEv
#else
# define CPPTEST_IMP__ZNKSt8ios_basecvPvEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_basentEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_basentEv)
# define CPPTEST_IMP__ZNKSt8ios_basentEv
#else
# define CPPTEST_IMP__ZNKSt8ios_basentEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5clearEib
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5clearEib)
# define CPPTEST_IMP__ZNSt8ios_base5clearEib
#else
# define CPPTEST_IMP__ZNSt8ios_base5clearEib __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5clearEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5clearEi)
# define CPPTEST_IMP__ZNSt8ios_base5clearEi
#else
# define CPPTEST_IMP__ZNSt8ios_base5clearEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5clearEj
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5clearEj)
# define CPPTEST_IMP__ZNSt8ios_base5clearEj
#else
# define CPPTEST_IMP__ZNSt8ios_base5clearEj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base7rdstateEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base7rdstateEv)
# define CPPTEST_IMP__ZNKSt8ios_base7rdstateEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base7rdstateEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base8setstateEib
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base8setstateEib)
# define CPPTEST_IMP__ZNSt8ios_base8setstateEib
#else
# define CPPTEST_IMP__ZNSt8ios_base8setstateEib __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base8setstateEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base8setstateEi)
# define CPPTEST_IMP__ZNSt8ios_base8setstateEi
#else
# define CPPTEST_IMP__ZNSt8ios_base8setstateEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base8setstateEj
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base8setstateEj)
# define CPPTEST_IMP__ZNSt8ios_base8setstateEj
#else
# define CPPTEST_IMP__ZNSt8ios_base8setstateEj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base4goodEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base4goodEv)
# define CPPTEST_IMP__ZNKSt8ios_base4goodEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base4goodEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base3eofEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base3eofEv)
# define CPPTEST_IMP__ZNKSt8ios_base3eofEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base3eofEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base4failEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base4failEv)
# define CPPTEST_IMP__ZNKSt8ios_base4failEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base4failEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base3badEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base3badEv)
# define CPPTEST_IMP__ZNKSt8ios_base3badEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base3badEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base10exceptionsEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base10exceptionsEv)
# define CPPTEST_IMP__ZNKSt8ios_base10exceptionsEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base10exceptionsEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base10exceptionsEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base10exceptionsEi)
# define CPPTEST_IMP__ZNSt8ios_base10exceptionsEi
#else
# define CPPTEST_IMP__ZNSt8ios_base10exceptionsEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base10exceptionsEj
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base10exceptionsEj)
# define CPPTEST_IMP__ZNSt8ios_base10exceptionsEj
#else
# define CPPTEST_IMP__ZNSt8ios_base10exceptionsEj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base5flagsEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base5flagsEv)
# define CPPTEST_IMP__ZNKSt8ios_base5flagsEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base5flagsEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5flagsEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5flagsEi)
# define CPPTEST_IMP__ZNSt8ios_base5flagsEi
#else
# define CPPTEST_IMP__ZNSt8ios_base5flagsEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base4setfEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base4setfEi)
# define CPPTEST_IMP__ZNSt8ios_base4setfEi
#else
# define CPPTEST_IMP__ZNSt8ios_base4setfEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base4setfEii
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base4setfEii)
# define CPPTEST_IMP__ZNSt8ios_base4setfEii
#else
# define CPPTEST_IMP__ZNSt8ios_base4setfEii __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base6unsetfEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base6unsetfEi)
# define CPPTEST_IMP__ZNSt8ios_base6unsetfEi
#else
# define CPPTEST_IMP__ZNSt8ios_base6unsetfEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base9precisionEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base9precisionEv)
# define CPPTEST_IMP__ZNKSt8ios_base9precisionEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base9precisionEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base9precisionEx
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base9precisionEx)
# define CPPTEST_IMP__ZNSt8ios_base9precisionEx
#else
# define CPPTEST_IMP__ZNSt8ios_base9precisionEx __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base5widthEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base5widthEv)
# define CPPTEST_IMP__ZNKSt8ios_base5widthEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base5widthEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5widthEx
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5widthEx)
# define CPPTEST_IMP__ZNSt8ios_base5widthEx
#else
# define CPPTEST_IMP__ZNSt8ios_base5widthEx __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt8ios_base6getlocEv
#if defined(CPPTEST_UNDEFINED__ZNKSt8ios_base6getlocEv)
# define CPPTEST_IMP__ZNKSt8ios_base6getlocEv
#else
# define CPPTEST_IMP__ZNKSt8ios_base6getlocEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5imbueERKSt6locale
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5imbueERKSt6locale)
# define CPPTEST_IMP__ZNSt8ios_base5imbueERKSt6locale
#else
# define CPPTEST_IMP__ZNSt8ios_base5imbueERKSt6locale __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base6xallocEv
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base6xallocEv)
# define CPPTEST_IMP__ZNSt8ios_base6xallocEv
#else
# define CPPTEST_IMP__ZNSt8ios_base6xallocEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5iwordEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5iwordEi)
# define CPPTEST_IMP__ZNSt8ios_base5iwordEi
#else
# define CPPTEST_IMP__ZNSt8ios_base5iwordEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5pwordEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5pwordEi)
# define CPPTEST_IMP__ZNSt8ios_base5pwordEi
#else
# define CPPTEST_IMP__ZNSt8ios_base5pwordEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi)
# define CPPTEST_IMP__ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi
#else
# define CPPTEST_IMP__ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base7copyfmtERKS_
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base7copyfmtERKS_)
# define CPPTEST_IMP__ZNSt8ios_base7copyfmtERKS_
#else
# define CPPTEST_IMP__ZNSt8ios_base7copyfmtERKS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base15sync_with_stdioEb
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base15sync_with_stdioEb)
# define CPPTEST_IMP__ZNSt8ios_base15sync_with_stdioEb
#else
# define CPPTEST_IMP__ZNSt8ios_base15sync_with_stdioEb __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base4swapERS_
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base4swapERS_)
# define CPPTEST_IMP__ZNSt8ios_base4swapERS_
#else
# define CPPTEST_IMP__ZNSt8ios_base4swapERS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_baseD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_baseD9Ev)
# define CPPTEST_IMP__ZNSt8ios_baseD9Ev
#else
# define CPPTEST_IMP__ZNSt8ios_baseD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_baseC9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_baseC9Ev)
# define CPPTEST_IMP__ZNSt8ios_baseC9Ev
#else
# define CPPTEST_IMP__ZNSt8ios_baseC9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5_InitEv
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5_InitEv)
# define CPPTEST_IMP__ZNSt8ios_base5_InitEv
#else
# define CPPTEST_IMP__ZNSt8ios_base5_InitEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base8_CallfnsENS_5eventE
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base8_CallfnsENS_5eventE)
# define CPPTEST_IMP__ZNSt8ios_base8_CallfnsENS_5eventE
#else
# define CPPTEST_IMP__ZNSt8ios_base8_CallfnsENS_5eventE __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base8_FindarrEi
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base8_FindarrEi)
# define CPPTEST_IMP__ZNSt8ios_base8_FindarrEi
#else
# define CPPTEST_IMP__ZNSt8ios_base8_FindarrEi __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8ios_base5_TidyEv
#if defined(CPPTEST_UNDEFINED__ZNSt8ios_base5_TidyEv)
# define CPPTEST_IMP__ZNSt8ios_base5_TidyEv
#else
# define CPPTEST_IMP__ZNSt8ios_base5_TidyEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE2isEsw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE2isEsw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE2isEsw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE2isEsw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE2isEPKwS2_Ps
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE2isEPKwS2_Ps)
# define CPPTEST_IMP__ZNKSt5ctypeIwE2isEPKwS2_Ps
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE2isEPKwS2_Ps __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE7scan_isEsPKwS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE7scan_isEsPKwS2_)
# define CPPTEST_IMP__ZNKSt5ctypeIwE7scan_isEsPKwS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE7scan_isEsPKwS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE8scan_notEsPKwS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE8scan_notEsPKwS2_)
# define CPPTEST_IMP__ZNKSt5ctypeIwE8scan_notEsPKwS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE8scan_notEsPKwS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE7tolowerEw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE7tolowerEw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE7tolowerEw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE7tolowerEw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE7tolowerEPwPKw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE7tolowerEPwPKw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE7tolowerEPwPKw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE7tolowerEPwPKw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE7toupperEw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE7toupperEw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE7toupperEw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE7toupperEw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE7toupperEPwPKw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE7toupperEPwPKw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE7toupperEPwPKw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE7toupperEPwPKw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE5widenEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE5widenEc)
# define CPPTEST_IMP__ZNKSt5ctypeIwE5widenEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE5widenEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE5widenEPKcS2_Pw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE5widenEPKcS2_Pw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE5widenEPKcS2_Pw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE5widenEPKcS2_Pw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE6narrowEwc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE6narrowEwc)
# define CPPTEST_IMP__ZNKSt5ctypeIwE6narrowEwc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE6narrowEwc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE6narrowEPKwS2_cPc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE6narrowEPKwS2_cPc)
# define CPPTEST_IMP__ZNKSt5ctypeIwE6narrowEPKwS2_cPc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE6narrowEPKwS2_cPc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIwEC9Ej
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIwEC9Ej)
# define CPPTEST_IMP__ZNSt5ctypeIwEC9Ej
#else
# define CPPTEST_IMP__ZNSt5ctypeIwEC9Ej __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIwEC9ERKSt8_Locinfoj
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIwEC9ERKSt8_Locinfoj)
# define CPPTEST_IMP__ZNSt5ctypeIwEC9ERKSt8_Locinfoj
#else
# define CPPTEST_IMP__ZNSt5ctypeIwEC9ERKSt8_Locinfoj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIwE7_GetcatEPPKNSt6locale5facetEPKS1_
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIwE7_GetcatEPPKNSt6locale5facetEPKS1_)
# define CPPTEST_IMP__ZNSt5ctypeIwE7_GetcatEPPKNSt6locale5facetEPKS1_
#else
# define CPPTEST_IMP__ZNSt5ctypeIwE7_GetcatEPPKNSt6locale5facetEPKS1_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIwED9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIwED9Ev)
# define CPPTEST_IMP__ZNSt5ctypeIwED9Ev
#else
# define CPPTEST_IMP__ZNSt5ctypeIwED9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIwE5_InitERKSt8_Locinfo
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIwE5_InitERKSt8_Locinfo)
# define CPPTEST_IMP__ZNSt5ctypeIwE5_InitERKSt8_Locinfo
#else
# define CPPTEST_IMP__ZNSt5ctypeIwE5_InitERKSt8_Locinfo __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE5do_isEsw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE5do_isEsw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE5do_isEsw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE5do_isEsw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE5do_isEPKwS2_Ps
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE5do_isEPKwS2_Ps)
# define CPPTEST_IMP__ZNKSt5ctypeIwE5do_isEPKwS2_Ps
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE5do_isEPKwS2_Ps __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE10do_scan_isEsPKwS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE10do_scan_isEsPKwS2_)
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_scan_isEsPKwS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_scan_isEsPKwS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE11do_scan_notEsPKwS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE11do_scan_notEsPKwS2_)
# define CPPTEST_IMP__ZNKSt5ctypeIwE11do_scan_notEsPKwS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE11do_scan_notEsPKwS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE10do_tolowerEw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE10do_tolowerEw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_tolowerEw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_tolowerEw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE10do_tolowerEPwPKw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE10do_tolowerEPwPKw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_tolowerEPwPKw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_tolowerEPwPKw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE10do_toupperEw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE10do_toupperEw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_toupperEw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_toupperEw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE10do_toupperEPwPKw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE10do_toupperEPwPKw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_toupperEPwPKw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE10do_toupperEPwPKw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE8_DowidenEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE8_DowidenEc)
# define CPPTEST_IMP__ZNKSt5ctypeIwE8_DowidenEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE8_DowidenEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE8do_widenEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE8do_widenEc)
# define CPPTEST_IMP__ZNKSt5ctypeIwE8do_widenEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE8do_widenEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE8do_widenEPKcS2_Pw
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE8do_widenEPKcS2_Pw)
# define CPPTEST_IMP__ZNKSt5ctypeIwE8do_widenEPKcS2_Pw
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE8do_widenEPKcS2_Pw __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE9_DonarrowEwc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE9_DonarrowEwc)
# define CPPTEST_IMP__ZNKSt5ctypeIwE9_DonarrowEwc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE9_DonarrowEwc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE9do_narrowEwc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE9do_narrowEwc)
# define CPPTEST_IMP__ZNKSt5ctypeIwE9do_narrowEwc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE9do_narrowEwc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIwE9do_narrowEPKwS2_cPc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIwE9do_narrowEPKwS2_cPc)
# define CPPTEST_IMP__ZNKSt5ctypeIwE9do_narrowEPKwS2_cPc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIwE9do_narrowEPKwS2_cPc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE2isEst
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE2isEst)
# define CPPTEST_IMP__ZNKSt5ctypeItE2isEst
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE2isEst __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE2isEPKtS2_Ps
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE2isEPKtS2_Ps)
# define CPPTEST_IMP__ZNKSt5ctypeItE2isEPKtS2_Ps
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE2isEPKtS2_Ps __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE7scan_isEsPKtS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE7scan_isEsPKtS2_)
# define CPPTEST_IMP__ZNKSt5ctypeItE7scan_isEsPKtS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE7scan_isEsPKtS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE8scan_notEsPKtS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE8scan_notEsPKtS2_)
# define CPPTEST_IMP__ZNKSt5ctypeItE8scan_notEsPKtS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE8scan_notEsPKtS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE7tolowerEt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE7tolowerEt)
# define CPPTEST_IMP__ZNKSt5ctypeItE7tolowerEt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE7tolowerEt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE7tolowerEPtPKt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE7tolowerEPtPKt)
# define CPPTEST_IMP__ZNKSt5ctypeItE7tolowerEPtPKt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE7tolowerEPtPKt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE7toupperEt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE7toupperEt)
# define CPPTEST_IMP__ZNKSt5ctypeItE7toupperEt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE7toupperEt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE7toupperEPtPKt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE7toupperEPtPKt)
# define CPPTEST_IMP__ZNKSt5ctypeItE7toupperEPtPKt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE7toupperEPtPKt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE5widenEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE5widenEc)
# define CPPTEST_IMP__ZNKSt5ctypeItE5widenEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE5widenEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE5widenEPKcS2_Pt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE5widenEPKcS2_Pt)
# define CPPTEST_IMP__ZNKSt5ctypeItE5widenEPKcS2_Pt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE5widenEPKcS2_Pt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE6narrowEtc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE6narrowEtc)
# define CPPTEST_IMP__ZNKSt5ctypeItE6narrowEtc
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE6narrowEtc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE6narrowEPKtS2_cPc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE6narrowEPKtS2_cPc)
# define CPPTEST_IMP__ZNKSt5ctypeItE6narrowEPKtS2_cPc
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE6narrowEPKtS2_cPc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeItEC9Ej
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeItEC9Ej)
# define CPPTEST_IMP__ZNSt5ctypeItEC9Ej
#else
# define CPPTEST_IMP__ZNSt5ctypeItEC9Ej __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeItEC9ERKSt8_Locinfoj
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeItEC9ERKSt8_Locinfoj)
# define CPPTEST_IMP__ZNSt5ctypeItEC9ERKSt8_Locinfoj
#else
# define CPPTEST_IMP__ZNSt5ctypeItEC9ERKSt8_Locinfoj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeItE7_GetcatEPPKNSt6locale5facetEPKS1_
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeItE7_GetcatEPPKNSt6locale5facetEPKS1_)
# define CPPTEST_IMP__ZNSt5ctypeItE7_GetcatEPPKNSt6locale5facetEPKS1_
#else
# define CPPTEST_IMP__ZNSt5ctypeItE7_GetcatEPPKNSt6locale5facetEPKS1_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeItED9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeItED9Ev)
# define CPPTEST_IMP__ZNSt5ctypeItED9Ev
#else
# define CPPTEST_IMP__ZNSt5ctypeItED9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeItE5_InitERKSt8_Locinfo
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeItE5_InitERKSt8_Locinfo)
# define CPPTEST_IMP__ZNSt5ctypeItE5_InitERKSt8_Locinfo
#else
# define CPPTEST_IMP__ZNSt5ctypeItE5_InitERKSt8_Locinfo __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE5do_isEst
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE5do_isEst)
# define CPPTEST_IMP__ZNKSt5ctypeItE5do_isEst
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE5do_isEst __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE5do_isEPKtS2_Ps
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE5do_isEPKtS2_Ps)
# define CPPTEST_IMP__ZNKSt5ctypeItE5do_isEPKtS2_Ps
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE5do_isEPKtS2_Ps __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE10do_scan_isEsPKtS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE10do_scan_isEsPKtS2_)
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_scan_isEsPKtS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_scan_isEsPKtS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE11do_scan_notEsPKtS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE11do_scan_notEsPKtS2_)
# define CPPTEST_IMP__ZNKSt5ctypeItE11do_scan_notEsPKtS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE11do_scan_notEsPKtS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE10do_tolowerEt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE10do_tolowerEt)
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_tolowerEt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_tolowerEt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE10do_tolowerEPtPKt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE10do_tolowerEPtPKt)
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_tolowerEPtPKt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_tolowerEPtPKt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE10do_toupperEt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE10do_toupperEt)
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_toupperEt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_toupperEt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE10do_toupperEPtPKt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE10do_toupperEPtPKt)
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_toupperEPtPKt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE10do_toupperEPtPKt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE8_DowidenEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE8_DowidenEc)
# define CPPTEST_IMP__ZNKSt5ctypeItE8_DowidenEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE8_DowidenEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE8do_widenEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE8do_widenEc)
# define CPPTEST_IMP__ZNKSt5ctypeItE8do_widenEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE8do_widenEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE8do_widenEPKcS2_Pt
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE8do_widenEPKcS2_Pt)
# define CPPTEST_IMP__ZNKSt5ctypeItE8do_widenEPKcS2_Pt
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE8do_widenEPKcS2_Pt __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE9_DonarrowEtc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE9_DonarrowEtc)
# define CPPTEST_IMP__ZNKSt5ctypeItE9_DonarrowEtc
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE9_DonarrowEtc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE9do_narrowEtc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE9do_narrowEtc)
# define CPPTEST_IMP__ZNKSt5ctypeItE9do_narrowEtc
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE9do_narrowEtc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeItE9do_narrowEPKtS2_cPc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeItE9do_narrowEPKtS2_cPc)
# define CPPTEST_IMP__ZNKSt5ctypeItE9do_narrowEPKtS2_cPc
#else
# define CPPTEST_IMP__ZNKSt5ctypeItE9do_narrowEPKtS2_cPc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt10ctype_baseC9Ej
#if defined(CPPTEST_UNDEFINED__ZNSt10ctype_baseC9Ej)
# define CPPTEST_IMP__ZNSt10ctype_baseC9Ej
#else
# define CPPTEST_IMP__ZNSt10ctype_baseC9Ej __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt10ctype_baseD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt10ctype_baseD9Ev)
# define CPPTEST_IMP__ZNSt10ctype_baseD9Ev
#else
# define CPPTEST_IMP__ZNSt10ctype_baseD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE2isEsc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE2isEsc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE2isEsc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE2isEsc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE2isEPKcS2_Ps
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE2isEPKcS2_Ps)
# define CPPTEST_IMP__ZNKSt5ctypeIcE2isEPKcS2_Ps
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE2isEPKcS2_Ps __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE7scan_isEsPKcS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE7scan_isEsPKcS2_)
# define CPPTEST_IMP__ZNKSt5ctypeIcE7scan_isEsPKcS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE7scan_isEsPKcS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE8scan_notEsPKcS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE8scan_notEsPKcS2_)
# define CPPTEST_IMP__ZNKSt5ctypeIcE8scan_notEsPKcS2_
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE8scan_notEsPKcS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE7tolowerEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE7tolowerEc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE7tolowerEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE7tolowerEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE7tolowerEPcPKc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE7tolowerEPcPKc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE7tolowerEPcPKc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE7tolowerEPcPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE7toupperEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE7toupperEc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE7toupperEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE7toupperEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE7toupperEPcPKc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE7toupperEPcPKc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE7toupperEPcPKc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE7toupperEPcPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE5widenEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE5widenEc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE5widenEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE5widenEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE5widenEPKcS2_Pc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE5widenEPKcS2_Pc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE5widenEPKcS2_Pc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE5widenEPKcS2_Pc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE6narrowEcc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE6narrowEcc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE6narrowEcc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE6narrowEcc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE6narrowEPKcS2_cPc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE6narrowEPKcS2_cPc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE6narrowEPKcS2_cPc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE6narrowEPKcS2_cPc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIcEC9EPKsbj
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIcEC9EPKsbj)
# define CPPTEST_IMP__ZNSt5ctypeIcEC9EPKsbj
#else
# define CPPTEST_IMP__ZNSt5ctypeIcEC9EPKsbj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIcEC9ERKSt8_Locinfoj
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIcEC9ERKSt8_Locinfoj)
# define CPPTEST_IMP__ZNSt5ctypeIcEC9ERKSt8_Locinfoj
#else
# define CPPTEST_IMP__ZNSt5ctypeIcEC9ERKSt8_Locinfoj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIcE7_GetcatEPPKNSt6locale5facetEPKS1_
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIcE7_GetcatEPPKNSt6locale5facetEPKS1_)
# define CPPTEST_IMP__ZNSt5ctypeIcE7_GetcatEPPKNSt6locale5facetEPKS1_
#else
# define CPPTEST_IMP__ZNSt5ctypeIcE7_GetcatEPPKNSt6locale5facetEPKS1_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE5tableEv
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE5tableEv)
# define CPPTEST_IMP__ZNKSt5ctypeIcE5tableEv
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE5tableEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIcE13classic_tableEv
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIcE13classic_tableEv)
# define CPPTEST_IMP__ZNSt5ctypeIcE13classic_tableEv
#else
# define CPPTEST_IMP__ZNSt5ctypeIcE13classic_tableEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIcED9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIcED9Ev)
# define CPPTEST_IMP__ZNSt5ctypeIcED9Ev
#else
# define CPPTEST_IMP__ZNSt5ctypeIcED9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIcE5_InitERKSt8_Locinfo
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIcE5_InitERKSt8_Locinfo)
# define CPPTEST_IMP__ZNSt5ctypeIcE5_InitERKSt8_Locinfo
#else
# define CPPTEST_IMP__ZNSt5ctypeIcE5_InitERKSt8_Locinfo __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt5ctypeIcE5_TidyEv
#if defined(CPPTEST_UNDEFINED__ZNSt5ctypeIcE5_TidyEv)
# define CPPTEST_IMP__ZNSt5ctypeIcE5_TidyEv
#else
# define CPPTEST_IMP__ZNSt5ctypeIcE5_TidyEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE10do_tolowerEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE10do_tolowerEc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE10do_tolowerEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE10do_tolowerEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE10do_tolowerEPcPKc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE10do_tolowerEPcPKc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE10do_tolowerEPcPKc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE10do_tolowerEPcPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE10do_toupperEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE10do_toupperEc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE10do_toupperEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE10do_toupperEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE10do_toupperEPcPKc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE10do_toupperEPcPKc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE10do_toupperEPcPKc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE10do_toupperEPcPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE8do_widenEc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE8do_widenEc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE8do_widenEc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE8do_widenEc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE8do_widenEPKcS2_Pc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE8do_widenEPKcS2_Pc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE8do_widenEPKcS2_Pc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE8do_widenEPKcS2_Pc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE9do_narrowEcc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE9do_narrowEcc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE9do_narrowEcc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE9do_narrowEcc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc
#if defined(CPPTEST_UNDEFINED__ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc)
# define CPPTEST_IMP__ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc
#else
# define CPPTEST_IMP__ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIcE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIcE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIcE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIcE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIcE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIcE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIcE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIcE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIcE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIcE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIcE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIcE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIcE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIcE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIcE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIcE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIcE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIcE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIcE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIwE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIwE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIwE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIwE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIwE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIwE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIwE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIwE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIwE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIwE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIwE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIwE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIwE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIwE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIwE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIwE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIwE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIwE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIwE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIbE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIbE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIbE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIbE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIbE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIbE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIbE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIbE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIbE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIbE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIbE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIbE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIbE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIbE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIbE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIbE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIbE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIbE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIbE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIaE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIaE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIaE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIaE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIaE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIaE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIaE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIaE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIaE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIaE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIaE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIaE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIaE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIaE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIaE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIaE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIaE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIaE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIaE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIhE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIhE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIhE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIhE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIhE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIhE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIhE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIhE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIhE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIhE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIhE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIhE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIhE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIhE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIhE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIhE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIhE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIhE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIhE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIsE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIsE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIsE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIsE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIsE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIsE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIsE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIsE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIsE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIsE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIsE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIsE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIsE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIsE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIsE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIsE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIsE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIsE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIsE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsItE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsItE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsItE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsItE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsItE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsItE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsItE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsItE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsItE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsItE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsItE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsItE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsItE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsItE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsItE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsItE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsItE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsItE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsItE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsItE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsItE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsItE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsItE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsItE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsItE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsItE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsItE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsItE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsItE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsItE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsItE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsItE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsItE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsItE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsItE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsItE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIiE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIiE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIiE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIiE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIiE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIiE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIiE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIiE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIiE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIiE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIiE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIiE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIiE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIiE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIiE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIiE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIiE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIiE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIiE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIjE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIjE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIjE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIjE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIjE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIjE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIjE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIjE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIjE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIjE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIjE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIjE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIjE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIjE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIjE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIjE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIjE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIjE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIjE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIlE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIlE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIlE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIlE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIlE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIlE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIlE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIlE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIlE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIlE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIlE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIlE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIlE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIlE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIlE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIlE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIlE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIlE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIlE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsImE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsImE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsImE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsImE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsImE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsImE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsImE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsImE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsImE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsImE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsImE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsImE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsImE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsImE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsImE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsImE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsImE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsImE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsImE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsImE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsImE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsImE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsImE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsImE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsImE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsImE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsImE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsImE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsImE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsImE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsImE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsImE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsImE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsImE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsImE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsImE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIxE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIxE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIxE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIxE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIxE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIxE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIxE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIxE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIxE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIxE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIxE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIxE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIxE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIxE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIxE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIxE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIxE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIxE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIxE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIyE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIyE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIyE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIyE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIyE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIyE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIyE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIyE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIyE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIyE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIyE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIyE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIyE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIyE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIyE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIyE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIyE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIyE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIyE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIfE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIfE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIfE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIfE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIfE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIfE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIfE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIfE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIfE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIfE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIfE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIfE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIfE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIfE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIfE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIfE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIfE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIfE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIfE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIdE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIdE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIdE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIdE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIdE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIdE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIdE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIdE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIdE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIdE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIdE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIdE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIdE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIdE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIdE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIdE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIdE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIdE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIdE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIeE3minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIeE3minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE3minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE3minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIeE3maxEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIeE3maxEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE3maxEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE3maxEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIeE6lowestEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIeE6lowestEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE6lowestEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE6lowestEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIeE7epsilonEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIeE7epsilonEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE7epsilonEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE7epsilonEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIeE11round_errorEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIeE11round_errorEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE11round_errorEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE11round_errorEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIeE10denorm_minEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIeE10denorm_minEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE10denorm_minEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE10denorm_minEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIeE8infinityEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIeE8infinityEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE8infinityEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE8infinityEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIeE9quiet_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIeE9quiet_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE9quiet_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE9quiet_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt14numeric_limitsIeE13signaling_NaNEv
#if defined(CPPTEST_UNDEFINED__ZNSt14numeric_limitsIeE13signaling_NaNEv)
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE13signaling_NaNEv
#else
# define CPPTEST_IMP__ZNSt14numeric_limitsIeE13signaling_NaNEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt16_Container_base011_Orphan_allEv
#if defined(CPPTEST_UNDEFINED__ZNSt16_Container_base011_Orphan_allEv)
# define CPPTEST_IMP__ZNSt16_Container_base011_Orphan_allEv
#else
# define CPPTEST_IMP__ZNSt16_Container_base011_Orphan_allEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt16_Container_base09_Swap_allERS_
#if defined(CPPTEST_UNDEFINED__ZNSt16_Container_base09_Swap_allERS_)
# define CPPTEST_IMP__ZNSt16_Container_base09_Swap_allERS_
#else
# define CPPTEST_IMP__ZNSt16_Container_base09_Swap_allERS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8bad_castC9EPKc
#if defined(CPPTEST_UNDEFINED__ZNSt8bad_castC9EPKc)
# define CPPTEST_IMP__ZNSt8bad_castC9EPKc
#else
# define CPPTEST_IMP__ZNSt8bad_castC9EPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8bad_castC9ERKS_
#if defined(CPPTEST_UNDEFINED__ZNSt8bad_castC9ERKS_)
# define CPPTEST_IMP__ZNSt8bad_castC9ERKS_
#else
# define CPPTEST_IMP__ZNSt8bad_castC9ERKS_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt8bad_castD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt8bad_castD9Ev)
# define CPPTEST_IMP__ZNSt8bad_castD9Ev
#else
# define CPPTEST_IMP__ZNSt8bad_castD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt12codecvt_baseC9Ej
#if defined(CPPTEST_UNDEFINED__ZNSt12codecvt_baseC9Ej)
# define CPPTEST_IMP__ZNSt12codecvt_baseC9Ej
#else
# define CPPTEST_IMP__ZNSt12codecvt_baseC9Ej __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt12codecvt_base13always_noconvEv
#if defined(CPPTEST_UNDEFINED__ZNKSt12codecvt_base13always_noconvEv)
# define CPPTEST_IMP__ZNKSt12codecvt_base13always_noconvEv
#else
# define CPPTEST_IMP__ZNKSt12codecvt_base13always_noconvEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt12codecvt_base10max_lengthEv
#if defined(CPPTEST_UNDEFINED__ZNKSt12codecvt_base10max_lengthEv)
# define CPPTEST_IMP__ZNKSt12codecvt_base10max_lengthEv
#else
# define CPPTEST_IMP__ZNKSt12codecvt_base10max_lengthEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt12codecvt_base8encodingEv
#if defined(CPPTEST_UNDEFINED__ZNKSt12codecvt_base8encodingEv)
# define CPPTEST_IMP__ZNKSt12codecvt_base8encodingEv
#else
# define CPPTEST_IMP__ZNKSt12codecvt_base8encodingEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt12codecvt_baseD9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt12codecvt_baseD9Ev)
# define CPPTEST_IMP__ZNSt12codecvt_baseD9Ev
#else
# define CPPTEST_IMP__ZNSt12codecvt_baseD9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt12codecvt_base16do_always_noconvEv
#if defined(CPPTEST_UNDEFINED__ZNKSt12codecvt_base16do_always_noconvEv)
# define CPPTEST_IMP__ZNKSt12codecvt_base16do_always_noconvEv
#else
# define CPPTEST_IMP__ZNKSt12codecvt_base16do_always_noconvEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt12codecvt_base13do_max_lengthEv
#if defined(CPPTEST_UNDEFINED__ZNKSt12codecvt_base13do_max_lengthEv)
# define CPPTEST_IMP__ZNKSt12codecvt_base13do_max_lengthEv
#else
# define CPPTEST_IMP__ZNKSt12codecvt_base13do_max_lengthEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt12codecvt_base11do_encodingEv
#if defined(CPPTEST_UNDEFINED__ZNKSt12codecvt_base11do_encodingEv)
# define CPPTEST_IMP__ZNKSt12codecvt_base11do_encodingEv
#else
# define CPPTEST_IMP__ZNKSt12codecvt_base11do_encodingEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE2inERiPKcS3_RS3_PwS5_RS5_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE2inERiPKcS3_RS3_PwS5_RS5_)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE2inERiPKcS3_RS3_PwS5_RS5_
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE2inERiPKcS3_RS3_PwS5_RS5_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE3outERiPKwS3_RS3_PcS5_RS5_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE3outERiPKwS3_RS3_PcS5_RS5_)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE3outERiPKwS3_RS3_PcS5_RS5_
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE3outERiPKwS3_RS3_PcS5_RS5_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE7unshiftERiPcS2_RS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE7unshiftERiPcS2_RS2_)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE7unshiftERiPcS2_RS2_
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE7unshiftERiPcS2_RS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE6lengthERKiPKcS4_j
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE6lengthERKiPKcS4_j)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE6lengthERKiPKcS4_j
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE6lengthERKiPKcS4_j __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtIwciEC9Ej
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtIwciEC9Ej)
# define CPPTEST_IMP__ZNSt7codecvtIwciEC9Ej
#else
# define CPPTEST_IMP__ZNSt7codecvtIwciEC9Ej __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtIwciEC9ERKSt8_Locinfoj
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtIwciEC9ERKSt8_Locinfoj)
# define CPPTEST_IMP__ZNSt7codecvtIwciEC9ERKSt8_Locinfoj
#else
# define CPPTEST_IMP__ZNSt7codecvtIwciEC9ERKSt8_Locinfoj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtIwciE7_GetcatEPPKNSt6locale5facetEPKS1_
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtIwciE7_GetcatEPPKNSt6locale5facetEPKS1_)
# define CPPTEST_IMP__ZNSt7codecvtIwciE7_GetcatEPPKNSt6locale5facetEPKS1_
#else
# define CPPTEST_IMP__ZNSt7codecvtIwciE7_GetcatEPPKNSt6locale5facetEPKS1_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtIwciED9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtIwciED9Ev)
# define CPPTEST_IMP__ZNSt7codecvtIwciED9Ev
#else
# define CPPTEST_IMP__ZNSt7codecvtIwciED9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtIwciE5_InitERKSt8_Locinfo
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtIwciE5_InitERKSt8_Locinfo)
# define CPPTEST_IMP__ZNSt7codecvtIwciE5_InitERKSt8_Locinfo
#else
# define CPPTEST_IMP__ZNSt7codecvtIwciE5_InitERKSt8_Locinfo __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE5do_inERiPKcS3_RS3_PwS5_RS5_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE5do_inERiPKcS3_RS3_PwS5_RS5_)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE5do_inERiPKcS3_RS3_PwS5_RS5_
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE5do_inERiPKcS3_RS3_PwS5_RS5_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE6do_outERiPKwS3_RS3_PcS5_RS5_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE6do_outERiPKwS3_RS3_PcS5_RS5_)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE6do_outERiPKwS3_RS3_PcS5_RS5_
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE6do_outERiPKwS3_RS3_PcS5_RS5_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE10do_unshiftERiPcS2_RS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE10do_unshiftERiPcS2_RS2_)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE10do_unshiftERiPcS2_RS2_
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE10do_unshiftERiPcS2_RS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE9do_lengthERKiPKcS4_j
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE9do_lengthERKiPKcS4_j)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE9do_lengthERKiPKcS4_j
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE9do_lengthERKiPKcS4_j __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE16do_always_noconvEv
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE16do_always_noconvEv)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE16do_always_noconvEv
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE16do_always_noconvEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtIwciE13do_max_lengthEv
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtIwciE13do_max_lengthEv)
# define CPPTEST_IMP__ZNKSt7codecvtIwciE13do_max_lengthEv
#else
# define CPPTEST_IMP__ZNKSt7codecvtIwciE13do_max_lengthEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE2inERiPKcS3_RS3_PtS5_RS5_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE2inERiPKcS3_RS3_PtS5_RS5_)
# define CPPTEST_IMP__ZNKSt7codecvtItciE2inERiPKcS3_RS3_PtS5_RS5_
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE2inERiPKcS3_RS3_PtS5_RS5_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE3outERiPKtS3_RS3_PcS5_RS5_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE3outERiPKtS3_RS3_PcS5_RS5_)
# define CPPTEST_IMP__ZNKSt7codecvtItciE3outERiPKtS3_RS3_PcS5_RS5_
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE3outERiPKtS3_RS3_PcS5_RS5_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE7unshiftERiPcS2_RS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE7unshiftERiPcS2_RS2_)
# define CPPTEST_IMP__ZNKSt7codecvtItciE7unshiftERiPcS2_RS2_
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE7unshiftERiPcS2_RS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE6lengthERKiPKcS4_j
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE6lengthERKiPKcS4_j)
# define CPPTEST_IMP__ZNKSt7codecvtItciE6lengthERKiPKcS4_j
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE6lengthERKiPKcS4_j __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtItciEC9Ej
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtItciEC9Ej)
# define CPPTEST_IMP__ZNSt7codecvtItciEC9Ej
#else
# define CPPTEST_IMP__ZNSt7codecvtItciEC9Ej __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtItciEC9ERKSt8_Locinfoj
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtItciEC9ERKSt8_Locinfoj)
# define CPPTEST_IMP__ZNSt7codecvtItciEC9ERKSt8_Locinfoj
#else
# define CPPTEST_IMP__ZNSt7codecvtItciEC9ERKSt8_Locinfoj __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtItciE7_GetcatEPPKNSt6locale5facetEPKS1_
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtItciE7_GetcatEPPKNSt6locale5facetEPKS1_)
# define CPPTEST_IMP__ZNSt7codecvtItciE7_GetcatEPPKNSt6locale5facetEPKS1_
#else
# define CPPTEST_IMP__ZNSt7codecvtItciE7_GetcatEPPKNSt6locale5facetEPKS1_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtItciED9Ev
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtItciED9Ev)
# define CPPTEST_IMP__ZNSt7codecvtItciED9Ev
#else
# define CPPTEST_IMP__ZNSt7codecvtItciED9Ev __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNSt7codecvtItciE5_InitERKSt8_Locinfo
#if defined(CPPTEST_UNDEFINED__ZNSt7codecvtItciE5_InitERKSt8_Locinfo)
# define CPPTEST_IMP__ZNSt7codecvtItciE5_InitERKSt8_Locinfo
#else
# define CPPTEST_IMP__ZNSt7codecvtItciE5_InitERKSt8_Locinfo __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE5do_inERiPKcS3_RS3_PtS5_RS5_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE5do_inERiPKcS3_RS3_PtS5_RS5_)
# define CPPTEST_IMP__ZNKSt7codecvtItciE5do_inERiPKcS3_RS3_PtS5_RS5_
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE5do_inERiPKcS3_RS3_PtS5_RS5_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE6do_outERiPKtS3_RS3_PcS5_RS5_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE6do_outERiPKtS3_RS3_PcS5_RS5_)
# define CPPTEST_IMP__ZNKSt7codecvtItciE6do_outERiPKtS3_RS3_PcS5_RS5_
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE6do_outERiPKtS3_RS3_PcS5_RS5_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE10do_unshiftERiPcS2_RS2_
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE10do_unshiftERiPcS2_RS2_)
# define CPPTEST_IMP__ZNKSt7codecvtItciE10do_unshiftERiPcS2_RS2_
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE10do_unshiftERiPcS2_RS2_ __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE9do_lengthERKiPKcS4_j
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE9do_lengthERKiPKcS4_j)
# define CPPTEST_IMP__ZNKSt7codecvtItciE9do_lengthERKiPKcS4_j
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE9do_lengthERKiPKcS4_j __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE16do_always_noconvEv
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE16do_always_noconvEv)
# define CPPTEST_IMP__ZNKSt7codecvtItciE16do_always_noconvEv
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE16do_always_noconvEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZNKSt7codecvtItciE13do_max_lengthEv
#if defined(CPPTEST_UNDEFINED__ZNKSt7codecvtItciE13do_max_lengthEv)
# define CPPTEST_IMP__ZNKSt7codecvtItciE13do_max_lengthEv
#else
# define CPPTEST_IMP__ZNKSt7codecvtItciE13do_max_lengthEv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZSt18uncaught_exceptionv
#if defined(CPPTEST_UNDEFINED__ZSt18uncaught_exceptionv)
# define CPPTEST_IMP__ZSt18uncaught_exceptionv
#else
# define CPPTEST_IMP__ZSt18uncaught_exceptionv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZSt14_Debug_messagePKwS0_j
#if defined(CPPTEST_UNDEFINED__ZSt14_Debug_messagePKwS0_j)
# define CPPTEST_IMP__ZSt14_Debug_messagePKwS0_j
#else
# define CPPTEST_IMP__ZSt14_Debug_messagePKwS0_j __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZSt14_Xlength_errorPKc
#if defined(CPPTEST_UNDEFINED__ZSt14_Xlength_errorPKc)
# define CPPTEST_IMP__ZSt14_Xlength_errorPKc
#else
# define CPPTEST_IMP__ZSt14_Xlength_errorPKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZSt14_Xout_of_rangePKc
#if defined(CPPTEST_UNDEFINED__ZSt14_Xout_of_rangePKc)
# define CPPTEST_IMP__ZSt14_Xout_of_rangePKc
#else
# define CPPTEST_IMP__ZSt14_Xout_of_rangePKc __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZSt18_DebugHeapTag_funcv
#if defined(CPPTEST_UNDEFINED__ZSt18_DebugHeapTag_funcv)
# define CPPTEST_IMP__ZSt18_DebugHeapTag_funcv
#else
# define CPPTEST_IMP__ZSt18_DebugHeapTag_funcv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZSt17iostream_categoryv
#if defined(CPPTEST_UNDEFINED__ZSt17iostream_categoryv)
# define CPPTEST_IMP__ZSt17iostream_categoryv
#else
# define CPPTEST_IMP__ZSt17iostream_categoryv __declspec(dllimport)
#endif
#endif

#ifndef CPPTEST_IMP__ZSt4endlRSo
#if defined(CPPTEST_UNDEFINED__ZSt4endlRSo)
# define CPPTEST_IMP__ZSt4endlRSo
#else
# define CPPTEST_IMP__ZSt4endlRSo __declspec(dllimport)
#endif
#endif

#line 11 "C:\\Program Files\\Parasoft\\C++test for Visual Studio\\9.5\\engine\\runtime\\include\\cpptest_pre.h"
struct CppTest_Dummy_Type { 
char nonEmpty; 
}; 

struct CppTest_Safe_Dummy_Type { 
char nonEmpty; 
}; 

struct CppTest_Auto_Dummy_Type { 
char nonEmpty; 
}; 



typedef CppTest_Dummy_Type &CppTest_Dummy; 
static CppTest_Dummy_Type CppTest_Dummy_InstanceT; 
static CppTest_Dummy CppTest_Dummy_Instance = (CppTest_Dummy_InstanceT); 

typedef CppTest_Safe_Dummy_Type &CppTest_Safe_Dummy; 
static CppTest_Safe_Dummy_Type CppTest_Safe_Dummy_InstanceT; 
static CppTest_Safe_Dummy CppTest_Safe_Dummy_Instance = (CppTest_Safe_Dummy_InstanceT); 

typedef CppTest_Auto_Dummy_Type &CppTest_Auto_Dummy; 
static CppTest_Auto_Dummy_Type CppTest_Auto_Dummy_InstanceT; 
static CppTest_Auto_Dummy CppTest_Auto_Dummy_Instance = (CppTest_Auto_Dummy_InstanceT); 
#line 29 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\codeanalysis\\sourceannotations.h"
typedef unsigned __w64 size_t; 
#line 52
namespace vc_attributes { 



enum YesNoMaybe { 


No = 0xfff0001, 
Maybe = 0xfff0010, 
Yes = 0xfff0100
}; 

typedef YesNoMaybe YesNoMaybe; 

enum AccessType { 

NoAccess, 
Read, 
Write, 
ReadWrite
}; 

typedef AccessType AccessType; 



[repeatable, 
source_annotation_attribute ( Parameter )] 
struct PreAttribute { 


PreAttribute(); 


unsigned Deref; 
YesNoMaybe Valid; 
YesNoMaybe Null; 
YesNoMaybe Tainted; 
AccessType Access; 
size_t ValidElementsConst; 
size_t ValidBytesConst; 
const __wchar_t *ValidElements; 
const __wchar_t *ValidBytes; 
const __wchar_t *ValidElementsLength; 
const __wchar_t *ValidBytesLength; 
size_t WritableElementsConst; 
size_t WritableBytesConst; 
const __wchar_t *WritableElements; 
const __wchar_t *WritableBytes; 
const __wchar_t *WritableElementsLength; 
const __wchar_t *WritableBytesLength; 
size_t ElementSizeConst; 
const __wchar_t *ElementSize; 
YesNoMaybe NullTerminated; 
const __wchar_t *Condition; 
}; 

[repeatable, 
source_annotation_attribute ( Parameter | ReturnValue )] 
struct PostAttribute { 


PostAttribute(); 


unsigned Deref; 
YesNoMaybe Valid; 
YesNoMaybe Null; 
YesNoMaybe Tainted; 
AccessType Access; 
size_t ValidElementsConst; 
size_t ValidBytesConst; 
const __wchar_t *ValidElements; 
const __wchar_t *ValidBytes; 
const __wchar_t *ValidElementsLength; 
const __wchar_t *ValidBytesLength; 
size_t WritableElementsConst; 
size_t WritableBytesConst; 
const __wchar_t *WritableElements; 
const __wchar_t *WritableBytes; 
const __wchar_t *WritableElementsLength; 
const __wchar_t *WritableBytesLength; 
size_t ElementSizeConst; 
const __wchar_t *ElementSize; 
YesNoMaybe NullTerminated; 
YesNoMaybe MustCheck; 
const __wchar_t *Condition; 
}; 

[source_annotation_attribute ( Parameter )] 
struct FormatStringAttribute { 


FormatStringAttribute(); 


const __wchar_t *Style; 
const __wchar_t *UnformattedAlternative; 
}; 

[repeatable, 
source_annotation_attribute ( ReturnValue )] 
struct InvalidCheckAttribute { 


InvalidCheckAttribute(); 


long Value; 
}; 

[source_annotation_attribute ( Method )] 
struct SuccessAttribute { 


SuccessAttribute(); 


const __wchar_t *Condition; 
}; 

[repeatable, 
source_annotation_attribute ( Parameter )] 
struct PreBoundAttribute { 


PreBoundAttribute(); 

unsigned Deref; 
}; 

[repeatable, 
source_annotation_attribute ( Parameter | ReturnValue )] 
struct PostBoundAttribute { 


PostBoundAttribute(); 

unsigned Deref; 
}; 

[repeatable, 
source_annotation_attribute ( Parameter )] 
struct PreRangeAttribute { 


PreRangeAttribute(); 

unsigned Deref; 
const char *MinVal; 
const char *MaxVal; 
}; 

[repeatable, 
source_annotation_attribute ( Parameter | ReturnValue )] 
struct PostRangeAttribute { 


PostRangeAttribute(); 

unsigned Deref; 
const char *MinVal; 
const char *MaxVal; 
}; 




}
#line 244
typedef vc_attributes::YesNoMaybe SA_YesNoMaybe; 
const vc_attributes::YesNoMaybe SA_Yes = vc_attributes::Yes; 
const vc_attributes::YesNoMaybe SA_No = vc_attributes::No; 
const vc_attributes::YesNoMaybe SA_Maybe = vc_attributes::Maybe; 

typedef vc_attributes::AccessType SA_AccessType; 
const vc_attributes::AccessType SA_NoAccess = vc_attributes::NoAccess; 
const vc_attributes::AccessType SA_Read = vc_attributes::Read; 
const vc_attributes::AccessType SA_Write = vc_attributes::Write; 
const vc_attributes::AccessType SA_ReadWrite = vc_attributes::ReadWrite; 


typedef vc_attributes::PreAttribute SA_Pre; 
typedef vc_attributes::PostAttribute SA_Post; 
typedef vc_attributes::FormatStringAttribute SA_FormatString; 
typedef vc_attributes::InvalidCheckAttribute SA_InvalidCheck; 
typedef vc_attributes::SuccessAttribute SA_Success; 
typedef vc_attributes::PreBoundAttribute SA_PreBound; 
typedef vc_attributes::PostBoundAttribute SA_PostBound; 
typedef vc_attributes::PreRangeAttribute SA_PreRange; 
typedef vc_attributes::PostRangeAttribute SA_PostRange; 
#line 61 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#pragma pack ( push, 8 )
#line 29 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"
#pragma pack ( push, 8 )
#line 48
extern "C" { typedef unsigned __w64 uintptr_t; }
#line 57
extern "C" { typedef char *va_list; }
#line 146
#pragma pack ( pop )
#line 409 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef size_t rsize_t; }
#line 418
extern "C" { typedef int __w64 intptr_t; }
#line 436
extern "C" { typedef int __w64 ptrdiff_t; }
#line 447
extern "C" { typedef unsigned short wint_t; }
extern "C" { typedef unsigned short wctype_t; }
#line 469
extern "C" { typedef int errno_t; }



extern "C" { typedef long __w64 __time32_t; }




extern "C" { typedef __int64 __time64_t; }
#line 486
extern "C" { typedef __time64_t time_t; }
#line 543
extern "C" { __declspec(dllimport) void __cdecl _invalid_parameter(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); } 
#line 550
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl _invoke_watson(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); } 
#line 1953
struct threadlocaleinfostruct; 
struct threadmbcinfostruct; 
extern "C" { typedef threadlocaleinfostruct *pthreadlocinfo; }
extern "C" { typedef threadmbcinfostruct *pthreadmbcinfo; }
struct __lc_time_data; 
#line 1963
extern "C" { typedef 
#line 1959
struct localeinfo_struct { 

pthreadlocinfo locinfo; 
pthreadmbcinfo mbcinfo; 
} _locale_tstruct, *_locale_t; }
#line 1970
extern "C" { typedef 
#line 1966
struct tagLC_ID { 
unsigned short wLanguage; 
unsigned short wCountry; 
unsigned short wCodePage; 
} LC_ID, *LPLC_ID; }
#line 1999
extern "C" { typedef 
#line 1975
struct threadlocaleinfostruct { 
int refcount; 
unsigned lc_codepage; 
unsigned lc_collate_cp; 
unsigned long lc_handle[6]; 
LC_ID lc_id[6]; 
struct { 
char *locale; 
__wchar_t *wlocale; 
int *refcount; 
int *wrefcount; 
} lc_category[6]; 
int lc_clike; 
int mb_cur_max; 
int *lconv_intl_refcount; 
int *lconv_num_refcount; 
int *lconv_mon_refcount; 
struct lconv *lconv; 
int *ctype1_refcount; 
unsigned short *ctype1; 
const unsigned short *pctype; 
const unsigned char *pclmap; 
const unsigned char *pcumap; 
__lc_time_data *lc_time_curr; 
} threadlocinfo; }
#line 2036
#pragma pack ( pop )
#line 28 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
#pragma pack ( push, 8 )
#line 52
extern "C" { typedef int (__cdecl *_onexit_t)(void); }
#line 78
extern "C" { typedef 
#line 75
struct _div_t { 
int quot; 
int rem; 
} div_t; }




extern "C" { typedef 
#line 80
struct _ldiv_t { 
long quot; 
long rem; 
} ldiv_t; }




extern "C" { typedef 
#line 85
struct _lldiv_t { 
__int64 quot; 
__int64 rem; 
} lldiv_t; }
#line 102
#pragma pack ( 4 )


extern "C" { typedef 
#line 103
struct { 
unsigned char ld[10]; 
} _LDOUBLE; }
#pragma pack ( )
#line 124
extern "C" { typedef 
#line 122
struct { 
double x; 
} _CRT_DOUBLE; }



extern "C" { typedef 
#line 126
struct { 
float f; 
} _CRT_FLOAT; }
#line 139
extern "C" { typedef 
#line 134
struct { 



long double x; 
} _LONGDOUBLE; }



#pragma pack ( 4 )


extern "C" { typedef 
#line 144
struct { 
unsigned char ld12[12]; 
} _LDBL12; }
#pragma pack ( )
#line 163
extern "C" __declspec(dllimport) int __mb_cur_max; 




extern "C" { __declspec(dllimport) int __cdecl ___mb_cur_max_func(); } 
extern "C" { __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t); } 
#line 208
extern "C" { typedef void (__cdecl *_purecall_handler)(void); }


extern "C" { __declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(_purecall_handler _Handler); } 
extern "C" { __declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(); } 
#line 228
extern "C" { typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); }


extern "C" { __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler _Handler); } 
extern "C" { __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); } 
#line 249
extern "C" { __declspec(dllimport) extern int *__cdecl _errno(); } 


extern "C" { errno_t __cdecl _set_errno(int _Value); } 
extern "C" { errno_t __cdecl _get_errno(int * _Value); } 


extern "C" { __declspec(dllimport) unsigned long *__cdecl __doserrno(); } 


extern "C" { errno_t __cdecl _set_doserrno(unsigned long _Value); } 
extern "C" { errno_t __cdecl _get_doserrno(unsigned long * _Value); } 


extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using strerror instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) char **__cdecl __sys_errlist(); } 


extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using strerror instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) int *__cdecl __sys_nerr(); } 




extern "C" { __declspec(dllimport) int *__cdecl __p___argc(); } 
extern "C" { __declspec(dllimport) char ***__cdecl __p___argv(); } 
extern "C" { __declspec(dllimport) __wchar_t ***__cdecl __p___wargv(); } 
extern "C" { __declspec(dllimport) char ***__cdecl __p__environ(); } 
extern "C" { __declspec(dllimport) __wchar_t ***__cdecl __p__wenviron(); } 
extern "C" { __declspec(dllimport) char **__cdecl __p__pgmptr(); } 
extern "C" { __declspec(dllimport) __wchar_t **__cdecl __p__wpgmptr(); } 
#line 283
extern "C" __declspec(dllimport) int __argc; 
extern "C" __declspec(dllimport) char **__argv; 
extern "C" __declspec(dllimport) __wchar_t **__wargv; 
#line 299
extern "C" __declspec(dllimport) char **_environ; 
extern "C" __declspec(dllimport) __wchar_t **_wenviron; 


extern "C" __declspec(deprecated("This function or variable may be unsafe. Consider using _get_pgmptr instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) char *_pgmptr; 
extern "C" __declspec(deprecated("This function or variable may be unsafe. Consider using _get_wpgmptr instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) __wchar_t *_wpgmptr; 
#line 321
extern "C" { errno_t __cdecl _get_pgmptr(char ** _Value); } 
extern "C" { errno_t __cdecl _get_wpgmptr(__wchar_t ** _Value); } 



extern "C" __declspec(deprecated("This function or variable may be unsafe. Consider using _get_fmode instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) int _fmode; 
#line 332
extern "C" { __declspec(dllimport) errno_t __cdecl _set_fmode(int _Mode); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _get_fmode(int * _PMode); } 
#line 342
template < typename _CountofType, size_t _SizeOfArray >
char ( * __countof_helper ( _CountofType ( & _Array ) [ _SizeOfArray ] ) ) [ _SizeOfArray ];
#line 353
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl exit(int _Code); } 
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(int _Code); } 
extern "C" { __declspec(dllimport) void __cdecl abort(); } 


extern "C" { __declspec(dllimport) unsigned __cdecl _set_abort_behavior(unsigned _Flags, unsigned _Mask); } 



extern "C" { int __cdecl abs(int _X); } 
extern "C" { long __cdecl labs(long _X); } 
extern "C" { __int64 __cdecl llabs(__int64 _X); } 


extern "C" { __int64 __cdecl _abs64(__int64); } 
#line 398
extern "C" { int __cdecl atexit(void (__cdecl *)(void)); } 



extern "C" { __declspec(dllimport) double __cdecl atof(const char * _String); } 
extern "C" { __declspec(dllimport) double __cdecl _atof_l(const char * _String, _locale_t _Locale); } 

extern "C" { __declspec(dllimport) int __cdecl atoi(const char * _Str); } 
extern "C" { __declspec(dllimport) int __cdecl _atoi_l(const char * _Str, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) long __cdecl atol(const char * _Str); } 
extern "C" { __declspec(dllimport) long __cdecl _atol_l(const char * _Str, _locale_t _Locale); } 



extern "C" { __declspec(dllimport) void *__cdecl bsearch_s(const void * _Key, const void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context); } 



extern "C" { __declspec(dllimport) void *__cdecl bsearch(const void * _Key, const void * _Base, size_t _NumOfElements, size_t _SizeOfElements, int (__cdecl * _PtFuncCompare)(const void *, const void *)); } 




extern "C" { __declspec(dllimport) void __cdecl qsort_s(void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context); } 



extern "C" { __declspec(dllimport) void __cdecl qsort(void * _Base, size_t _NumOfElements, size_t _SizeOfElements, int (__cdecl * _PtFuncCompare)(const void *, const void *)); } 



extern "C" { unsigned short __cdecl _byteswap_ushort(unsigned short _Short); } 
extern "C" { unsigned long __cdecl _byteswap_ulong(unsigned long _Long); } 
extern "C" { unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Int64); } 
extern "C" { __declspec(dllimport) div_t __cdecl div(int _Numerator, int _Denominator); } 
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char *__cdecl getenv(const char * _VarName); } 

extern "C" { __declspec(dllimport) errno_t __cdecl getenv_s(size_t * _ReturnSize, char * _DstBuf, rsize_t _DstSize, const char * _VarName); } 

template < size_t _Size > inline errno_t __cdecl getenv_s ( size_t * _ReturnSize, char ( & _Dest ) [ _Size ], const char * _VarName ) throw ( ) { return getenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 443
extern "C" { __declspec(dllimport) errno_t __cdecl _dupenv_s(char ** _PBuffer, size_t * _PBufferSizeInBytes, const char * _VarName); } 
#line 449
extern "C" { __declspec(dllimport) errno_t __cdecl _itoa_s(int _Value, char * _DstBuf, size_t _Size, int _Radix); } 
template < size_t _Size > inline errno_t __cdecl _itoa_s ( int _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _itoa_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _itoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) char *__cdecl _itoa(int _Value, char * _Dest, int _Radix); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _i64toa_s(__int64 _Val, char * _DstBuf, size_t _Size, int _Radix); } 
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _i64toa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char *__cdecl _i64toa(__int64 _Val, char * _DstBuf, int _Radix); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _ui64toa_s(unsigned __int64 _Val, char * _DstBuf, size_t _Size, int _Radix); } 
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _ui64toa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) char *__cdecl _ui64toa(unsigned __int64 _Val, char * _DstBuf, int _Radix); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _atoi64(const char * _String); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _atoi64_l(const char * _String, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _strtoi64(const char * _String, char ** _EndPtr, int _Radix); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _strtoi64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(const char * _String, char ** _EndPtr, int _Radix); } 
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) ldiv_t __cdecl ldiv(long _Numerator, long _Denominator); } 
extern "C" { __declspec(dllimport) lldiv_t __cdecl lldiv(__int64 _Numerator, __int64 _Denominator); } 



inline long abs(long _X) 
{ 
return labs(_X); 
} 
inline __int64 abs(__int64 _X) 
{ 
return llabs(_X); 
} 
inline ldiv_t div(long _A1, long _A2) 
{ 
return ldiv(_A1, _A2); 
} 
inline lldiv_t div(__int64 _A1, __int64 _A2) 
{ 
return lldiv(_A1, _A2); 
} 


extern "C" { __declspec(dllimport) errno_t __cdecl _ltoa_s(long _Val, char * _DstBuf, size_t _Size, int _Radix); } 
template < size_t _Size > inline errno_t __cdecl _ltoa_s ( long _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ltoa_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _ltoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) char *__cdecl _ltoa(long _Value, char * _Dest, int _Radix); } 
extern "C" { __declspec(dllimport) int __cdecl mblen(const char * _Ch, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) int __cdecl _mblen_l(const char * _Ch, size_t _MaxCount, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrlen(const char * _Str); } 
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrlen_l(const char * _Str, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrnlen(const char * _Str, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrnlen_l(const char * _Str, size_t _MaxCount, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl mbtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes); } 
extern "C" { __declspec(dllimport) int __cdecl _mbtowc_l(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) errno_t __cdecl mbstowcs_s(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount); } 
template < size_t _Size > inline errno_t __cdecl mbstowcs_s ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount ) throw ( ) { return mbstowcs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using mbstowcs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs(__wchar_t * _Dest, const char * _Source, size_t _MaxCount); } 

extern "C" { __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount, _locale_t _Locale); } 
template < size_t _Size > inline errno_t __cdecl _mbstowcs_s_l ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _mbstowcs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _mbstowcs_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNIN" "GS. See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(__wchar_t * _Dest, const char * _Source, size_t _MaxCount, _locale_t _Locale); } 

extern "C" { __declspec(dllimport) int __cdecl rand(); } 




extern "C" { __declspec(dllimport) int __cdecl _set_error_mode(int _Mode); } 

extern "C" { __declspec(dllimport) void __cdecl srand(unsigned _Seed); } 
extern "C" { __declspec(dllimport) double __cdecl strtod(const char * _Str, char ** _EndPtr); } 
extern "C" { __declspec(dllimport) double __cdecl _strtod_l(const char * _Str, char ** _EndPtr, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) long __cdecl strtol(const char * _Str, char ** _EndPtr, int _Radix); } 
extern "C" { __declspec(dllimport) long __cdecl _strtol_l(const char * _Str, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) unsigned long __cdecl strtoul(const char * _Str, char ** _EndPtr, int _Radix); } 
extern "C" { __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _Str, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
#if !defined(CppTest_Stub_system_system) && defined(CPPTEST_USER_STUB_system)
extern "C" { int __cdecl CppTest_Stub_system_system(const char * _Command); } 
#endif

#if !defined(CppTest_Safe_Stub_system_system) && defined(CPPTEST_SAFE_STUB_system)
extern "C" { int __cdecl CppTest_Safe_Stub_system_system(const char * _Command); } 
#endif

#if !defined(CppTest_Auto_Stub_system_system) && defined(CPPTEST_AUTO_STUB_system)
extern "C" { int __cdecl CppTest_Auto_Stub_system_system(const char * _Command); } 
#endif
#line 520
extern "C" { CPPTEST_IMP_system int __cdecl system(const char * _Command); } 

extern "C" { __declspec(dllimport) errno_t __cdecl _ultoa_s(unsigned long _Val, char * _DstBuf, size_t _Size, int _Radix); } 
template < size_t _Size > inline errno_t __cdecl _ultoa_s ( unsigned long _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ultoa_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _ultoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) char *__cdecl _ultoa(unsigned long _Value, char * _Dest, int _Radix); } 
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using wctomb_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) int __cdecl wctomb(char * _MbCh, __wchar_t _WCh); } 
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctomb_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) int __cdecl _wctomb_l(char * _MbCh, __wchar_t _WCh, _locale_t _Locale); } 

extern "C" { __declspec(dllimport) errno_t __cdecl wctomb_s(int * _SizeConverted, char * _MbCh, rsize_t _SizeInBytes, __wchar_t _WCh); } 

extern "C" { __declspec(dllimport) errno_t __cdecl _wctomb_s_l(int * _SizeConverted, char * _MbCh, size_t _SizeInBytes, __wchar_t _WCh, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) errno_t __cdecl wcstombs_s(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes); } 
template < size_t _Size > inline errno_t __cdecl wcstombs_s ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount ) throw ( ) { return wcstombs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using wcstombs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs(char * _Dest, const __wchar_t * _Source, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes, _locale_t _Locale); } 
template < size_t _Size > inline errno_t __cdecl _wcstombs_s_l ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _wcstombs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wcstombs_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNIN" "GS. See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(char * _Dest, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); } 
#line 598
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl calloc(size_t _Count, size_t _Size); } 
extern "C" { CPPTEST_IMP_free __declspec(noalias) void __cdecl free(void * _Memory); } 
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl malloc(size_t _Size); } 

extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl realloc(void * _Memory, size_t _NewSize); } 

extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _recalloc(void * _Memory, size_t _Count, size_t _Size); } 
extern "C" { __declspec(dllimport) __declspec(noalias) void __cdecl _aligned_free(void * _Memory); } 
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_malloc(size_t _Size, size_t _Alignment); } 
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset); } 

extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_realloc(void * _Memory, size_t _NewSize, size_t _Alignment); } 

extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_recalloc(void * _Memory, size_t _Count, size_t _Size, size_t _Alignment); } 

extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_realloc(void * _Memory, size_t _NewSize, size_t _Alignment, size_t _Offset); } 

extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_recalloc(void * _Memory, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset); } 
extern "C" { __declspec(dllimport) size_t __cdecl _aligned_msize(void * _Memory, size_t _Alignment, size_t _Offset); } 
#line 643
extern "C" { __declspec(dllimport) errno_t __cdecl _itow_s(int _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
template < size_t _Size > inline errno_t __cdecl _itow_s ( int _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _itow_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _itow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _itow(int _Value, __wchar_t * _Dest, int _Radix); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _ltow_s(long _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
template < size_t _Size > inline errno_t __cdecl _ltow_s ( long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ltow_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _ltow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _ltow(long _Value, __wchar_t * _Dest, int _Radix); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _ultow_s(unsigned long _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
template < size_t _Size > inline errno_t __cdecl _ultow_s ( unsigned long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ultow_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _ultow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _ultow(unsigned long _Value, __wchar_t * _Dest, int _Radix); } 
extern "C" { __declspec(dllimport) double __cdecl wcstod(const __wchar_t * _Str, __wchar_t ** _EndPtr); } 
extern "C" { __declspec(dllimport) double __cdecl _wcstod_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) long __cdecl wcstol(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
extern "C" { __declspec(dllimport) long __cdecl _wcstol_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) unsigned long __cdecl wcstoul(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
extern "C" { __declspec(dllimport) unsigned long __cdecl _wcstoul_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _wdupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __wchar_t *__cdecl _wgetenv(const __wchar_t * _VarName); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wgetenv_s(size_t * _ReturnSize, __wchar_t * _DstBuf, size_t _DstSizeInWords, const __wchar_t * _VarName); } 
template < size_t _Size > inline errno_t __cdecl _wgetenv_s ( size_t * _ReturnSize, wchar_t ( & _Dest ) [ _Size ], const wchar_t * _VarName ) throw ( ) { return _wgetenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 667
extern "C" { __declspec(dllimport) errno_t __cdecl _wdupenv_s(__wchar_t ** _Buffer, size_t * _BufferSizeInWords, const __wchar_t * _VarName); } 
#line 675
extern "C" { __declspec(dllimport) int __cdecl _wsystem(const __wchar_t * _Command); } 

extern "C" { __declspec(dllimport) double __cdecl _wtof(const __wchar_t * _Str); } 
extern "C" { __declspec(dllimport) double __cdecl _wtof_l(const __wchar_t * _Str, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _wtoi(const __wchar_t * _Str); } 
extern "C" { __declspec(dllimport) int __cdecl _wtoi_l(const __wchar_t * _Str, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) long __cdecl _wtol(const __wchar_t * _Str); } 
extern "C" { __declspec(dllimport) long __cdecl _wtol_l(const __wchar_t * _Str, _locale_t _Locale); } 

extern "C" { __declspec(dllimport) errno_t __cdecl _i64tow_s(__int64 _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _i64tow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __wchar_t *__cdecl _i64tow(__int64 _Val, __wchar_t * _DstBuf, int _Radix); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _ui64tow_s(unsigned __int64 _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _ui64tow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __wchar_t *__cdecl _ui64tow(unsigned __int64 _Val, __wchar_t * _DstBuf, int _Radix); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoi64(const __wchar_t * _Str); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoi64_l(const __wchar_t * _Str, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _wcstoi64(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _wcstoi64_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 713
extern "C" { __declspec(dllimport) char *__cdecl _fullpath(char * _FullPath, const char * _Path, size_t _SizeInBytes); } 
#line 721
extern "C" { __declspec(dllimport) errno_t __cdecl _ecvt_s(char * _DstBuf, size_t _Size, double _Val, int _NumOfDights, int * _PtDec, int * _PtSign); } 
template < size_t _Size > inline errno_t __cdecl _ecvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) throw ( ) { return _ecvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _ecvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) char *__cdecl _ecvt(double _Val, int _NumOfDigits, int * _PtDec, int * _PtSign); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _fcvt_s(char * _DstBuf, size_t _Size, double _Val, int _NumOfDec, int * _PtDec, int * _PtSign); } 
template < size_t _Size > inline errno_t __cdecl _fcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) throw ( ) { return _fcvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) char *__cdecl _fcvt(double _Val, int _NumOfDec, int * _PtDec, int * _PtSign); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _gcvt_s(char * _DstBuf, size_t _Size, double _Val, int _NumOfDigits); } 
template < size_t _Size > inline errno_t __cdecl _gcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits ) throw ( ) { return _gcvt_s ( _Dest, _Size, _Value, _NumOfDigits ); }
extern "C" { __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using _gcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) char *__cdecl _gcvt(double _Val, int _NumOfDigits, char * _DstBuf); } 

extern "C" { __declspec(dllimport) int __cdecl _atodbl(_CRT_DOUBLE * _Result, char * _Str); } 
extern "C" { __declspec(dllimport) int __cdecl _atoldbl(_LDOUBLE * _Result, char * _Str); } 
extern "C" { __declspec(dllimport) int __cdecl _atoflt(_CRT_FLOAT * _Result, char * _Str); } 
extern "C" { __declspec(dllimport) int __cdecl _atodbl_l(_CRT_DOUBLE * _Result, char * _Str, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _atoldbl_l(_LDOUBLE * _Result, char * _Str, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _atoflt_l(_CRT_FLOAT * _Result, char * _Str, _locale_t _Locale); } 
extern "C" { unsigned long __cdecl _lrotl(unsigned long _Val, int _Shift); } 
extern "C" { unsigned long __cdecl _lrotr(unsigned long _Val, int _Shift); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _makepath_s(char * _PathResult, size_t _SizeInWords, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); } 

template < size_t _Size > inline errno_t __cdecl _makepath_s ( char ( & _Path ) [ _Size ], const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext ) throw ( ) { return _makepath_s ( _Path, _Size, _Drive, _Dir, _Filename, _Ext ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _makepath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) void __cdecl _makepath(char * _Path, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); } 
#line 769
extern "C" { _onexit_t __cdecl _onexit(_onexit_t _Func); } 




extern "C" { __declspec(dllimport) void __cdecl perror(const char * _ErrMsg); } 


/* Removed pragma: #pragma warning (push)*/
#pragma warning(disable: 6540) /* Removed pragma: #pragma warning (disable:6540)*/
extern "C" { __declspec(dllimport) int __cdecl _putenv(const char * _EnvString); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _putenv_s(const char * _Name, const char * _Value); } 
extern "C" { unsigned __cdecl _rotl(unsigned _Val, int _Shift); } 
extern "C" { unsigned __int64 __cdecl _rotl64(unsigned __int64 _Val, int _Shift); } 
extern "C" { unsigned __cdecl _rotr(unsigned _Val, int _Shift); } 
extern "C" { unsigned __int64 __cdecl _rotr64(unsigned __int64 _Val, int _Shift); } 
/* Removed pragma: #pragma warning (pop)*/

extern "C" { __declspec(dllimport) errno_t __cdecl _searchenv_s(const char * _Filename, const char * _EnvVar, char * _ResultPath, size_t _SizeInBytes); } 
template < size_t _Size > inline errno_t __cdecl _searchenv_s ( const char * _Filename, const char * _EnvVar, char ( & _ResultPath ) [ _Size ] ) throw ( ) { return _searchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _searchenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) void __cdecl _searchenv(const char * _Filename, const char * _EnvVar, char * _ResultPath); } 

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _splitpath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) void __cdecl _splitpath(const char * _FullPath, char * _Drive, char * _Dir, char * _Filename, char * _Ext); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _splitpath_s(const char * _FullPath, char * _Drive, size_t _DriveSize, char * _Dir, size_t _DirSize, char * _Filename, size_t _FilenameSize, char * _Ext, size_t _ExtSize); } 




template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _splitpath_s ( const char * _Dest, char ( & _Drive ) [ _DriveSize ], char ( & _Dir ) [ _DirSize ], char ( & _Name ) [ _NameSize ], char ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _splitpath_s ( _Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }

extern "C" { __declspec(dllimport) void __cdecl _swab(char * _Buf1, char * _Buf2, int _SizeInBytes); } 
#line 810
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wfullpath(__wchar_t * _FullPath, const __wchar_t * _Path, size_t _SizeInWords); } 
#line 816
extern "C" { __declspec(dllimport) errno_t __cdecl _wmakepath_s(__wchar_t * _PathResult, size_t _SIZE, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); } 

template < size_t _Size > inline errno_t __cdecl _wmakepath_s ( wchar_t ( & _ResultPath ) [ _Size ], const wchar_t * _Drive, const wchar_t * _Dir, const wchar_t * _Filename, const wchar_t * _Ext ) throw ( ) { return _wmakepath_s ( _ResultPath, _Size, _Drive, _Dir, _Filename, _Ext ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wmakepath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(__wchar_t * _ResultPath, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); } 


extern "C" { __declspec(dllimport) void __cdecl _wperror(const __wchar_t * _ErrMsg); } 

extern "C" { __declspec(dllimport) int __cdecl _wputenv(const __wchar_t * _EnvString); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wputenv_s(const __wchar_t * _Name, const __wchar_t * _Value); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wsearchenv_s(const __wchar_t * _Filename, const __wchar_t * _EnvVar, __wchar_t * _ResultPath, size_t _SizeInWords); } 
template < size_t _Size > inline errno_t __cdecl _wsearchenv_s ( const wchar_t * _Filename, const wchar_t * _EnvVar, wchar_t ( & _ResultPath ) [ _Size ] ) throw ( ) { return _wsearchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wsearchenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNIN" "GS. See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv(const __wchar_t * _Filename, const __wchar_t * _EnvVar, __wchar_t * _ResultPath); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wsplitpath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNIN" "GS. See online help for details.")) __declspec(dllimport) void __cdecl _wsplitpath(const __wchar_t * _FullPath, __wchar_t * _Drive, __wchar_t * _Dir, __wchar_t * _Filename, __wchar_t * _Ext); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wsplitpath_s(const __wchar_t * _FullPath, __wchar_t * _Drive, size_t _DriveSize, __wchar_t * _Dir, size_t _DirSize, __wchar_t * _Filename, size_t _FilenameSize, __wchar_t * _Ext, size_t _ExtSize); } 




template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _wsplitpath_s ( const wchar_t * _Path, wchar_t ( & _Drive ) [ _DriveSize ], wchar_t ( & _Dir ) [ _DirSize ], wchar_t ( & _Name ) [ _NameSize ], wchar_t ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _wsplitpath_s ( _Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }
#line 841
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode in" "stead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(int _Mode); } 
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. S" "ee online help for details.")) __declspec(dllimport) void __cdecl _beep(unsigned _Frequency, unsigned _Duration); } 
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. " "See online help for details.")) __declspec(dllimport) void __cdecl _sleep(unsigned long _Duration); } 
#line 862
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4141) /* Removed pragma: #pragma warning(disable: 4141)*/
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _ecvt. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _ecvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) char *__cdecl ecvt(double _Val, int _NumOfDigits, int * _PtDec, int * _PtSign); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fcvt. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) char *__cdecl fcvt(double _Val, int _NumOfDec, int * _PtDec, int * _PtSign); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _gcvt. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) char *__cdecl gcvt(double _Val, int _NumOfDigits, char * _DstBuf); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _itoa. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _itoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) char *__cdecl itoa(int _Val, char * _DstBuf, int _Radix); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _ltoa. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) char *__cdecl ltoa(long _Val, char * _DstBuf, int _Radix); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _putenv. See online help for details.")) __declspec(dllimport) int __cdecl putenv(const char * _EnvString); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _swab. See online help for details.")) __declspec(dllimport) void __cdecl swab(char * _Buf1, char * _Buf2, int _SizeInBytes); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _ultoa. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) char *__cdecl ultoa(unsigned long _Val, char * _Dstbuf, int _Radix); } 
/* Removed pragma: #pragma warning(pop)*/
extern "C" { _onexit_t __cdecl onexit(_onexit_t _Func); } 
#line 884
#pragma pack ( pop )
#line 36 "C:\\Program Files\\Parasoft\\C++test for Visual Studio\\9.5\\engine\\runtime\\include\\cpptest_common.h"
typedef 
#line 29
struct { 

char *ptr; 

size_t len; 

size_t size; 
} CppTestExpandableString; 
#line 45
typedef 
#line 38
struct CppTestListElement_s { 

char *data; 

CppTestListElement_s *next; 

CppTestListElement_s *prev; 
} CppTestListElement; 
#line 52
typedef 
#line 47
struct { 

CppTestListElement *head; 

CppTestListElement *tail; 
} CppTestList; 

typedef CppTestListElement *CppTestListIterator; 
typedef const CppTestListElement *CppTestListConstIterator; 

typedef unsigned long CppTest_ULong; 



typedef __wchar_t CppTest_wchar_t; 



extern "C" __declspec(dllimport) void __cdecl cpptestExpandableStringInit(CppTestExpandableString * es, size_t initSize); 



extern "C" __declspec(dllimport) void __cdecl cpptestExpandableStringExpand(CppTestExpandableString * es); 



extern "C" __declspec(dllimport) void __cdecl cpptestExpandableStringAppend(CppTestExpandableString * es, const char * str, size_t len); 



extern "C" __declspec(dllimport) void __cdecl cpptestExpandableStringAppendChar(CppTestExpandableString * es, char c); 



extern "C" __declspec(dllimport) void __cdecl cpptestExpandableStringDispose(CppTestExpandableString * es); 



extern "C" __declspec(dllimport) void __cdecl cpptestListInit(CppTestList * l); 


extern "C" { typedef void (__cdecl *ListElementDestructor)(char * data, void * additionalParameter); }



extern "C" __declspec(dllimport) void __cdecl cpptestListClear(CppTestList * l, ListElementDestructor destructor, void * additionalParameter); 


extern "C" __declspec(dllimport) CppTestListIterator __cdecl cpptestListRemove(CppTestList * l, CppTestListIterator it); 


extern "C" __declspec(dllimport) void __cdecl cpptestListPushFront(CppTestList * l, char * data); 


extern "C" __declspec(dllimport) char *__cdecl cpptestListFrontElement(const CppTestList * l); 


extern "C" __declspec(dllimport) void __cdecl cpptestListPushBack(CppTestList * l, char * data); 


extern "C" __declspec(dllimport) CppTestListIterator __cdecl cpptestListGetIterator(const CppTestList * l); 


extern "C" __declspec(dllimport) char *__cdecl cpptestListIteratorElement(CppTestListConstIterator it); 


extern "C" __declspec(dllimport) CppTestListIterator __cdecl cpptestListIteratorNext(CppTestListConstIterator it); 


extern "C" __declspec(dllimport) int __cdecl cpptestListIteratorEnd(CppTestListConstIterator it); 


extern "C" __declspec(dllimport) char *__cdecl cpptestStrDup(const char * str); 


extern "C" __declspec(dllimport) unsigned __cdecl cpptestStrLen(const char * str); 


extern "C" __declspec(dllimport) int __cdecl cpptestStrCmp(const char * str1, const char * str2); 


extern "C" __declspec(dllimport) int __cdecl cpptestStrNCmp(const char * str1, const char * str2, unsigned n); 


extern "C" __declspec(dllimport) int __cdecl cpptestStrCaseCmp(const char * str1, const char * str2); 


extern "C" __declspec(dllimport) int __cdecl cpptestStrNCaseCmp(const char * str1, const char * str2, unsigned n); 


extern "C" __declspec(dllimport) unsigned __cdecl cpptestCharToDigit(char c); 


extern "C" __declspec(dllimport) const char *__cdecl cpptestStrToInteger(const char * str, __int64 * integer); 


extern "C" __declspec(dllimport) const char *__cdecl cpptestStrToUInteger(const char * str, unsigned __int64 * uinteger); 


extern "C" __declspec(dllimport) const char *__cdecl cpptestStrToBool(const char * str, int * result); 


extern "C" __declspec(dllimport) char *__cdecl cpptestAllocateString(size_t size, unsigned char content); 


extern "C" __declspec(dllimport) void __cdecl cpptestIntToBitStrMask(char * bitString, unsigned value, unsigned mask); 



extern "C" __declspec(dllimport) CppTest_wchar_t *__cdecl cpptestWStrDup(const CppTest_wchar_t * str); 


extern "C" __declspec(dllimport) unsigned __cdecl cpptestWStrLen(const CppTest_wchar_t * str); 


extern "C" __declspec(dllimport) int __cdecl cpptestWStrCmp(const CppTest_wchar_t * str1, const CppTest_wchar_t * str2); 


extern "C" __declspec(dllimport) int __cdecl cpptestWStrNCmp(const CppTest_wchar_t * str1, const CppTest_wchar_t * str2, unsigned n); 


extern "C" __declspec(dllimport) unsigned __cdecl cpptestWCharToDigit(CppTest_wchar_t c); 


extern "C" __declspec(dllimport) const CppTest_wchar_t *__cdecl cpptestWStrToInteger(const CppTest_wchar_t * str, __int64 * integer); 


extern "C" __declspec(dllimport) const CppTest_wchar_t *__cdecl cpptestWStrToUInteger(const CppTest_wchar_t * str, unsigned __int64 * uinteger); 
#line 180
extern "C" __declspec(dllimport) void *__cdecl cpptestMalloc(size_t size); 


extern "C" __declspec(dllimport) void *__cdecl cpptestAlloc(size_t size); 


extern "C" __declspec(dllimport) void __cdecl cpptestFree(void * str); 


extern "C" __declspec(dllimport) void *__cdecl cpptestMemset(void * ptr, int c, size_t size); 
#line 207
typedef struct CppTestTreeNode *CppTestTree; 
#line 213
extern "C" __declspec(dllimport) void __cdecl cpptestTreeInit(CppTestTree * tree); 
#line 219
extern "C" __declspec(dllimport) void __cdecl cpptestTreeClear(CppTestTree * tree); 
#line 226
extern "C" __declspec(dllimport) int __cdecl cpptestTreeFind(CppTestTree * tree, const char * key, void ** ret); 
#line 232
extern "C" __declspec(dllimport) void __cdecl cpptestTreeAdd(CppTestTree * tree, const char * key, void * value); 

typedef void __cdecl CppTestTreeCallBackRoutine(const char * key, void * value); 
typedef CppTestTreeCallBackRoutine *CppTestTreeCallBack; 
#line 241
extern "C" __declspec(dllimport) void __cdecl cpptestTreeTraverseInorder(const CppTestTree * tree, const CppTestTreeCallBack callback); 
#line 249
extern "C" __declspec(dllimport) void __cdecl cpptestAddProperty(const char * name, const char * value); 
#line 257
extern "C" __declspec(dllimport) void __cdecl cpptestAddWeakProperty(const char * name, const char * value); 
#line 270
extern "C" __declspec(dllimport) void __cdecl cpptestParseAndAddProperties(char * properties); 
#line 276
extern "C" __declspec(dllimport) int __cdecl cpptestHasProperty(const char * name); 
#line 283
extern "C" __declspec(dllimport) const char *__cdecl cpptestGetProperty(const char * name); 
#line 290
extern "C" __declspec(dllimport) const char *__cdecl cpptestGetPropertyEx(const char * name, const char * defaultValue); 
#line 297
extern "C" __declspec(dllimport) __int64 __cdecl cpptestGetIntProperty(const char * name); 
#line 304
extern "C" __declspec(dllimport) __int64 __cdecl cpptestGetIntPropertyEx(const char * name, __int64 defaultValue); 
#line 311
extern "C" __declspec(dllimport) unsigned __int64 __cdecl cpptestGetUIntProperty(const char * name); 
#line 318
extern "C" __declspec(dllimport) unsigned __int64 __cdecl cpptestGetUIntPropertyEx(const char * name, unsigned __int64 defaultValue); 
#line 325
extern "C" __declspec(dllimport) int __cdecl cpptestGetBoolProperty(const char * name); 
#line 332
extern "C" __declspec(dllimport) int __cdecl cpptestGetBoolPropertyEx(const char * name, int defaultValue); 
#line 338
extern "C" __declspec(dllimport) const char *__cdecl cpptestPathRelativeToAbsolute(const char * relPath, const char * relToFileName); 
#line 21 "C:\\Program Files\\Parasoft\\C++test for Visual Studio\\9.5\\engine\\runtime\\include\\cpptest_system.h"
typedef 
#line 15
struct { 
void *(*mallocFunc)(size_t size); 
void *(*callocFunc)(size_t elements, size_t elem_size); 
void *(*reallocFunc)(void * ptr, size_t new_size); 
void (*freeFunc)(void * ptr); 
void *(*memsetFunc)(void * ptr, int value, size_t size); 
} CppTest_System; 
#line 37 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\setjmp.h"
#pragma pack ( push, 8 )
#line 75
extern "C" { typedef 
#line 63
struct __JUMP_BUFFER { 
unsigned long Ebp; 
unsigned long Ebx; 
unsigned long Edi; 
unsigned long Esi; 
unsigned long Esp; 
unsigned long Eip; 
unsigned long Registration; 
unsigned long TryLevel; 
unsigned long Cookie; 
unsigned long UnwindFunc; 
unsigned long UnwindData[6]; 
} _JUMP_BUFFER; }
#line 236
extern "C" { typedef int jmp_buf[16]; }
#line 243
extern "C" { int __cdecl _setjmp(jmp_buf _Buf); } 
#line 252
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl longjmp(jmp_buf _Buf, int _Value) throw(...); } 





#pragma pack ( pop )
#line 187 "C:\\Program Files\\Parasoft\\C++test for Visual Studio\\9.5\\engine\\runtime\\include\\cpptest_runtime_u.h"
typedef unsigned CppTest_ErrorCode; 



typedef void (*__CPTR_TestCasePtr)(void); 


typedef void (*__CPTR_TestCaseBreakFuncPtr)(void); 

struct _CONTEXT; 
struct _EXCEPTION_RECORD; 

struct CppTest_DataSource; 
struct CppTest_DsCsvData; 
#line 216
extern "C" __declspec(dllimport) const char *__cdecl cpptestGetCurrentTestCaseName(); 
#line 222
extern "C" __declspec(dllimport) const char *__cdecl cpptestGetCurrentTestSuiteName(); 
#line 228
extern "C" __declspec(dllimport) unsigned __cdecl cpptestGetCurrentTestCaseIteration(); 
#line 242
extern "C" __declspec(dllimport) const char *__cdecl cpptestGetCurrentTestCaseFile(); 
#line 248
extern "C" __declspec(dllimport) unsigned __cdecl cpptestGetCurrentTestCaseLine(); 
#line 255
extern "C" __declspec(dllimport) void __cdecl cpptestCommunicationBegin(); 


extern "C" __declspec(dllimport) void __cdecl cpptestCommunicationEnd(); 


extern "C" __declspec(dllimport) void __cdecl cpptestTestRunnerBegin(); 


extern "C" __declspec(dllimport) void __cdecl cpptestTestRunnerEnd(); 


extern "C" __declspec(dllimport) void __cdecl cpptestTestSuiteBegin(const char * name, const char * file, unsigned line); 



extern "C" __declspec(dllimport) void __cdecl cpptestTestSuiteEnd(); 


extern "C" __declspec(dllimport) void __cdecl cpptestTestCaseBegin(const char * name, CppTest_ErrorCode expectedErrorCode, unsigned expectedErrorCodeMask, int isCpp, const char * file, unsigned line); 




extern "C" __declspec(dllimport) void __cdecl cpptestTestCaseEnd(); 


extern "C" __declspec(dllimport) void __cdecl cpptestDsForCurrentTestCaseInitialized(CppTest_DataSource * dataSource); 


extern "C" __declspec(dllimport) void __cdecl cpptestDsTestCaseBegin(const char * name, CppTest_ErrorCode expectedErrorCode, unsigned expectedErrorCodeMask, int isCpp, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestDsTestCaseEnd(); 


extern "C" __declspec(dllimport) void __cdecl cpptestDsTestCaseIterationBegin(unsigned iteration, const char * signature); 


extern "C" __declspec(dllimport) void __cdecl cpptestDsTestCaseIterationEnd(); 




extern "C" __declspec(dllimport) void CppTest_DsFinalize(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) void CppTest_DsDumpInt(CppTestExpandableString * es, int i); 


extern "C" __declspec(dllimport) const char *CppTest_DsGetMemBuffer(CppTest_DataSource * ds, const char * name, unsigned * size); 


extern "C" __declspec(dllimport) __int64 CppTest_DsGetInteger(CppTest_DataSource * ds, const char * name); 


extern "C" __declspec(dllimport) unsigned __int64 CppTest_DsGetUInteger(CppTest_DataSource * ds, const char * name); 


extern "C" __declspec(dllimport) double CppTest_DsGetFloat(CppTest_DataSource * ds, const char * name); 


extern "C" __declspec(dllimport) int CppTest_DsGetBool(CppTest_DataSource * ds, const char * name); 


extern "C" __declspec(dllimport) char CppTest_DsGetChar(CppTest_DataSource * ds, const char * name); 


extern "C" __declspec(dllimport) int CppTest_DsErrorHasMoreData(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) const char *CppTest_DsErrorGetDataSignature(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) unsigned CppTest_DsErrorGetIteration(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) int CppTest_DsRepeatLoadNextData(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) unsigned CppTest_DsRepeatGetIteration(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) int CppTest_DsRepeatHasMoreData(CppTest_DataSource * ds); 
#line 348
extern "C" __declspec(dllimport) void CppTest_DsRepeatFinalize(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) CppTest_DataSource *__cdecl CppTest_DsRepeat(int count); 


extern "C" __declspec(dllimport) int CppTest_DsArrayLoadNextData(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) unsigned CppTest_DsArrayGetIteration(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) int CppTest_DsArrayHasMoreData(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) int CppTest_DsArrayGetColumn(CppTest_DataSource * ds, const char * name); 


extern "C" __declspec(dllimport) int CppTest_DsArrayHasColumn(CppTest_DataSource * ds, const char * name); 


extern "C" __declspec(dllimport) const char *CppTest_DsArrayGetCStr(CppTest_DataSource * ds, const char * name); 



extern "C" __declspec(dllimport) const CppTest_wchar_t *CppTest_DsArrayGetWCStr(CppTest_DataSource * ds, const char * name); 
#line 382
extern "C" __declspec(dllimport) void CppTest_DsArrayFinalize(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) CppTest_DataSource *__cdecl CppTest_DsArray(const char ** data, int rows, int columns); 




extern "C" __declspec(dllimport) int CppTest_DsCsvPeekChar(CppTest_DsCsvData * dsCsv); 


extern "C" __declspec(dllimport) int CppTest_DsCsvReadChar(CppTest_DsCsvData * dsCsv); 


extern "C" __declspec(dllimport) void CppTest_DsCsvGetSkipWS(CppTest_DsCsvData * dsCsv); 


extern "C" __declspec(dllimport) int CppTest_DsCsvIsEndOfField(CppTest_DsCsvData * dsCsv, int * pC); 


extern "C" __declspec(dllimport) int CppTest_DsCsvLoadQuotedField(CppTest_DsCsvData * dsCsv, CppTestExpandableString * pEs, int * pC); 


extern "C" __declspec(dllimport) int CppTest_DsCsvLoadField(CppTest_DsCsvData * dsCsv, CppTestExpandableString * pEs, int * pC); 
#line 413
extern "C" __declspec(dllimport) int CppTest_DsCsvLoadNextData(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) unsigned CppTest_DsCsvGetIteration(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) int CppTest_DsCsvHasMoreData(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) CppTestListIterator CppTest_DsCsvGetColumn(CppTest_DataSource * ds, const char * name); 


extern "C" __declspec(dllimport) int CppTest_DsCsvHasColumn(CppTest_DataSource * ds, const char * name); 


extern "C" __declspec(dllimport) const char *CppTest_DsCsvGetCStr(CppTest_DataSource * ds, const char * name); 



extern "C" __declspec(dllimport) const CppTest_wchar_t *CppTest_DsCsvGetWCStr(CppTest_DataSource * ds, const char * name); 
#line 441
extern "C" __declspec(dllimport) void CppTest_DsCsvFinalize(CppTest_DataSource * ds); 


extern "C" __declspec(dllimport) CppTest_DataSource *__cdecl CppTest_DsCsv(const char * fileName, char separator, int useCollumns, int trimValues); 
#line 450
extern "C" __declspec(dllimport) CppTest_DataSource *__cdecl CppTest_Ds(const char * dataSourceName); 
#line 467
extern "C" __declspec(dllimport) const char *__cdecl cpptestFormatBuffer(char * buffer, const char * format, ...); 
#line 476
extern "C" __declspec(dllimport) int __cdecl cpptestCharPtrsEqual(const char * expected, const char * actual); 
#line 487
extern "C" __declspec(dllimport) int cpptestWCharPtrsEqual(const void * expected, const void * actual); 



extern "C" __declspec(dllimport) int cpptestWCharPtrsNEqual(const void * expected, const void * actual, unsigned maxSize); 




extern "C" __declspec(dllimport) void __cdecl cpptestUnhandledStructuredExceptionInThread(unsigned code); 

extern "C" __declspec(dllimport) int __cdecl cpptestUnhandledStructuredExceptionInTestCase(unsigned code); 

extern "C" __declspec(dllimport) void __cdecl cpptestUnhandledCppExceptionInThread(); 

extern "C" __declspec(dllimport) void __cdecl cpptestNoExpectedCppExceptionInTestCase(const char * e); 

extern "C" __declspec(dllimport) void __cdecl cpptestUnhandledStdExceptionInTestCase(const char * what); 

extern "C" __declspec(dllimport) void __cdecl cpptestUnhandledCppExceptionInTestCase(); 
#line 514
extern "C" __declspec(dllimport) void __cdecl cpptestSignalFound(int sigNo); 


extern "C" __declspec(dllimport) __CPTR_TestCaseBreakFuncPtr __cdecl cpptestGetTestCaseBreakFuncPtr(); 


extern "C" __declspec(dllimport) __CPTR_TestCaseBreakFuncPtr __cdecl cpptestSetTestCaseBreakFuncPtr(__CPTR_TestCaseBreakFuncPtr funcpPtr); 
#line 537
extern "C" __declspec(dllimport) char __cdecl cpptestLimitsGetMaxChar(); 
#line 543
extern "C" __declspec(dllimport) char __cdecl cpptestLimitsGetMinChar(); 
#line 549
extern "C" __declspec(dllimport) signed char __cdecl cpptestLimitsGetMaxSignedChar(); 
#line 555
extern "C" __declspec(dllimport) signed char __cdecl cpptestLimitsGetMinSignedChar(); 
#line 561
extern "C" __declspec(dllimport) unsigned char __cdecl cpptestLimitsGetMaxUnsignedChar(); 
#line 568
extern "C" __declspec(dllimport) short __cdecl cpptestLimitsGetMaxShort(); 
#line 574
extern "C" __declspec(dllimport) short __cdecl cpptestLimitsGetMinShort(); 
#line 580
extern "C" __declspec(dllimport) unsigned short __cdecl cpptestLimitsGetMaxUnsignedShort(); 
#line 587
extern "C" __declspec(dllimport) int __cdecl cpptestLimitsGetMaxInt(); 
#line 593
extern "C" __declspec(dllimport) int __cdecl cpptestLimitsGetMinInt(); 
#line 599
extern "C" __declspec(dllimport) unsigned __cdecl cpptestLimitsGetMaxUnsignedInt(); 
#line 606
extern "C" __declspec(dllimport) long __cdecl cpptestLimitsGetMaxLong(); 
#line 612
extern "C" __declspec(dllimport) long __cdecl cpptestLimitsGetMinLong(); 
#line 618
extern "C" __declspec(dllimport) unsigned long __cdecl cpptestLimitsGetMaxUnsignedLong(); 
#line 625
extern "C" __declspec(dllimport) float __cdecl cpptestLimitsGetMaxPosFloat(); 
#line 631
extern "C" __declspec(dllimport) float __cdecl cpptestLimitsGetMinNegFloat(); 
#line 637
extern "C" __declspec(dllimport) float __cdecl cpptestLimitsGetMaxNegFloat(); 
#line 643
extern "C" __declspec(dllimport) float __cdecl cpptestLimitsGetMinPosFloat(); 
#line 650
extern "C" __declspec(dllimport) double __cdecl cpptestLimitsGetMaxPosDouble(); 
#line 656
extern "C" __declspec(dllimport) double __cdecl cpptestLimitsGetMinNegDouble(); 
#line 662
extern "C" __declspec(dllimport) double __cdecl cpptestLimitsGetMaxNegDouble(); 
#line 668
extern "C" __declspec(dllimport) double __cdecl cpptestLimitsGetMinPosDouble(); 
#line 675
extern "C" __declspec(dllimport) long double __cdecl cpptestLimitsGetMaxPosLongDouble(); 
#line 681
extern "C" __declspec(dllimport) long double __cdecl cpptestLimitsGetMinNegLongDouble(); 
#line 687
extern "C" __declspec(dllimport) long double __cdecl cpptestLimitsGetMaxNegLongDouble(); 
#line 693
extern "C" __declspec(dllimport) long double __cdecl cpptestLimitsGetMinPosLongDouble(); 
#line 710
extern "C" __declspec(dllimport) int __cdecl CppTest_IsCurrentTestCase(const char * id); 
#line 716
extern "C" __declspec(dllimport) const char *__cdecl CppTest_GetCurrentTestCaseName(); 
#line 722
extern "C" __declspec(dllimport) const char *__cdecl CppTest_GetCurrentTestSuiteName(); 
#line 730
extern "C" __declspec(dllimport) const char *__cdecl CppTest_Format(const char * format, ...); 
#line 736
typedef struct CppTest_StreamRedirectStruct CppTest_StreamRedirect; 
typedef void (*CppTest_ClearFlush)(void); 
typedef int (*CppTest_StreamDup)(long, int); 
#line 745
void CppTest_flushStdOutput(); 
#line 753
void CppTest_flushStdError(); 
#line 760
void CppTest_clearStdInput(); 

int CppTest_streamDup(long, int); 
#line 829
extern "C" __declspec(dllimport) CppTest_StreamRedirect *__cdecl CppTest_StreamRedirectInput(int fd, const char * value, CppTest_ClearFlush ptr, CppTest_StreamDup ptr1); 
#line 844
extern "C" __declspec(dllimport) CppTest_StreamRedirect *__cdecl CppTest_StreamRedirectNInput(int fd, const char * value, unsigned size, CppTest_ClearFlush ptr, CppTest_StreamDup ptr1); 
#line 856
extern "C" __declspec(dllimport) CppTest_StreamRedirect *__cdecl CppTest_StreamRedirectOutput(int fd, CppTest_ClearFlush ptr); 
#line 871
extern "C" __declspec(dllimport) int __cdecl CppTest_StreamCompare(CppTest_StreamRedirect * redirect, const char * value); 
#line 889
extern "C" __declspec(dllimport) int __cdecl CppTest_StreamNCompare(CppTest_StreamRedirect * redirect, const char * value, unsigned size); 
#line 902
extern "C" __declspec(dllimport) int __cdecl CppTest_StreamSearch(CppTest_StreamRedirect * redirect, const char * pattern); 
#line 915
extern "C" __declspec(dllimport) int __cdecl CppTest_StreamNSearch(CppTest_StreamRedirect * redirect, const char * pattern, unsigned size); 
#line 929
extern "C" __declspec(dllimport) char *__cdecl CppTest_StreamReadData(CppTest_StreamRedirect * redirect, unsigned * len); 
#line 939
extern "C" __declspec(dllimport) void __cdecl CppTest_StreamReset(CppTest_StreamRedirect * redirect); 
#line 947
extern "C" __declspec(dllimport) void __cdecl CppTest_ClearRedirects(); 
#line 956
extern "C" __declspec(dllimport) CppTest_DataSource *__cdecl cpptestGetCurrentDataSource(); 
#line 962
extern "C" __declspec(dllimport) void __cdecl cpptestIgnoreCurrStackElement(); 


typedef void (*CppTestThreadInitCallback)(void); 




extern "C" __declspec(dllimport) void __cdecl cpptestSetThreadInitCallback(CppTestThreadInitCallback callback); 


typedef void (*CppTestPropertiesInitCallback)(void); 




extern "C" __declspec(dllimport) void __cdecl cpptestSetPropertiesInitCallback(CppTestPropertiesInitCallback callback); 
#line 984
extern "C" __declspec(dllimport) void __cdecl cpptestInitializeRuntime(CppTestPropertiesInitCallback propInitCallback, CppTestThreadInitCallback threadInitCallback, CppTest_System * system); 
#line 993
extern "C" __declspec(dllimport) void __cdecl cpptestFinalizeRuntime(); 
#line 999
typedef 
#line 996
struct { 
long seconds; 
long nanoseconds; 
} CppTest_Time; 
#line 1005
extern "C" __declspec(dllimport) void __cdecl cpptestCheckMemoryLeaks(const char * file, unsigned line, int isAssert); 
#line 1013
extern "C" __declspec(dllimport) CppTest_Time __cdecl CppTest_TimeInit(long seconds, long nanoseconds); 
#line 1020
extern "C" __declspec(dllimport) CppTest_Time __cdecl CppTest_TimeCurrent(); 




extern "C" __declspec(dllimport) CppTest_Time __cdecl CppTest_TimeDiff(CppTest_Time t1, CppTest_Time t2); 
#line 1034
extern "C" __declspec(dllimport) int __cdecl CppTest_TimeCompare(CppTest_Time t1, CppTest_Time t2); 
#line 1040
extern "C" const char *__cdecl CppTestCallProgramWrapper(const char * program, int * pResult, const char * param1, const char * param2, const char * param3); 
#line 1047
extern "C" __declspec(dllimport) void __cdecl cpptestUnhandledExceptionTerminate(); 
#line 1054
extern "C" __declspec(dllimport) void __cdecl cpptestAssertException(const char * file, unsigned line, const char * message, const char * arg1, const char * arg2, const char * arg3, const char * arg4, int kind); 


extern "C" void CppTest_InitializeRuntime(); 

extern "C" void CppTest_FinalizeRuntime(); 

extern "C" __declspec(dllimport) char **__cdecl CppTest_CmdLineToArgv(const char * cmdLine, int * argc); 

extern "C" __declspec(dllimport) void __cdecl CppTest_FreeArgv(int argc, char * argv[]); 



extern "C" __declspec(dllimport) CppTest_wchar_t **__cdecl CppTest_CmdLineToArgvW(const CppTest_wchar_t * cmdLine, int * argc); 

extern "C" __declspec(dllimport) void __cdecl CppTest_FreeArgvW(int argc, CppTest_wchar_t * argv[]); 



extern int CppTest_Main(int argc, char * argv[]); 



extern int CppTest_MainW(int argc, CppTest_wchar_t * argv[]); 



extern "C" __declspec(dllimport) const char *__cdecl cpptestStringPool(int id, const char * str); 

int __cdecl CppTest_IsCurrentContext(const char * context); 
#line 1095
extern "C" __declspec(dllimport) void *__cdecl cpptestDsMalloc(size_t size); 


extern "C" __declspec(dllimport) void __cdecl cpptestDsFree(void * str); 


extern "C" __declspec(dllimport) void __cdecl cpptestDsCsvError(CppTest_ErrorCode errorCode, const char * err, const char * file, unsigned line, unsigned column); 



extern "C" __declspec(dllimport) void __cdecl cpptestDsCsvErrorOpeningFile(const char * err, const char * file); 


extern "C" __declspec(dllimport) void __cdecl cpptestNoDsError(const char * dataSourceName); 


extern "C" __declspec(dllimport) void __cdecl cpptestDsErrorInValue(const char * value); 


extern "C" __declspec(dllimport) void __cdecl cpptestDsUnknownValue(const char * name); 


extern "C" __declspec(dllimport) int __cdecl cpptestDsNotInitialized(); 


extern "C" __declspec(dllimport) int __cdecl cpptestDsMethodNotInitialized(const char * method); 


extern "C" __declspec(dllimport) void __cdecl cpptestAssertCall(const char * message, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestExitCall(int exitCode); 


extern "C" __declspec(dllimport) void __cdecl cpptestAbortCall(); 


extern "C" __declspec(dllimport) void __cdecl cpptestRiseCall(int exitCode); 



extern "C" __declspec(dllimport) void __cdecl cpptestInvalidParamCalled(const CppTest_wchar_t * expression, const CppTest_wchar_t * function, const CppTest_wchar_t * file, unsigned line); 




extern "C" __declspec(dllimport) void __cdecl cpptestTooLargeStackTrace(unsigned maxAllowedStackTraceDepth); 



extern "C" __declspec(dllimport) void __cdecl cpptestTestCaseNotValidated(const char * file, unsigned line); 



extern "C" __declspec(dllimport) void __cdecl cpptestReport(const char * txt, const char * file, unsigned line, int reportStackTrace); 


extern "C" __declspec(dllimport) void __cdecl cpptestReportBool(const char * txt, int value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestReportInteger(const char * txt, __int64 value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestReportUInteger(const char * txt, unsigned __int64 value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestReportFloat(const char * txt, double value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestReportCStr(const char * txt, const char * value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestReportCStrN(const char * txt, const char * value, unsigned maxSize, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestReportMemBuffer(const char * txt, const void * value, unsigned size, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestReportPtr(const char * txt, int isNull, const char * file, unsigned line); 



extern "C" __declspec(dllimport) void __cdecl cpptestPostConditionBool(const char * valueString, int value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestPostConditionInteger(const char * valueString, __int64 value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestPostConditionUInteger(const char * valueString, unsigned __int64 value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestPostConditionFloat(const char * valueString, double value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestPostConditionCStr(const char * valueString, const char * value, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestPostConditionCStrN(const char * valueString, const char * value, unsigned maxSize, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestPostConditionMemBuffer(const char * valueString, const void * value, unsigned size, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestPostConditionPtr(const char * valueString, int isNull, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestPostConditionExternal(const char * userMessage, const char * ret, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestExternalProcessError(CppTest_ErrorCode errorCode, const char * err); 


extern "C" __declspec(dllimport) void __cdecl cpptestExternalProcessErrorFull(CppTest_ErrorCode errorCode, const char * err, const char * program, const char * param1, const char * param2, const char * param3); 
#line 1213
extern "C" __declspec(dllimport) int __cdecl cpptestAssertion(int value, const char * userMessage, const char * conditionStr, const char * file, unsigned line); 


extern "C" __declspec(dllimport) int __cdecl cpptestBitAssertion(int value, unsigned mask, unsigned expected, unsigned actual, const char * userMessage, const char * actualStr, const char * file, unsigned line); 



extern "C" __declspec(dllimport) int __cdecl cpptestEqualAssertion(int value, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 



extern "C" __declspec(dllimport) int __cdecl cpptestBoolEqualAssertion(int value, int expected, int actual, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 



extern "C" __declspec(dllimport) int __cdecl cpptestIntegerEqualAssertion(int value, __int64 expected, __int64 actual, int hasDelta, __int64 delta, unsigned * arrayIndex, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 




extern "C" __declspec(dllimport) int __cdecl cpptestUIntegerEqualAssertion(int value, unsigned __int64 expected, unsigned __int64 actual, int hasDelta, unsigned __int64 delta, unsigned * arrayIndex, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 




extern "C" __declspec(dllimport) int __cdecl cpptestFloatEqualAssertion(int value, double expected, double actual, int hasDelta, double delta, unsigned * arrayIndex, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 




extern "C" __declspec(dllimport) int __cdecl cpptestFloatFmtEqualAssertion(int value, double actual, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 



extern "C" __declspec(dllimport) int __cdecl cpptestCstrEqualAssertion(int value, const char * expected, const char * actual, unsigned * arrayIndex, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 



extern "C" __declspec(dllimport) int __cdecl cpptestCstrNEqualAssertion(int value, const char * expected, const char * actual, unsigned maxSize, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 



extern "C" __declspec(dllimport) int __cdecl cpptestMemBufferEqualAssertion(int value, const void * expected, const void * actual, unsigned size, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 




extern "C" __declspec(dllimport) int __cdecl cpptestPtrEqualAssertion(int value, const void * expected, const void * actual, unsigned * arrayIndex, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 
#line 1266
extern "C" __declspec(dllimport) int __cdecl cpptestWCstrEqualAssertion(int value, const CppTest_wchar_t * expected, const CppTest_wchar_t * actual, unsigned * arrayIndex, const char * userMessage, const char * expectedStr, const char * actualStr, const char * file, unsigned line); 
#line 1272
extern "C" __declspec(dllimport) void __cdecl cpptestThrowAssertion(int value, const char * userMessage, const char * exceptionTypeStr, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestNoThrowAssertion(int value, const char * userMessage, const char * file, unsigned line); 


extern "C" __declspec(dllimport) void __cdecl cpptestNoExpectedExceptionInTestCase(const char * e); 


extern "C" __declspec(dllimport) void __cdecl cpptestStdExceptionInTestCase(const char * what); 


extern "C" __declspec(dllimport) void __cdecl cpptestExceptionInTestCase(); 


extern "C" __declspec(dllimport) void __cdecl cpptestTestCaseDisabled(const char * name, const char * file, unsigned line); 



extern "C" __declspec(dllimport) int __cdecl cpptestCharPtrsNEqual(const char * expected, const char * actual, unsigned maxSize); 


extern "C" __declspec(dllimport) int __cdecl cpptestMemBuffersEqual(const void * expected, const void * actual, unsigned size); 


extern "C" __declspec(dllimport) int __cdecl cpptestFloatsFmtEqual(const char * expected, double actual); 


extern "C" __declspec(dllimport) void __cdecl cpptestTimeout(unsigned long timeout); 


extern "C" __declspec(dllimport) void __cdecl cpptestUserBreak(const char * file, unsigned line); 




extern "C" __declspec(dllimport) jmp_buf *__cdecl cpptestGetJmpBuf(); 


extern "C" __declspec(dllimport) void __cdecl cpptestSetJmpCalled(int jmpCalled); 


extern "C" __declspec(dllimport) int __cdecl cpptestGetJmpCalled(); 


extern "C" __declspec(dllimport) int __cdecl cpptestSetJmpReturn(int jmpReturn); 


extern "C" __declspec(dllimport) int __cdecl cpptestGetJmpReturn(); 



extern "C" void __cdecl cpptestTestCaseSlave(__CPTR_TestCasePtr tc); 
#line 41 "C:\\Program Files\\Parasoft\\C++test for Visual Studio\\9.5\\engine\\runtime\\include\\cpptest_data_source.h"
extern "C" { typedef 
#line 16
struct CppTest_DataSource { 

const char *(*getMemBuffer)(CppTest_DataSource *, const char * name, unsigned * size); 
const char *(*getCStr)(CppTest_DataSource *, const char * name); 

const CppTest_wchar_t *(*getWCStr)(CppTest_DataSource *, const char * name); 

__int64 (*getInteger)(CppTest_DataSource *, const char * name); 
unsigned __int64 (*getUInteger)(CppTest_DataSource *, const char * name); 
double (*getFloat)(CppTest_DataSource *, const char * name); 
int (*getBool)(CppTest_DataSource *, const char * name); 
char (*getChar)(CppTest_DataSource *, const char * name); 

int (*hasColumn)(CppTest_DataSource *, const char * name); 

int (*loadNextData)(CppTest_DataSource *); 
int (*hasMoreData)(CppTest_DataSource *); 
unsigned (*getIteration)(CppTest_DataSource *); 




void (*finalize)(CppTest_DataSource *); 

void *data; 
} CppTest_DataSource; }

extern "C" { typedef CppTest_DataSource *(*CppTest_GetDataSourceFPtr)(const char * dataSource, const char * testSuite); }
#line 52
extern "C" CppTest_DataSource *__cdecl CppTest_DsArray(const char ** data, int rows, int columns); 
extern "C" CppTest_DataSource *__cdecl CppTest_DsRepeat(int count); 
extern "C" CppTest_DataSource *__cdecl CppTest_Ds(const char * dataSourceName); 


extern "C" CppTest_DataSource *__cdecl CppTest_DsCsv(const char * fileName, char separator, int useCollumns, int trimValues); 
#line 194 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1600")
#line 203
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
#line 27 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\use_ansi.h"
#ifndef __CPTR_NO_PRAGMA_1499154335_0_27
#pragma comment(lib, "msvcprtd")
#endif
#line 8 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
#pragma pack ( push, 8 )
#line 535
namespace std { 
typedef bool _Bool; 
}
#line 553
typedef __int64 _Longlong; 
typedef unsigned __int64 _ULonglong; 
#line 576
typedef unsigned short char16_t; 
typedef unsigned char32_t; 
#line 591
namespace std { 
enum _Uninitialized { 

_Noinit
}; 



/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4412) /* Removed pragma: #pragma warning(disable:4412)*/
class _Lockit { 
#line 624
public: __thiscall _Lockit(); 
CPPTEST_IMP__ZNSt7_LockitC9Ei explicit __thiscall _Lockit(int); 
CPPTEST_IMP__ZNSt7_LockitD9Ev __thiscall ~_Lockit(); 


static void __cdecl _Lockit_ctor(int); 
static void __cdecl _Lockit_dtor(int); 


private: static void __cdecl _Lockit_ctor(_Lockit *); 
static void __cdecl _Lockit_ctor(_Lockit *, int); 
static void __cdecl _Lockit_dtor(_Lockit *); 

_Lockit(const _Lockit &); 
_Lockit &operator=(const _Lockit &); 

int _Locktype; 
#line 655
}; 
#line 742
class _Mutex { 
#line 773
public: CPPTEST_IMP__ZNSt6_MutexC9ESt14_Uninitialized inline __thiscall _Mutex(_Uninitialized) 
{ 
} 

__thiscall _Mutex(); 
__thiscall ~_Mutex(); 
void __thiscall _Lock(); 
void __thiscall _Unlock(); 



private: static void __cdecl _Mutex_ctor(_Mutex *); 
static void __cdecl _Mutex_dtor(_Mutex *); 
static void __cdecl _Mutex_Lock(_Mutex *); 
static void __cdecl _Mutex_Unlock(_Mutex *); 

_Mutex(const _Mutex &); 
_Mutex &operator=(const _Mutex &); 
void *_Mtx; 
#line 802
}; 

class __declspec(dllimport) _Init_locks { 
#line 820
public: __thiscall _Init_locks(); 
__thiscall ~_Init_locks(); 



private: static void __cdecl _Init_locks_ctor(_Init_locks *); 
static void __cdecl _Init_locks_dtor(_Init_locks *); 
#line 837
}; 

/* Removed pragma: #pragma warning(pop)*/
}
#line 849
__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void)); 

typedef int _Mbstatet; 
typedef unsigned long _Uint32t; 
#line 860
#pragma pack ( pop )
#line 38 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"
namespace std { typedef decltype((__nullptr)) nullptr_t; }
using std::nullptr_t;
#line 73
extern "C" { __declspec(dllimport) extern unsigned long __cdecl __threadid(); } 

extern "C" { __declspec(dllimport) extern uintptr_t __cdecl __threadhandle(); } 
#line 17 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\cstddef"
namespace std { 
using ::ptrdiff_t;using ::size_t;
}
#line 17 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"
/* Removed pragma: #pragma warning(push,3)*/
#line 16
#pragma pack ( push, 8 )


namespace std { 
#line 78
template < bool _Test,
 class _Ty1,
 class _Ty2 >
 class _If{ 


public: typedef _Ty2 _Type; 
};

template < class _Ty1,
 class _Ty2 >
 class _If < true, _Ty1, _Ty2 >{ 


public: typedef _Ty1 _Type; 
};




namespace tr1 { 
typedef char (&_No)[1]; 
typedef char (&_Yes)[2]; 
}
#line 108
struct _Bool_struct { 

int _Member; 
}; 
#line 125
typedef int _Bool_struct::*_Bool_type; 
#line 132
template < class _Arg,
 class _Result >
 struct unary_function{ 

typedef _Arg argument_type; 
typedef _Result result_type; 
};


template < class _Arg1,
 class _Arg2,
 class _Result >
 struct binary_function{ 

typedef _Arg1 first_argument_type; 
typedef _Arg2 second_argument_type; 
typedef _Result result_type; 
};
}


/* Removed pragma: #pragma warning(pop)*/
#line 10 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
/* Removed pragma: #pragma warning(push,3)*/
#line 154 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"
#pragma pack ( pop )
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
#pragma pack ( push, 8 )
#line 21
namespace std { 
#line 34
}
#line 24 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"
#pragma pack ( push, 8 )
#line 32
typedef void (__cdecl *terminate_function)(void); 
typedef void (__cdecl *terminate_handler)(void); 
typedef void (__cdecl *unexpected_function)(void); 
typedef void (__cdecl *unexpected_handler)(void); 
#line 50
struct _EXCEPTION_POINTERS; 

typedef void (__cdecl *_se_translator_function)(unsigned, _EXCEPTION_POINTERS *); 


__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(); 
__declspec(dllimport) void __cdecl unexpected(); 

__declspec(dllimport) int __cdecl _is_exception_typeof(const class type_info & _Type, _EXCEPTION_POINTERS * _ExceptionPtr); 



__declspec(dllimport) terminate_function __cdecl set_terminate(terminate_function _NewPtFunc); 
extern "C" __declspec(dllimport) terminate_function __cdecl _get_terminate(); 
__declspec(dllimport) unexpected_function __cdecl set_unexpected(unexpected_function _NewPtFunc); 
extern "C" __declspec(dllimport) unexpected_function __cdecl _get_unexpected(); 




__declspec(dllimport) _se_translator_function __cdecl _set_se_translator(_se_translator_function _NewPtFunc); 

__declspec(dllimport) bool __cdecl __uncaught_exception(); 
#line 82
#pragma pack ( pop )
#line 26 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
#pragma pack ( push, 8 )
#line 62
extern "C" { typedef 
#line 58
struct _heapinfo { 
int *_pentry; 
size_t _size; 
int _useflag; 
} _HEAPINFO; }
#line 142
extern "C" { __declspec(dllimport) int __cdecl _resetstkoflw(); } 



extern "C" { __declspec(dllimport) unsigned long __cdecl _set_malloc_crt_max_wait(unsigned long _NewValue); } 
#line 157
extern "C" { __declspec(dllimport) void *__cdecl _expand(void * _Memory, size_t _NewSize); } 
extern "C" { __declspec(dllimport) size_t __cdecl _msize(void * _Memory); } 
#line 165
extern "C" { void *__cdecl _alloca(size_t _Size); } 
extern "C" { __declspec(dllimport) int __cdecl _heapadd(void * _Memory, size_t _Size); } 
extern "C" { __declspec(dllimport) int __cdecl _heapchk(); } 
extern "C" { __declspec(dllimport) int __cdecl _heapmin(); } 
extern "C" { __declspec(dllimport) int __cdecl _heapset(unsigned _Fill); } 
extern "C" { __declspec(dllimport) int __cdecl _heapwalk(_HEAPINFO * _EntryInfo); } 
extern "C" { __declspec(dllimport) size_t __cdecl _heapused(size_t * _Used, size_t * _Commit); } 

extern "C" { __declspec(dllimport) intptr_t __cdecl _get_heap_handle(); } 
#line 187
extern "C" { typedef char __static_assert_t[(sizeof(unsigned) <= 8)]; }


/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 6540) /* Removed pragma: #pragma warning(disable:6540)*/
extern "C" { __inline void *_MarkAllocaS(void *_Ptr, unsigned _Marker) 
{ 
if (_Ptr) 
{ 
*((unsigned *)_Ptr) = _Marker; 
_Ptr = (char *)_Ptr + 8; 
}  
return _Ptr; 
} } 
/* Removed pragma: #pragma warning(pop)*/
#line 227
extern "C" { __declspec(noalias) __inline void __cdecl _freea(void *_Memory) 
{ 
unsigned _Marker; 
if (_Memory) 
{ 
_Memory = (char *)_Memory - 8; 
_Marker = *((unsigned *)_Memory); 
if (_Marker == 0xdddd) 
{ 
free(_Memory); 
}  
#line 244
}  
} } 
#line 280
#pragma pack ( pop )
#line 46 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) void *__cdecl _memccpy(void * _Dst, const void * _Src, int _Val, size_t _MaxCount); } 
extern "C" { CPPTEST_IMP_memchr const void *__cdecl memchr(const void * _Buf, int _Val, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) int __cdecl _memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); } 
extern "C" { __declspec(dllimport) int __cdecl _memicmp_l(const void * _Buf1, const void * _Buf2, size_t _Size, _locale_t _Locale); } 
extern "C" { int __cdecl memcmp(const void * _Buf1, const void * _Buf2, size_t _Size); } 
extern "C" { void *__cdecl memcpy(void * _Dst, const void * _Src, size_t _Size); } 

extern "C" { __declspec(dllimport) errno_t __cdecl memcpy_s(void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount); } 
#line 88
extern "C" { void *__cdecl memset(void * _Dst, int _Val, size_t _Size); } 



extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _memccpy. See online help for details.")) __declspec(dllimport) void *__cdecl memccpy(void * _Dst, const void * _Src, int _Val, size_t _Size); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _memicmp. See online help for details.")) __declspec(dllimport) int __cdecl memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); } 




extern "C" { __declspec(dllimport) errno_t __cdecl _strset_s(char * _Dst, size_t _DstSize, int _Value); } 
template < size_t _Size > inline errno_t __cdecl _strset_s ( char ( & _Dest ) [ _Size ], int _Value ) throw ( ) { return _strset_s ( _Dest, _Size, _Value ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _strset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char *__cdecl _strset(char * _Dest, int _Value); } 

extern "C" { __declspec(dllimport) errno_t __cdecl strcpy_s(char * _Dst, rsize_t _SizeInBytes, const char * _Src); } 

template < size_t _Size > inline errno_t __cdecl strcpy_s ( char ( & _Dest ) [ _Size ], const char * _Source ) throw ( ) { return strcpy_s ( _Dest, _Size, _Source ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) char *__cdecl strcpy(char * _Dest, const char * _Source); } 

extern "C" { __declspec(dllimport) errno_t __cdecl strcat_s(char * _Dst, rsize_t _SizeInBytes, const char * _Src); } 

template < size_t _Size > inline errno_t __cdecl strcat_s ( char ( & _Dest ) [ _Size ], const char * _Source ) throw ( ) { return strcat_s ( _Dest, _Size, _Source ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using strcat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) char *__cdecl strcat(char * _Dest, const char * _Source); } 
extern "C" { int __cdecl strcmp(const char * _Str1, const char * _Str2); } 
extern "C" { size_t __cdecl strlen(const char * _Str); } 
extern "C" { __declspec(dllimport) size_t __cdecl strnlen(const char * _Str, size_t _MaxCount); } 

extern "C" { static __inline size_t __cdecl strnlen_s(const char *_Str, size_t _MaxCount) 
{ 
return (_Str == 0) ? 0 : (strnlen(_Str, _MaxCount)); 
} } 


extern "C" { CPPTEST_IMP_memmove_s errno_t __cdecl memmove_s(void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount); } 
#line 127
extern "C" { CPPTEST_IMP_memmove void *__cdecl memmove(void * _Dst, const void * _Src, size_t _Size); } 
#line 135
extern "C" { __declspec(dllimport) char *__cdecl _strdup(const char * _Src); } 
#line 141
extern "C" { __declspec(dllimport) const char *__cdecl strchr(const char * _Str, int _Val); } 
extern "C" { __declspec(dllimport) int __cdecl _stricmp(const char * _Str1, const char * _Str2); } 
extern "C" { __declspec(dllimport) int __cdecl _strcmpi(const char * _Str1, const char * _Str2); } 
extern "C" { __declspec(dllimport) int __cdecl _stricmp_l(const char * _Str1, const char * _Str2, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl strcoll(const char * _Str1, const char * _Str2); } 
extern "C" { __declspec(dllimport) int __cdecl _strcoll_l(const char * _Str1, const char * _Str2, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _stricoll(const char * _Str1, const char * _Str2); } 
extern "C" { __declspec(dllimport) int __cdecl _stricoll_l(const char * _Str1, const char * _Str2, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _strncoll(const char * _Str1, const char * _Str2, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) int __cdecl _strncoll_l(const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _strnicoll(const char * _Str1, const char * _Str2, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) int __cdecl _strnicoll_l(const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale); } 
extern "C" { CPPTEST_IMP_strcspn size_t __cdecl strcspn(const char * _Str, const char * _Control); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _strerror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) char *__cdecl _strerror(const char * _ErrMsg); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _strerror_s(char * _Buf, size_t _SizeInBytes, const char * _ErrMsg); } 
template < size_t _Size > inline errno_t __cdecl _strerror_s ( char ( & _Buffer ) [ _Size ], const char * _ErrorMessage ) throw ( ) { return _strerror_s ( _Buffer, _Size, _ErrorMessage ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using strerror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) char *__cdecl strerror(int); } 

extern "C" { __declspec(dllimport) errno_t __cdecl strerror_s(char * _Buf, size_t _SizeInBytes, int _ErrNum); } 

template < size_t _Size > inline errno_t __cdecl strerror_s ( char ( & _Buffer ) [ _Size ], int _ErrorMessage ) throw ( ) { return strerror_s ( _Buffer, _Size, _ErrorMessage ); }
extern "C" { __declspec(dllimport) errno_t __cdecl _strlwr_s(char * _Str, size_t _Size); } 
template < size_t _Size > inline errno_t __cdecl _strlwr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strlwr_s ( _String, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _strlwr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char *__cdecl _strlwr(char * _String); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _strlwr_s_l(char * _Str, size_t _Size, _locale_t _Locale); } 
template < size_t _Size > inline errno_t __cdecl _strlwr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strlwr_s_l ( _String, _Size, _Locale ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _strlwr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) char *__cdecl _strlwr_l(char * _String, _locale_t _Locale); } 

extern "C" { __declspec(dllimport) errno_t __cdecl strncat_s(char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount); } 

template < size_t _Size > inline errno_t __cdecl strncat_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) throw ( ) { return strncat_s ( _Dest, _Size, _Source, _Count ); }
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 6059) /* Removed pragma: #pragma warning(disable:6059)*/

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using strncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char *__cdecl strncat(char * _Dest, const char * _Source, size_t _Count); } 
/* Removed pragma: #pragma warning(pop)*/



extern "C" { __declspec(dllimport) int __cdecl strncmp(const char * _Str1, const char * _Str2, size_t _MaxCount); } 

extern "C" { __declspec(dllimport) int __cdecl _strnicmp(const char * _Str1, const char * _Str2, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) int __cdecl _strnicmp_l(const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale); } 

extern "C" { __declspec(dllimport) errno_t __cdecl strncpy_s(char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount); } 

template < size_t _Size > inline errno_t __cdecl strncpy_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) throw ( ) { return strncpy_s ( _Dest, _Size, _Source, _Count ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char *__cdecl strncpy(char * _Dest, const char * _Source, size_t _Count); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _strnset_s(char * _Str, size_t _SizeInBytes, int _Val, size_t _MaxCount); } 
template < size_t _Size > inline errno_t __cdecl _strnset_s ( char ( & _Dest ) [ _Size ], int _Val, size_t _Count ) throw ( ) { return _strnset_s ( _Dest, _Size, _Val, _Count ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _strnset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) char *__cdecl _strnset(char * _Dest, int _Val, size_t _Count); } 
extern "C" { __declspec(dllimport) const char *__cdecl strpbrk(const char * _Str, const char * _Control); } 
extern "C" { __declspec(dllimport) const char *__cdecl strrchr(const char * _Str, int _Ch); } 
extern "C" { __declspec(dllimport) char *__cdecl _strrev(char * _Str); } 
extern "C" { __declspec(dllimport) size_t __cdecl strspn(const char * _Str, const char * _Control); } 
extern "C" { __declspec(dllimport) const char *__cdecl strstr(const char * _Str, const char * _SubStr); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using strtok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) char *__cdecl strtok(char * _Str, const char * _Delim); } 

extern "C" { __declspec(dllimport) char *__cdecl strtok_s(char * _Str, const char * _Delim, char ** _Context); } 

extern "C" { __declspec(dllimport) errno_t __cdecl _strupr_s(char * _Str, size_t _Size); } 
template < size_t _Size > inline errno_t __cdecl _strupr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strupr_s ( _String, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _strupr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char *__cdecl _strupr(char * _String); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _strupr_s_l(char * _Str, size_t _Size, _locale_t _Locale); } 
template < size_t _Size > inline errno_t __cdecl _strupr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strupr_s_l ( _String, _Size, _Locale ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _strupr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) char *__cdecl _strupr_l(char * _String, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) size_t __cdecl strxfrm(char * _Dst, const char * _Src, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) size_t __cdecl _strxfrm_l(char * _Dst, const char * _Src, size_t _MaxCount, _locale_t _Locale); } 
#line 214
inline char *__cdecl strchr(char *_Str, int _Ch) 
{ return (char *)strchr((const char *)_Str, _Ch); } 
inline char *__cdecl strpbrk(char *_Str, const char *_Control) 
{ return (char *)strpbrk((const char *)_Str, _Control); } 
inline char *__cdecl strrchr(char *_Str, int _Ch) 
{ return (char *)strrchr((const char *)_Str, _Ch); } 
inline char *__cdecl strstr(char *_Str, const char *_SubStr) 
{ return (char *)strstr((const char *)_Str, _SubStr); } 



inline void *__cdecl memchr(void *_Pv, int _C, size_t _N) 
{ return (void *)memchr((const void *)_Pv, _C, _N); } 
#line 238
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strdup. See online help for details.")) __declspec(dllimport) char *__cdecl strdup(const char * _Src); } 
#line 245
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strcmpi. See online help for details.")) __declspec(dllimport) int __cdecl strcmpi(const char * _Str1, const char * _Str2); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _stricmp. See online help for details.")) __declspec(dllimport) int __cdecl stricmp(const char * _Str1, const char * _Str2); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strlwr. See online help for details.")) __declspec(dllimport) char *__cdecl strlwr(char * _Str); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strnicmp. See online help for details.")) __declspec(dllimport) int __cdecl strnicmp(const char * _Str1, const char * _Str, size_t _MaxCount); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strnset. See online help for details.")) __declspec(dllimport) char *__cdecl strnset(char * _Str, int _Val, size_t _MaxCount); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strrev. See online help for details.")) __declspec(dllimport) char *__cdecl strrev(char * _Str); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strset. See online help for details.")) char *__cdecl strset(char * _Str, int _Val); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strupr. See online help for details.")) __declspec(dllimport) char *__cdecl strupr(char * _Str); } 
#line 266
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsdup(const __wchar_t * _Str); } 
#line 273
extern "C" { __declspec(dllimport) errno_t __cdecl wcscat_s(__wchar_t * _Dst, rsize_t _SizeInWords, const __wchar_t * _Src); } 

template < size_t _Size > inline errno_t __cdecl wcscat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) throw ( ) { return wcscat_s ( _Dest, _Size, _Source ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using wcscat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcscat(__wchar_t * _Dest, const __wchar_t * _Source); } 
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcschr(const __wchar_t * _Str, __wchar_t _Ch); } 
extern "C" { __declspec(dllimport) int __cdecl wcscmp(const __wchar_t * _Str1, const __wchar_t * _Str2); } 

extern "C" { __declspec(dllimport) errno_t __cdecl wcscpy_s(__wchar_t * _Dst, rsize_t _SizeInWords, const __wchar_t * _Src); } 

template < size_t _Size > inline errno_t __cdecl wcscpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) throw ( ) { return wcscpy_s ( _Dest, _Size, _Source ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using wcscpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcscpy(__wchar_t * _Dest, const __wchar_t * _Source); } 
extern "C" { __declspec(dllimport) size_t __cdecl wcscspn(const __wchar_t * _Str, const __wchar_t * _Control); } 
extern "C" { __declspec(dllimport) size_t __cdecl wcslen(const __wchar_t * _Str); } 
extern "C" { __declspec(dllimport) size_t __cdecl wcsnlen(const __wchar_t * _Src, size_t _MaxCount); } 

extern "C" { static __inline size_t __cdecl wcsnlen_s(const __wchar_t *_Src, size_t _MaxCount) 
{ 
return (_Src == 0) ? 0 : (wcsnlen(_Src, _MaxCount)); 
} } 


extern "C" { __declspec(dllimport) errno_t __cdecl wcsncat_s(__wchar_t * _Dst, rsize_t _SizeInWords, const __wchar_t * _Src, rsize_t _MaxCount); } 

template < size_t _Size > inline errno_t __cdecl wcsncat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) throw ( ) { return wcsncat_s ( _Dest, _Size, _Source, _Count ); }
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 6059) /* Removed pragma: #pragma warning(disable:6059)*/
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using wcsncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcsncat(__wchar_t * _Dest, const __wchar_t * _Source, size_t _Count); } 
/* Removed pragma: #pragma warning(pop)*/
extern "C" { __declspec(dllimport) int __cdecl wcsncmp(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 

extern "C" { __declspec(dllimport) errno_t __cdecl wcsncpy_s(__wchar_t * _Dst, rsize_t _SizeInWords, const __wchar_t * _Src, rsize_t _MaxCount); } 

template < size_t _Size > inline errno_t __cdecl wcsncpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) throw ( ) { return wcsncpy_s ( _Dest, _Size, _Source, _Count ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcsncpy(__wchar_t * _Dest, const __wchar_t * _Source, size_t _Count); } 
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcspbrk(const __wchar_t * _Str, const __wchar_t * _Control); } 
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcsrchr(const __wchar_t * _Str, __wchar_t _Ch); } 
extern "C" { __declspec(dllimport) size_t __cdecl wcsspn(const __wchar_t * _Str, const __wchar_t * _Control); } 
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcsstr(const __wchar_t * _Str, const __wchar_t * _SubStr); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using wcstok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcstok(__wchar_t * _Str, const __wchar_t * _Delim); } 

extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcstok_s(__wchar_t * _Str, const __wchar_t * _Delim, __wchar_t ** _Context); } 

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wcserror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wcserror(int _ErrNum); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wcserror_s(__wchar_t * _Buf, size_t _SizeInWords, int _ErrNum); } 
template < size_t _Size > inline errno_t __cdecl _wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], int _Error ) throw ( ) { return _wcserror_s ( _Buffer, _Size, _Error ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using __wcserror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl __wcserror(const __wchar_t * _Str); } 
extern "C" { __declspec(dllimport) errno_t __cdecl __wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _ErrMsg); } 
template < size_t _Size > inline errno_t __cdecl __wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], const wchar_t * _ErrorMessage ) throw ( ) { return __wcserror_s ( _Buffer, _Size, _ErrorMessage ); }

extern "C" { __declspec(dllimport) int __cdecl _wcsicmp(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
extern "C" { __declspec(dllimport) int __cdecl _wcsicmp_l(const __wchar_t * _Str1, const __wchar_t * _Str2, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _wcsnicmp(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) int __cdecl _wcsnicmp_l(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsnset_s(__wchar_t * _Dst, size_t _SizeInWords, __wchar_t _Val, size_t _MaxCount); } 
template < size_t _Size > inline errno_t __cdecl _wcsnset_s ( wchar_t ( & _Dst ) [ _Size ], wchar_t _Val, size_t _MaxCount ) throw ( ) { return _wcsnset_s ( _Dst, _Size, _Val, _MaxCount ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsnset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wcsnset(__wchar_t * _Str, __wchar_t _Val, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsrev(__wchar_t * _Str); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsset_s(__wchar_t * _Dst, size_t _SizeInWords, __wchar_t _Value); } 
template < size_t _Size > inline errno_t __cdecl _wcsset_s ( wchar_t ( & _Str ) [ _Size ], wchar_t _Val ) throw ( ) { return _wcsset_s ( _Str, _Size, _Val ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wcsset(__wchar_t * _Str, __wchar_t _Val); } 

extern "C" { __declspec(dllimport) errno_t __cdecl _wcslwr_s(__wchar_t * _Str, size_t _SizeInWords); } 
template < size_t _Size > inline errno_t __cdecl _wcslwr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcslwr_s ( _String, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wcslwr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wcslwr(__wchar_t * _String); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(__wchar_t * _Str, size_t _SizeInWords, _locale_t _Locale); } 
template < size_t _Size > inline errno_t __cdecl _wcslwr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcslwr_s_l ( _String, _Size, _Locale ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wcslwr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wcslwr_l(__wchar_t * _String, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsupr_s(__wchar_t * _Str, size_t _Size); } 
template < size_t _Size > inline errno_t __cdecl _wcsupr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcsupr_s ( _String, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsupr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wcsupr(__wchar_t * _String); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(__wchar_t * _Str, size_t _Size, _locale_t _Locale); } 
template < size_t _Size > inline errno_t __cdecl _wcsupr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcsupr_s_l ( _String, _Size, _Locale ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsupr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wcsupr_l(__wchar_t * _String, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) size_t __cdecl wcsxfrm(__wchar_t * _Dst, const __wchar_t * _Src, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) size_t __cdecl _wcsxfrm_l(__wchar_t * _Dst, const __wchar_t * _Src, size_t _MaxCount, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl wcscoll(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
extern "C" { __declspec(dllimport) int __cdecl _wcscoll_l(const __wchar_t * _Str1, const __wchar_t * _Str2, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _wcsicoll(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
extern "C" { __declspec(dllimport) int __cdecl _wcsicoll_l(const __wchar_t * _Str1, const __wchar_t * _Str2, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _wcsncoll(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) int __cdecl _wcsncoll_l(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _wcsnicoll(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 
extern "C" { __declspec(dllimport) int __cdecl _wcsnicoll_l(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale); } 
#line 361
inline __wchar_t *__cdecl wcschr(__wchar_t *_Str, __wchar_t _Ch) 
{ return ((__wchar_t *)wcschr((const __wchar_t *)_Str, _Ch)); } 
inline __wchar_t *__cdecl wcspbrk(__wchar_t *_Str, const __wchar_t *_Control) 
{ return ((__wchar_t *)wcspbrk((const __wchar_t *)_Str, _Control)); } 
inline __wchar_t *__cdecl wcsrchr(__wchar_t *_Str, __wchar_t _Ch) 
{ return ((__wchar_t *)wcsrchr((const __wchar_t *)_Str, _Ch)); } 
inline __wchar_t *__cdecl wcsstr(__wchar_t *_Str, const __wchar_t *_SubStr) 
{ return ((__wchar_t *)wcsstr((const __wchar_t *)_Str, _SubStr)); } 
#line 380
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsdup. See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcsdup(const __wchar_t * _Str); } 
#line 390
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsicmp. See online help for details.")) __declspec(dllimport) int __cdecl wcsicmp(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsnicmp. See online help for details.")) __declspec(dllimport) int __cdecl wcsnicmp(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsnset. See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcsnset(__wchar_t * _Str, __wchar_t _Val, size_t _MaxCount); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsrev. See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcsrev(__wchar_t * _Str); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsset. See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcsset(__wchar_t * _Str, __wchar_t _Val); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcslwr. See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcslwr(__wchar_t * _Str); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsupr. See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl wcsupr(__wchar_t * _Str); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsicoll. See online help for details.")) __declspec(dllimport) int __cdecl wcsicoll(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
#line 84 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
namespace std { 
#line 93
class exception { 


public: exception(); 
CPPTEST_IMP__ZNSt9exceptionC9ERKPKc explicit exception(const char *const &); 
exception(const char *const &, int); 
CPPTEST_IMP__ZNSt9exceptionC9ERKS_ exception(const exception &); 
exception &operator=(const exception &); 
CPPTEST_IMP__ZNSt9exceptionD9Ev virtual ~exception(); 
CPPTEST_IMP__ZNKSt9exception4whatEv virtual const char *what() const; 


private: void _Copy_str(const char *); 
void _Tidy(); 

const char *_Mywhat; 
bool _Mydofree; 
}; 
#line 192
using ::set_terminate;using ::terminate_handler;using ::terminate;using ::set_unexpected;using ::unexpected_handler;using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception &); 

CPPTEST_IMP__ZSt18uncaught_exceptionv bool __cdecl uncaught_exception(); 

}
#line 310
namespace std { 
#line 316
class bad_exception : public exception { 


public: bad_exception(const char *_Message = "bad exception") throw() : exception(_Message) 


{ 
} 

virtual ~bad_exception() throw() 
{ 
} 
#line 337
}; 


class bad_alloc : public exception { 


public: bad_alloc(const char *_Message) throw() : exception(_Message) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

bad_alloc() throw() : exception("bad allocation", 1) 

{ 
} 

virtual ~bad_alloc() throw() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 
#line 365
}; 



class bad_array_new_length : public bad_alloc { 




public: bad_array_new_length() throw() : bad_alloc("bad array new length") 

{ 
} 
}; 



}
#line 394
__declspec(dllimport) void __cdecl __ExceptionPtrCreate(void *); 
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(void *); 
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(void *, const void *); 
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(void *, const void *); 
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(const void *, const void *); 

__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(void *); 
__declspec(dllimport) void __cdecl __ExceptionPtrRethrow(const void *); 
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(void *, const void *, const void *); 

namespace std { 


typedef nullptr_t _Null_type; 




class _Exception_ptr { 


public: _Exception_ptr() 
{ 
__ExceptionPtrCreate(this); 
} 
_Exception_ptr(_Null_type) 
{ 
__ExceptionPtrCreate(this); 
} 
~_Exception_ptr() 
{ 
__ExceptionPtrDestroy(this); 
} 
_Exception_ptr(const _Exception_ptr &_Rhs) 
{ 
__ExceptionPtrCopy(this, const_cast< _Exception_ptr *>(&_Rhs)); 
} 
_Exception_ptr &operator=(const _Exception_ptr &_Rhs) 
{ 
__ExceptionPtrAssign(this, const_cast< _Exception_ptr *>(&_Rhs)); 
return *this; 
} 
_Exception_ptr &operator=(_Null_type) 
{ 
_Exception_ptr _Ptr; 
__ExceptionPtrAssign(this, &_Ptr); 
return *this; 
} 

void _RethrowException() const 
{ 
__ExceptionPtrRethrow(const_cast< _Exception_ptr *>(this)); 
} 

static _Exception_ptr _Current_exception() 
{ 
_Exception_ptr _Retval; 
__ExceptionPtrCurrentException(&_Retval); 
return _Retval; 
} 
static _Exception_ptr _Copy_exception(void *_Except, const void *_Ptr) 
{ 
_Exception_ptr _Retval = 0; 
if (!_Ptr) 
{ 

return _Retval; 
}  
__ExceptionPtrCopyException(&_Retval, _Except, _Ptr); 
return _Retval; 
} 

private: void *_Data1; 
void *_Data2; 
}; 

inline bool operator==(const _Exception_ptr &_Lhs, const _Exception_ptr &_Rhs) 
{ 
return __ExceptionPtrCompare(const_cast< _Exception_ptr *>(&_Lhs), const_cast< _Exception_ptr *>(&_Rhs)); 
} 

inline bool operator==(_Null_type, const _Exception_ptr &_Rhs) 
{ 
_Exception_ptr _Ptr; 
return __ExceptionPtrCompare(&_Ptr, const_cast< _Exception_ptr *>(&_Rhs)); 
} 

inline bool operator==(const _Exception_ptr &_Lhs, _Null_type) 
{ 
return operator==(0, _Lhs); 
} 

typedef _Exception_ptr exception_ptr; 

inline exception_ptr current_exception() 
{ 
return _Exception_ptr::_Current_exception(); 
} 

inline void rethrow_exception(exception_ptr _P) 
{ 
_P._RethrowException(); 
} 

template < class _E > void * __GetExceptionInfo ( _E );

template < class _E > exception_ptr copy_exception ( _E _Except )
 {
 return _Exception_ptr :: _Copy_exception ( & _Except, __GetExceptionInfo ( _Except ) );
 }

}
#line 513
/* Removed pragma: #pragma warning(pop)*/
#pragma pack ( pop )
#line 19 "C:\\Program Files\\Parasoft\\C++test for Visual Studio\\9.5\\engine\\runtime\\include\\cpptest.h"
struct __CPTR_AddressOfType { }; 
#line 512
struct __CPTR_TestRunner; 
#line 614
static const char *CPPTEST_DS_GET_CSTR(const char *name) 
{ 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->getCStr || cpptestDsMethodNotInitialized("getCStr"))), (cpptestGetCurrentDataSource()->getCStr))(cpptestGetCurrentDataSource(), name); 
} 

static const CppTest_wchar_t *CPPTEST_DS_GET_WCSTR(const char *name) 
{ 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->getWCStr || cpptestDsMethodNotInitialized("getWCStr"))), (cpptestGetCurrentDataSource()->getWCStr))(cpptestGetCurrentDataSource(), name); 
} 

static const char *CPPTEST_DS_GET_MEM_BUFFER(const char *name, unsigned *sizePtr) 
{ 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->getMemBuffer || cpptestDsMethodNotInitialized("getMemBuffer"))), (cpptestGetCurrentDataSource()->getMemBuffer))(cpptestGetCurrentDataSource(), name, sizePtr); 
} 
static __int64 CPPTEST_DS_GET_INTEGER(const char *name) 
{ 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->getInteger || cpptestDsMethodNotInitialized("getInteger"))), (cpptestGetCurrentDataSource()->getInteger))(cpptestGetCurrentDataSource(), name); 
} 
static unsigned __int64 CPPTEST_DS_GET_UINTEGER(const char *name) 
{ 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->getUInteger || cpptestDsMethodNotInitialized("getUInteger"))), (cpptestGetCurrentDataSource()->getUInteger))(cpptestGetCurrentDataSource(), name); 
} 
static double CPPTEST_DS_GET_FLOAT(const char *name) 
{ 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->getFloat || cpptestDsMethodNotInitialized("getFloat"))), (cpptestGetCurrentDataSource()->getFloat))(cpptestGetCurrentDataSource(), name); 
} 
static int CPPTEST_DS_GET_BOOL(const char *name) 
{ 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->getBool || cpptestDsMethodNotInitialized("getBool"))), (cpptestGetCurrentDataSource()->getBool))(cpptestGetCurrentDataSource(), name); 
} 
static char CPPTEST_DS_GET_CHAR(const char *name) 
{ 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->getChar || cpptestDsMethodNotInitialized("getChar"))), (cpptestGetCurrentDataSource()->getChar))(cpptestGetCurrentDataSource(), name); 
} 
static unsigned CPPTEST_DS_GET_ITERATION() 
{ 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->getIteration || cpptestDsMethodNotInitialized("getIteration"))), (cpptestGetCurrentDataSource()->getIteration))(cpptestGetCurrentDataSource()); 
} 
static int CPPTEST_DS_HAS_COLUMN(const char *name) 
{ 
if (cpptestGetCurrentDataSource() && ((((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->hasColumn || cpptestDsMethodNotInitialized("hasColumn"))), (cpptestGetCurrentDataSource()->hasColumn)))) { 
return (((cpptestGetCurrentDataSource() || cpptestDsNotInitialized()), (cpptestGetCurrentDataSource()->hasColumn || cpptestDsMethodNotInitialized("hasColumn"))), (cpptestGetCurrentDataSource()->hasColumn))(cpptestGetCurrentDataSource(), name); 
}  
return 0; 
} 
#line 806
extern "C" { typedef int CPPTEST_CALL_ROUTINE(const char *); }
#line 943
struct CppTest_TestSuite { 




virtual void setUp() 
{ 
} 




virtual void tearDown() 
{ 
} 

virtual ~CppTest_TestSuite() 
{ 
} 
}; 
#line 24 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
#pragma pack ( push, 8 )
#line 37
extern "C" { struct _exception { 
int type; 
char *name; 
double arg1; 
double arg2; 
double retval; 
}; }
#line 54
extern "C" { struct _complex { 
double x, y; 
}; }
#line 88
extern "C" __declspec(dllimport) double _HUGE; 
#line 106
extern "C" { double __cdecl acos(double _X); } 
extern "C" { double __cdecl asin(double _X); } 
extern "C" { double __cdecl atan(double _X); } 
extern "C" { double __cdecl atan2(double _Y, double _X); } 

extern "C" { __declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign); } 
extern "C" { __declspec(dllimport) double __cdecl _chgsign(double _X); } 


extern "C" { double __cdecl cos(double _X); } 
extern "C" { double __cdecl cosh(double _X); } 
extern "C" { double __cdecl exp(double _X); } 
extern "C" { double __cdecl fabs(double _X); } 
extern "C" { double __cdecl fmod(double _X, double _Y); } 
extern "C" { double __cdecl log(double _X); } 
extern "C" { double __cdecl log10(double _X); } 
extern "C" { double __cdecl pow(double _X, double _Y); } 
extern "C" { double __cdecl sin(double _X); } 
extern "C" { double __cdecl sinh(double _X); } 
extern "C" { double __cdecl tan(double _X); } 
extern "C" { double __cdecl tanh(double _X); } 
extern "C" { double __cdecl sqrt(double _X); } 
#line 134
extern "C" { __declspec(dllimport) double __cdecl _cabs(_complex _Complex_value); } 
extern "C" { __declspec(dllimport) double __cdecl ceil(double _X); } 
extern "C" { __declspec(dllimport) double __cdecl floor(double _X); } 
extern "C" { __declspec(dllimport) double __cdecl frexp(double _X, int * _Y); } 
extern "C" { __declspec(dllimport) double __cdecl _hypot(double _X, double _Y); } 
extern "C" { __declspec(dllimport) float __cdecl _hypotf(float _X, float _Y); } 
extern "C" { __declspec(dllimport) double __cdecl _j0(double _X); } 
extern "C" { __declspec(dllimport) double __cdecl _j1(double _X); } 
extern "C" { __declspec(dllimport) double __cdecl _jn(int _X, double _Y); } 
extern "C" { __declspec(dllimport) double __cdecl ldexp(double _X, int _Y); } 
#line 149
extern "C" { int __cdecl _matherr(_exception * _Except); } 


extern "C" { __declspec(dllimport) double __cdecl modf(double _X, double * _Y); } 

extern "C" { __declspec(dllimport) double __cdecl _y0(double _X); } 
extern "C" { __declspec(dllimport) double __cdecl _y1(double _X); } 
extern "C" { __declspec(dllimport) double __cdecl _yn(int _X, double _Y); } 




extern "C" { static __inline double __cdecl hypot(double _X, double _Y) 
{ 
return _hypot(_X, _Y); 
} } 

extern "C" { static __inline float __cdecl hypotf(float _X, float _Y) 
{ 
return _hypotf(_X, _Y); 
} } 
#line 175
extern "C" { __declspec(dllimport) int __cdecl _set_SSE2_enable(int _Flag); } 
#line 328
extern "C" { inline long double acosl(long double _X) 
{ return (acos((double)_X)); } } 
extern "C" { inline long double asinl(long double _X) 
{ return (asin((double)_X)); } } 
extern "C" { inline long double atanl(long double _X) 
{ return (atan((double)_X)); } } 
extern "C" { inline long double atan2l(long double _Y, long double _X) 
{ return (atan2((double)_Y, (double)_X)); } } 
extern "C" { inline long double ceill(long double _X) 
{ return (ceil((double)_X)); } } 
extern "C" { inline long double cosl(long double _X) 
{ return (cos((double)_X)); } } 
extern "C" { inline long double coshl(long double _X) 
{ return (cosh((double)_X)); } } 
extern "C" { inline long double expl(long double _X) 
{ return (exp((double)_X)); } } 
extern "C" { inline long double fabsl(long double _X) 
{ return (fabs((double)_X)); } } 
extern "C" { inline long double floorl(long double _X) 
{ return (floor((double)_X)); } } 
extern "C" { inline long double fmodl(long double _X, long double _Y) 
{ return (fmod((double)_X, (double)_Y)); } } 
extern "C" { inline long double frexpl(long double _X, int *_Y) 
{ return (frexp((double)_X, _Y)); } } 
extern "C" { inline long double ldexpl(long double _X, int _Y) 
{ return (ldexp((double)_X, _Y)); } } 
extern "C" { inline long double logl(long double _X) 
{ return (log((double)_X)); } } 
extern "C" { inline long double log10l(long double _X) 
{ return (log10((double)_X)); } } 
extern "C" { inline long double modfl(long double _X, long double *_Y) 
{ double _Di, _Df = modf((double)_X, &_Di); 
*_Y = (long double)_Di; 
return (_Df); } } 
extern "C" { inline long double powl(long double _X, long double _Y) 
{ return (pow((double)_X, (double)_Y)); } } 
extern "C" { inline long double sinl(long double _X) 
{ return (sin((double)_X)); } } 
extern "C" { inline long double sinhl(long double _X) 
{ return (sinh((double)_X)); } } 
extern "C" { inline long double sqrtl(long double _X) 
{ return (sqrt((double)_X)); } } 

extern "C" { inline long double tanl(long double _X) 
{ return (tan((double)_X)); } } 




extern "C" { inline long double tanhl(long double _X) 
{ return (tanh((double)_X)); } } 

extern "C" { inline long double _chgsignl(long double _Number) 
{ 
return _chgsign(static_cast< double>(_Number)); 
} } 

extern "C" { inline long double _copysignl(long double _Number, long double _Sign) 
{ 
return _copysign(static_cast< double>(_Number), static_cast< double>(_Sign)); 
} } 

extern "C" { inline float frexpf(float _X, int *_Y) 
{ return ((float)frexp((double)_X, _Y)); } } 


extern "C" { inline float fabsf(float _X) 
{ return ((float)fabs((double)_X)); } } 
extern "C" { inline float ldexpf(float _X, int _Y) 
{ return ((float)ldexp((double)_X, _Y)); } } 

extern "C" { inline float acosf(float _X) 
{ return ((float)acos((double)_X)); } } 
extern "C" { inline float asinf(float _X) 
{ return ((float)asin((double)_X)); } } 
extern "C" { inline float atanf(float _X) 
{ return ((float)atan((double)_X)); } } 
extern "C" { inline float atan2f(float _Y, float _X) 
{ return ((float)atan2((double)_Y, (double)_X)); } } 
extern "C" { inline float ceilf(float _X) 
{ return ((float)ceil((double)_X)); } } 
extern "C" { inline float cosf(float _X) 
{ return ((float)cos((double)_X)); } } 
extern "C" { inline float coshf(float _X) 
{ return ((float)cosh((double)_X)); } } 
extern "C" { inline float expf(float _X) 
{ return ((float)exp((double)_X)); } } 
extern "C" { inline float floorf(float _X) 
{ return ((float)floor((double)_X)); } } 
extern "C" { inline float fmodf(float _X, float _Y) 
{ return ((float)fmod((double)_X, (double)_Y)); } } 
extern "C" { inline float logf(float _X) 
{ return ((float)log((double)_X)); } } 
extern "C" { inline float log10f(float _X) 
{ return ((float)log10((double)_X)); } } 
extern "C" { inline float modff(float _X, float *_Y) 
{ double _Di, _Df = modf((double)_X, &_Di); 
*_Y = (float)_Di; 
return ((float)_Df); } } 
extern "C" { inline float powf(float _X, float _Y) 
{ return ((float)pow((double)_X, (double)_Y)); } } 
extern "C" { inline float sinf(float _X) 
{ return ((float)sin((double)_X)); } } 
extern "C" { inline float sinhf(float _X) 
{ return ((float)sinh((double)_X)); } } 
extern "C" { inline float sqrtf(float _X) 
{ return ((float)sqrt((double)_X)); } } 
extern "C" { inline float tanf(float _X) 
{ return ((float)tan((double)_X)); } } 
extern "C" { inline float tanhf(float _X) 
{ return ((float)tanh((double)_X)); } } 
#line 460
extern "C" __declspec(dllimport) double HUGE; 




extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _cabs. See online help for details.")) __declspec(dllimport) double __cdecl cabs(_complex _X); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _j0. See online help for details.")) __declspec(dllimport) double __cdecl j0(double _X); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _j1. See online help for details.")) __declspec(dllimport) double __cdecl j1(double _X); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _jn. See online help for details.")) __declspec(dllimport) double __cdecl jn(int _X, double _Y); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _y0. See online help for details.")) __declspec(dllimport) double __cdecl y0(double _X); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _y1. See online help for details.")) __declspec(dllimport) double __cdecl y1(double _X); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _yn. See online help for details.")) __declspec(dllimport) double __cdecl yn(int _X, double _Y); } 
#line 482
template < class _Ty > inline
        _Ty _Pow_int ( _Ty _X, int _Y )
        { unsigned int _N;
        if ( _Y >= 0 )
                _N = ( unsigned int ) _Y;
        else
                _N = ( unsigned int ) ( - _Y );
        for ( _Ty _Z = _Ty ( 1 );; _X *= _X )
                { if ( ( _N & 1 ) != 0 )
                        _Z *= _X;
                if ( ( _N >>= 1 ) == 0 )
                        return ( _Y < 0 ? _Ty ( 1 ) / _Z : _Z ); } }

inline double __cdecl abs(double _X) 
{ return (fabs(_X)); } 
inline double __cdecl pow(double _X, int _Y) 
{ return (_Pow_int(_X, _Y)); } 
inline float __cdecl abs(float _X) 
{ return (fabsf(_X)); } 
inline float __cdecl acos(float _X) 
{ return (acosf(_X)); } 
inline float __cdecl asin(float _X) 
{ return (asinf(_X)); } 
inline float __cdecl atan(float _X) 
{ return (atanf(_X)); } 
inline float __cdecl atan2(float _Y, float _X) 
{ return (atan2f(_Y, _X)); } 
inline float __cdecl ceil(float _X) 
{ return (ceilf(_X)); } 
inline float __cdecl cos(float _X) 
{ return (cosf(_X)); } 
inline float __cdecl cosh(float _X) 
{ return (coshf(_X)); } 
inline float __cdecl exp(float _X) 
{ return (expf(_X)); } 
inline float __cdecl fabs(float _X) 
{ return (fabsf(_X)); } 
inline float __cdecl floor(float _X) 
{ return (floorf(_X)); } 
inline float __cdecl fmod(float _X, float _Y) 
{ return (fmodf(_X, _Y)); } 
inline float __cdecl frexp(float _X, int *_Y) 
{ return (frexpf(_X, _Y)); } 
inline float __cdecl ldexp(float _X, int _Y) 
{ return (ldexpf(_X, _Y)); } 
inline float __cdecl log(float _X) 
{ return (logf(_X)); } 
inline float __cdecl log10(float _X) 
{ return (log10f(_X)); } 
inline float __cdecl modf(float _X, float *_Y) 
{ return (modff(_X, _Y)); } 
inline float __cdecl pow(float _X, float _Y) 
{ return (powf(_X, _Y)); } 
inline float __cdecl pow(float _X, int _Y) 
{ return (_Pow_int(_X, _Y)); } 
inline float __cdecl sin(float _X) 
{ return (sinf(_X)); } 
inline float __cdecl sinh(float _X) 
{ return (sinhf(_X)); } 
inline float __cdecl sqrt(float _X) 
{ return (sqrtf(_X)); } 
inline float __cdecl tan(float _X) 
{ return (tanf(_X)); } 
inline float __cdecl tanh(float _X) 
{ return (tanhf(_X)); } 
inline long double __cdecl abs(long double _X) 
{ return (fabsl(_X)); } 
inline long double __cdecl acos(long double _X) 
{ return (acosl(_X)); } 
inline long double __cdecl asin(long double _X) 
{ return (asinl(_X)); } 
inline long double __cdecl atan(long double _X) 
{ return (atanl(_X)); } 
inline long double __cdecl atan2(long double _Y, long double _X) 
{ return (atan2l(_Y, _X)); } 
inline long double __cdecl ceil(long double _X) 
{ return (ceill(_X)); } 
inline long double __cdecl cos(long double _X) 
{ return (cosl(_X)); } 
inline long double __cdecl cosh(long double _X) 
{ return (coshl(_X)); } 
inline long double __cdecl exp(long double _X) 
{ return (expl(_X)); } 
inline long double __cdecl fabs(long double _X) 
{ return (fabsl(_X)); } 
inline long double __cdecl floor(long double _X) 
{ return (floorl(_X)); } 
inline long double __cdecl fmod(long double _X, long double _Y) 
{ return (fmodl(_X, _Y)); } 
inline long double __cdecl frexp(long double _X, int *_Y) 
{ return (frexpl(_X, _Y)); } 
inline long double __cdecl ldexp(long double _X, int _Y) 
{ return (ldexpl(_X, _Y)); } 
inline long double __cdecl log(long double _X) 
{ return (logl(_X)); } 
inline long double __cdecl log10(long double _X) 
{ return (log10l(_X)); } 
inline long double __cdecl modf(long double _X, long double *_Y) 
{ return (modfl(_X, _Y)); } 
inline long double __cdecl pow(long double _X, long double _Y) 
{ return (powl(_X, _Y)); } 
inline long double __cdecl pow(long double _X, int _Y) 
{ return (_Pow_int(_X, _Y)); } 
inline long double __cdecl sin(long double _X) 
{ return (sinl(_X)); } 
inline long double __cdecl sinh(long double _X) 
{ return (sinhl(_X)); } 
inline long double __cdecl sqrt(long double _X) 
{ return (sqrtl(_X)); } 
inline long double __cdecl tan(long double _X) 
{ return (tanl(_X)); } 
inline long double __cdecl tanh(long double _X) 
{ return (tanhl(_X)); } 




#pragma pack ( pop )
#line 18 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\cmath"
namespace std { 
using ::acosf;using ::asinf;
using ::atanf;using ::atan2f;using ::ceilf;
using ::cosf;using ::coshf;using ::expf;
using ::fabsf;using ::floorf;using ::fmodf;
using ::frexpf;using ::ldexpf;using ::logf;
using ::log10f;using ::modff;using ::powf;
using ::sinf;using ::sinhf;using ::sqrtf;
using ::tanf;using ::tanhf;

using ::acosl;using ::asinl;
using ::atanl;using ::atan2l;using ::ceill;
using ::cosl;using ::coshl;using ::expl;
using ::fabsl;using ::floorl;using ::fmodl;
using ::frexpl;using ::ldexpl;using ::logl;
using ::log10l;using ::modfl;using ::powl;
using ::sinl;using ::sinhl;using ::sqrtl;
using ::tanl;using ::tanhl;

using ::abs;

using ::acos;using ::asin;
using ::atan;using ::atan2;using ::ceil;
using ::cos;using ::cosh;using ::exp;
using ::fabs;using ::floor;using ::fmod;
using ::frexp;using ::ldexp;using ::log;
using ::log10;using ::modf;using ::pow;
using ::sin;using ::sinh;using ::sqrt;
using ::tan;using ::tanh;
}
#line 26 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
#pragma pack ( push, 8 )
#line 56
extern "C" { struct _iobuf { 
char *_ptr; 
int _cnt; 
char *_base; 
int _flag; 
int _file; 
int _charbuf; 
int _bufsiz; 
char *_tmpfname; 
}; }
extern "C" { typedef _iobuf FILE; }
#line 129
extern "C" { __declspec(dllimport) FILE *__cdecl __iob_func(); } 
#line 145
extern "C" { typedef __int64 fpos_t; }
#line 186
extern "C" { __declspec(dllimport) int __cdecl _filbuf(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl _flsbuf(int _Ch, FILE * _File); } 




extern "C" { __declspec(dllimport) FILE *__cdecl _fsopen(const char * _Filename, const char * _Mode, int _ShFlag); } 


extern "C" { __declspec(dllimport) void __cdecl clearerr(FILE * _File); } 

extern "C" { __declspec(dllimport) errno_t __cdecl clearerr_s(FILE * _File); } 

extern "C" { __declspec(dllimport) int __cdecl fclose(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl _fcloseall(); } 




extern "C" { __declspec(dllimport) FILE *__cdecl _fdopen(int _FileHandle, const char * _Mode); } 


extern "C" { __declspec(dllimport) int __cdecl feof(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl ferror(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl fflush(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl fgetc(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl _fgetchar(); } 
extern "C" { __declspec(dllimport) int __cdecl fgetpos(FILE * _File, fpos_t * _Pos); } 
extern "C" { __declspec(dllimport) char *__cdecl fgets(char * _Buf, int _MaxCount, FILE * _File); } 




extern "C" { __declspec(dllimport) int __cdecl _fileno(FILE * _File); } 
#line 227
extern "C" { __declspec(dllimport) char *__cdecl _tempnam(const char * _DirName, const char * _FilePrefix); } 
#line 233
extern "C" { __declspec(dllimport) int __cdecl _flushall(); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) FILE *__cdecl fopen(const char * _Filename, const char * _Mode); } 

extern "C" { __declspec(dllimport) errno_t __cdecl fopen_s(FILE ** _File, const char * _Filename, const char * _Mode); } 

extern "C" { __declspec(dllimport) int __cdecl fprintf(FILE * _File, const char * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl fprintf_s(FILE * _File, const char * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl fputc(int _Ch, FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl _fputchar(int _Ch); } 
extern "C" { __declspec(dllimport) int __cdecl fputs(const char * _Str, FILE * _File); } 
extern "C" { __declspec(dllimport) size_t __cdecl fread(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File); } 

extern "C" { __declspec(dllimport) size_t __cdecl fread_s(void * _DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE * _File); } 

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using freopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) FILE *__cdecl freopen(const char * _Filename, const char * _Mode, FILE * _File); } 

extern "C" { __declspec(dllimport) errno_t __cdecl freopen_s(FILE ** _File, const char * _Filename, const char * _Mode, FILE * _OldFile); } 

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using fscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) int __cdecl fscanf(FILE * _File, const char * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _fscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) int __cdecl _fscanf_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 6530) /* Removed pragma: #pragma warning(disable:6530)*/

extern "C" { __declspec(dllimport) int __cdecl fscanf_s(FILE * _File, const char * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl _fscanf_s_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
/* Removed pragma: #pragma warning(pop)*/
extern "C" { __declspec(dllimport) int __cdecl fsetpos(FILE * _File, const fpos_t * _Pos); } 
extern "C" { __declspec(dllimport) int __cdecl fseek(FILE * _File, long _Offset, int _Origin); } 
extern "C" { __declspec(dllimport) long __cdecl ftell(FILE * _File); } 

extern "C" { __declspec(dllimport) int __cdecl _fseeki64(FILE * _File, __int64 _Offset, int _Origin); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _ftelli64(FILE * _File); } 

extern "C" { __declspec(dllimport) size_t __cdecl fwrite(const void * _Str, size_t _Size, size_t _Count, FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl getc(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl getchar(); } 
extern "C" { __declspec(dllimport) int __cdecl _getmaxstdio(); } 

extern "C" { __declspec(dllimport) char *__cdecl gets_s(char * _Buf, rsize_t _Size); } 

template < size_t _Size > inline char * __cdecl gets_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return gets_s ( _Buffer, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using gets_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See" " online help for details.")) __declspec(dllimport) char *__cdecl gets(char * _Buffer); } 
extern "C" { int __cdecl _getw(FILE * _File); } 




extern "C" { __declspec(dllimport) int __cdecl _pclose(FILE * _File); } 
extern "C" { __declspec(dllimport) FILE *__cdecl _popen(const char * _Command, const char * _Mode); } 
extern "C" { __declspec(dllimport) int __cdecl printf(const char * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl printf_s(const char * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl putc(int _Ch, FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl putchar(int _Ch); } 
extern "C" { __declspec(dllimport) int __cdecl puts(const char * _Str); } 
extern "C" { __declspec(dllimport) int __cdecl _putw(int _Word, FILE * _File); } 


extern "C" { __declspec(dllimport) int __cdecl remove(const char * _Filename); } 
extern "C" { __declspec(dllimport) int __cdecl rename(const char * _OldFilename, const char * _NewFilename); } 
extern "C" { __declspec(dllimport) int __cdecl _unlink(const char * _Filename); } 

extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _unlink. See online help for details.")) __declspec(dllimport) int __cdecl unlink(const char * _Filename); } 


extern "C" { __declspec(dllimport) void __cdecl rewind(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl _rmtmp(); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) int __cdecl scanf(const char * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _scanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) int __cdecl _scanf_l(const char * _Format, _locale_t _Locale, ...); } 
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 6530) /* Removed pragma: #pragma warning(disable:6530)*/

extern "C" { __declspec(dllimport) int __cdecl scanf_s(const char * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl _scanf_s_l(const char * _Format, _locale_t _Locale, ...); } 
/* Removed pragma: #pragma warning(pop)*/
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using setvbuf instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. Se" "e online help for details.")) __declspec(dllimport) void __cdecl setbuf(FILE * _File, char * _Buffer); } 
extern "C" { __declspec(dllimport) int __cdecl _setmaxstdio(int _Max); } 
extern "C" { __declspec(dllimport) unsigned __cdecl _set_output_format(unsigned _Format); } 
extern "C" { __declspec(dllimport) unsigned __cdecl _get_output_format(); } 
extern "C" { __declspec(dllimport) int __cdecl setvbuf(FILE * _File, char * _Buf, int _Mode, size_t _Size); } 
extern "C" { __declspec(dllimport) int __cdecl _snprintf_s(char * _DstBuf, size_t _SizeInBytes, size_t _MaxCount, const char * _Format, ...); } 
/* Removed pragma: __pragma( warning(push)) */__pragma(warning(disable: 4793) )/* Removed pragma: __pragma( warning(disable: 4793)) */template < size_t _Size > inline int __cdecl _snprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _ArgList ); }/* Removed pragma: __pragma( warning(pop)) */

extern "C" { CPPTEST_IMP_sprintf_s int __cdecl sprintf_s(char * _DstBuf, size_t _SizeInBytes, const char * _Format, ...); } 

/* Removed pragma: __pragma( warning(push)) */__pragma(warning(disable: 4793) )/* Removed pragma: __pragma( warning(disable: 4793)) */template < size_t _Size > inline int __cdecl sprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return vsprintf_s ( _Dest, _Size, _Format, _ArgList ); }/* Removed pragma: __pragma( warning(pop)) */
extern "C" { __declspec(dllimport) int __cdecl _scprintf(const char * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using sscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) int __cdecl sscanf(const char * _Src, const char * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _sscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) int __cdecl _sscanf_l(const char * _Src, const char * _Format, _locale_t _Locale, ...); } 
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 6530) /* Removed pragma: #pragma warning(disable:6530)*/

extern "C" { __declspec(dllimport) int __cdecl sscanf_s(const char * _Src, const char * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl _sscanf_s_l(const char * _Src, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _snscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) int __cdecl _snscanf(const char * _Src, size_t _MaxCount, const char * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _snscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) int __cdecl _snscanf_l(const char * _Src, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _snscanf_s(const char * _Src, size_t _MaxCount, const char * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _snscanf_s_l(const char * _Src, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
/* Removed pragma: #pragma warning(pop)*/
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using tmpfile_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) FILE *__cdecl tmpfile(); } 

extern "C" { __declspec(dllimport) errno_t __cdecl tmpfile_s(FILE ** _File); } 
extern "C" { __declspec(dllimport) errno_t __cdecl tmpnam_s(char * _Buf, rsize_t _Size); } 

template < size_t _Size > inline errno_t __cdecl tmpnam_s ( char ( & _Buf ) [ _Size ] ) throw ( ) { return tmpnam_s ( _Buf, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using tmpnam_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) char *__cdecl tmpnam(char * _Buffer); } 
extern "C" { __declspec(dllimport) int __cdecl ungetc(int _Ch, FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl vfprintf(FILE * _File, const char * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl vfprintf_s(FILE * _File, const char * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl vprintf(const char * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl vprintf_s(const char * _Format, va_list _ArgList); } 

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using vsnprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) int __cdecl vsnprintf(char * _DstBuf, size_t _MaxCount, const char * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl vsnprintf_s(char * _DstBuf, size_t _DstSize, size_t _MaxCount, const char * _Format, va_list _ArgList); } 
template < size_t _Size > inline int __cdecl vsnprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, va_list _Args ) throw ( ) { return vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _Args ); }

extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_s(char * _DstBuf, size_t _SizeInBytes, size_t _MaxCount, const char * _Format, va_list _ArgList); } 
template < size_t _Size > inline int __cdecl _vsnprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, va_list _Args ) throw ( ) { return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _Args ); }
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4793) /* Removed pragma: #pragma warning(disable:4793)*/
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _snprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) int __cdecl _snprintf(char * _Dest, size_t _Count, const char * _Format, ...); } extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf(char * _Dest, size_t _Count, const char * _Format, va_list _Args); } 
/* Removed pragma: #pragma warning(pop)*/

extern "C" { __declspec(dllimport) int __cdecl vsprintf_s(char * _DstBuf, size_t _SizeInBytes, const char * _Format, va_list _ArgList); } 
template < size_t _Size > inline int __cdecl vsprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, va_list _Args ) throw ( ) { return vsprintf_s ( _Dest, _Size, _Format, _Args ); }

/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4793) /* Removed pragma: #pragma warning(disable:4793)*/
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using sprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int __cdecl sprintf(char * _Dest, const char * _Format, ...); } extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using vsprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) int __cdecl vsprintf(char * _Dest, const char * _Format, va_list _Args); } 
/* Removed pragma: #pragma warning(pop)*/
extern "C" { __declspec(dllimport) int __cdecl _vscprintf(const char * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _snprintf_c(char * _DstBuf, size_t _MaxCount, const char * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_c(char * _DstBuf, size_t _MaxCount, const char * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _fprintf_p(FILE * _File, const char * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _printf_p(const char * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _sprintf_p(char * _Dst, size_t _MaxCount, const char * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_p(FILE * _File, const char * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vprintf_p(const char * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_p(char * _Dst, size_t _MaxCount, const char * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _scprintf_p(const char * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_p(const char * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _set_printf_count_output(int _Value); } 
extern "C" { __declspec(dllimport) int __cdecl _get_printf_count_output(); } 

extern "C" { __declspec(dllimport) int __cdecl _printf_l(const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _printf_p_l(const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _printf_s_l(const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vprintf_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vprintf_p_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vprintf_s_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _fprintf_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _fprintf_p_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _fprintf_s_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_l(FILE * _File, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_p_l(FILE * _File, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_s_l(FILE * _File, const char * _Format, _locale_t _Locale, va_list _ArgList); } 

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _sprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) int __cdecl _sprintf_l(char * _DstBuf, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _sprintf_p_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _sprintf_s_l(char * _DstBuf, size_t _DstSize, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _vsprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNIN" "GS. See online help for details.")) __declspec(dllimport) int __cdecl _vsprintf_l(char * _DstBuf, const char * _Format, _locale_t, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_p_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_s_l(char * _DstBuf, size_t _DstSize, const char * _Format, _locale_t _Locale, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _scprintf_l(const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _scprintf_p_l(const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_p_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _snprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNIN" "GS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _snprintf_c_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _snprintf_s_l(char * _DstBuf, size_t _DstSize, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNI" "NGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_c_l(char * _DstBuf, size_t _MaxCount, const char *, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_s_l(char * _DstBuf, size_t _DstSize, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 432
extern "C" { __declspec(dllimport) FILE *__cdecl _wfsopen(const __wchar_t * _Filename, const __wchar_t * _Mode, int _ShFlag); } 


extern "C" { __declspec(dllimport) wint_t __cdecl fgetwc(FILE * _File); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _fgetwchar(); } 
extern "C" { __declspec(dllimport) wint_t __cdecl fputwc(__wchar_t _Ch, FILE * _File); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _fputwchar(__wchar_t _Ch); } 
extern "C" { __declspec(dllimport) wint_t __cdecl getwc(FILE * _File); } 
extern "C" { __declspec(dllimport) inline wint_t __cdecl getwchar(); } 
extern "C" { __declspec(dllimport) wint_t __cdecl putwc(__wchar_t _Ch, FILE * _File); } 
extern "C" { __declspec(dllimport) inline wint_t __cdecl putwchar(__wchar_t _Ch); } 
extern "C" { __declspec(dllimport) wint_t __cdecl ungetwc(wint_t _Ch, FILE * _File); } 

extern "C" { __declspec(dllimport) __wchar_t *__cdecl fgetws(__wchar_t * _Dst, int _SizeInWords, FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl fputws(const __wchar_t * _Str, FILE * _File); } 
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _getws_s(__wchar_t * _Str, size_t _SizeInWords); } 
template < size_t _Size > inline wchar_t * __cdecl _getws_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _getws_s ( _String, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _getws_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _getws(__wchar_t * _String); } 
extern "C" { __declspec(dllimport) int __cdecl _putws(const __wchar_t * _Str); } 

extern "C" { __declspec(dllimport) int __cdecl fwprintf(FILE * _File, const __wchar_t * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl fwprintf_s(FILE * _File, const __wchar_t * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl wprintf(const __wchar_t * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl wprintf_s(const __wchar_t * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl _scwprintf(const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl vfwprintf(FILE * _File, const __wchar_t * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl vfwprintf_s(FILE * _File, const __wchar_t * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl vwprintf(const __wchar_t * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl vwprintf_s(const __wchar_t * _Format, va_list _ArgList); } 



extern "C" { __declspec(dllimport) int __cdecl swprintf_s(__wchar_t * _Dst, size_t _SizeInWords, const __wchar_t * _Format, ...); } 

/* Removed pragma: __pragma( warning(push)) */__pragma(warning(disable: 4793) )/* Removed pragma: __pragma( warning(disable: 4793)) */template < size_t _Size > inline int __cdecl swprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return vswprintf_s ( _Dest, _Size, _Format, _ArgList ); }/* Removed pragma: __pragma( warning(pop)) */

extern "C" { __declspec(dllimport) int __cdecl vswprintf_s(__wchar_t * _Dst, size_t _SizeInWords, const __wchar_t * _Format, va_list _ArgList); } 

template < size_t _Size > inline int __cdecl vswprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, va_list _Args ) throw ( ) { return vswprintf_s ( _Dest, _Size, _Format, _Args ); }

extern "C" { __declspec(dllimport) int __cdecl _swprintf_c(__wchar_t * _DstBuf, size_t _SizeInWords, const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_c(__wchar_t * _DstBuf, size_t _SizeInWords, const __wchar_t * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _snwprintf_s(__wchar_t * _DstBuf, size_t _SizeInWords, size_t _MaxCount, const __wchar_t * _Format, ...); } 
/* Removed pragma: __pragma( warning(push)) */__pragma(warning(disable: 4793) )/* Removed pragma: __pragma( warning(disable: 4793)) */template < size_t _Size > inline int __cdecl _snwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _ArgList ); }/* Removed pragma: __pragma( warning(pop)) */
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_s(__wchar_t * _DstBuf, size_t _SizeInWords, size_t _MaxCount, const __wchar_t * _Format, va_list _ArgList); } 
template < size_t _Size > inline int __cdecl _vsnwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, va_list _Args ) throw ( ) { return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _Args ); }
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4793) /* Removed pragma: #pragma warning(disable:4793)*/
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _snwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf(__wchar_t * _Dest, size_t _Count, const __wchar_t * _Format, ...); } extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNIN" "GS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf(__wchar_t * _Dest, size_t _Count, const __wchar_t * _Format, va_list _Args); } 
/* Removed pragma: #pragma warning(pop)*/

extern "C" { __declspec(dllimport) int __cdecl _fwprintf_p(FILE * _File, const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _wprintf_p(const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_p(FILE * _File, const __wchar_t * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_p(const __wchar_t * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _swprintf_p(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_p(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_p(const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_p(const __wchar_t * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _wprintf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _wprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _wprintf_s_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_s_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _fwprintf_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_p_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_s_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_p_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_s_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _swprintf_c_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _swprintf_p_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _swprintf_s_l(__wchar_t * _DstBuf, size_t _DstSize, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_c_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_p_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_s_l(__wchar_t * _DstBuf, size_t _DstSize, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _scwprintf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _snwprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNI" "NGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_s_l(__wchar_t * _DstBuf, size_t _DstSize, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARN" "INGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_s_l(__wchar_t * _DstBuf, size_t _DstSize, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 542
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4141 4996 4793) /* Removed pragma: #pragma warning(disable:4141 4996 4793)*/
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _swprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf(__wchar_t * _Dest, const __wchar_t * _Format, ...); } extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using vswprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf(__wchar_t * _Dest, const __wchar_t * _Format, va_list _Args); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using __swprintf_l_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNI" "NGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l(__wchar_t * _Dest, const __wchar_t * _Format, _locale_t _Plocinfo, ...); } extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _vswprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNI" "NGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l(__wchar_t * _Dest, const __wchar_t * _Format, _locale_t _Plocinfo, va_list _Args); } 
/* Removed pragma: #pragma warning(pop)*/
#line 34 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"
/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4793 4412) /* Removed pragma: #pragma warning( disable : 4793 4412 )*/
extern "C" { static __inline int swprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, ...) 
{ 
va_list _Arglist; 
int _Ret; 
(_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Format))) + (((sizeof (_Format) + sizeof(int)) - 1) & ~(sizeof(int) - 1))); 
_Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist); 
(_Arglist = (va_list)0); 
return _Ret; 
} } 
/* Removed pragma: #pragma warning( pop )*/

/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4412) /* Removed pragma: #pragma warning( disable : 4412 )*/
extern "C" { static __inline int __cdecl vswprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, va_list _Ap) 
{ 
return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap); 
} } 
/* Removed pragma: #pragma warning( pop )*/




/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4793 4412) /* Removed pragma: #pragma warning( disable : 4793 4412 )*/
extern "C" { static __inline int _swprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
{ 
va_list _Arglist; 
int _Ret; 
(_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Plocinfo))) + (((sizeof (_Plocinfo) + sizeof(int)) - 1) & ~(sizeof(int) - 1))); 
_Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist); 
(_Arglist = (va_list)0); 
return _Ret; 
} } 
/* Removed pragma: #pragma warning( pop )*/

/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4412) /* Removed pragma: #pragma warning( disable : 4412 )*/
extern "C" { static __inline int __cdecl _vswprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
{ 
return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap); 
} } 
/* Removed pragma: #pragma warning( pop )*/


/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4996) /* Removed pragma: #pragma warning( disable : 4996 )*/

/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4793 4141) /* Removed pragma: #pragma warning( disable : 4793 4141 )*/
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using swprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __inline int swprintf(__wchar_t *_String, const __wchar_t *_Format, ...) 
{ 
va_list _Arglist; 
(_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Format))) + (((sizeof (_Format) + sizeof(int)) - 1) & ~(sizeof(int) - 1))); 
int _Ret = _vswprintf(_String, _Format, _Arglist); 
(_Arglist = (va_list)0); 
return _Ret; 
} 
/* Removed pragma: #pragma warning( pop )*/

/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4141) /* Removed pragma: #pragma warning( disable : 4141 )*/
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using vswprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __inline int __cdecl vswprintf(__wchar_t *_String, const __wchar_t *_Format, va_list _Ap) 
{ 
return _vswprintf(_String, _Format, _Ap); 
} 
/* Removed pragma: #pragma warning( pop )*/

/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4793 4141) /* Removed pragma: #pragma warning( disable : 4793 4141 )*/
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _swprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNIN" "GS. See online help for details.")) __inline int _swprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
{ 
va_list _Arglist; 
(_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Plocinfo))) + (((sizeof (_Plocinfo) + sizeof(int)) - 1) & ~(sizeof(int) - 1))); 
int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist); 
(_Arglist = (va_list)0); 
return _Ret; 
} 
/* Removed pragma: #pragma warning( pop )*/

/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4141) /* Removed pragma: #pragma warning( disable : 4141 )*/
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _vswprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNI" "NGS. See online help for details.")) __inline int __cdecl _vswprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
{ 
return __vswprintf_l(_String, _Format, _Plocinfo, _Ap); 
} 
/* Removed pragma: #pragma warning( pop )*/

/* Removed pragma: #pragma warning( pop )*/
#line 566 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wtempnam(const __wchar_t * _Directory, const __wchar_t * _FilePrefix); } 
#line 572
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf(const __wchar_t * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using fwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int __cdecl fwscanf(FILE * _File, const __wchar_t * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _fwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) int __cdecl _fwscanf_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 6530) /* Removed pragma: #pragma warning(disable:6530)*/

extern "C" { __declspec(dllimport) int __cdecl fwscanf_s(FILE * _File, const __wchar_t * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl _fwscanf_s_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using swscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int __cdecl swscanf(const __wchar_t * _Src, const __wchar_t * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _swscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) int __cdecl _swscanf_l(const __wchar_t * _Src, const __wchar_t * _Format, _locale_t _Locale, ...); } 

extern "C" { __declspec(dllimport) int __cdecl swscanf_s(const __wchar_t * _Src, const __wchar_t * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl _swscanf_s_l(const __wchar_t * _Src, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _snwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf(const __wchar_t * _Src, size_t _MaxCount, const __wchar_t * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _snwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNIN" "GS. See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf_l(const __wchar_t * _Src, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_s(const __wchar_t * _Src, size_t _MaxCount, const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_s_l(const __wchar_t * _Src, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using wscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. S" "ee online help for details.")) __declspec(dllimport) int __cdecl wscanf(const __wchar_t * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) int __cdecl _wscanf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 

extern "C" { __declspec(dllimport) int __cdecl wscanf_s(const __wchar_t * _Format, ...); } 

extern "C" { __declspec(dllimport) int __cdecl _wscanf_s_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
/* Removed pragma: #pragma warning(pop)*/

extern "C" { __declspec(dllimport) FILE *__cdecl _wfdopen(int _FileHandle, const __wchar_t * _Mode); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wfopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) FILE *__cdecl _wfopen(const __wchar_t * _Filename, const __wchar_t * _Mode); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wfopen_s(FILE ** _File, const __wchar_t * _Filename, const __wchar_t * _Mode); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wfreopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) FILE *__cdecl _wfreopen(const __wchar_t * _Filename, const __wchar_t * _Mode, FILE * _OldFile); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wfreopen_s(FILE ** _File, const __wchar_t * _Filename, const __wchar_t * _Mode, FILE * _OldFile); } 
#line 610
extern "C" { __declspec(dllimport) FILE *__cdecl _wpopen(const __wchar_t * _Command, const __wchar_t * _Mode); } 
extern "C" { __declspec(dllimport) int __cdecl _wremove(const __wchar_t * _Filename); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wtmpnam_s(__wchar_t * _DstBuf, size_t _SizeInWords); } 
template < size_t _Size > inline errno_t __cdecl _wtmpnam_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wtmpnam_s ( _Buffer, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wtmpnam_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wtmpnam(__wchar_t * _Buffer); } 

extern "C" { __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(FILE * _File); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _fputwc_nolock(__wchar_t _Ch, FILE * _File); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(wint_t _Ch, FILE * _File); } 
#line 626
extern "C" { inline wint_t __cdecl getwchar() 
{ return (fgetwc((&(__iob_func()[0])))); } } 
extern "C" { inline wint_t __cdecl putwchar(__wchar_t _C) 
{ return (fputwc(_C, (&(__iob_func()[1])))); } } 
#line 675
extern "C" { __declspec(dllimport) void __cdecl _lock_file(FILE * _File); } 
extern "C" { __declspec(dllimport) void __cdecl _unlock_file(FILE * _File); } 

extern "C" { __declspec(dllimport) int __cdecl _fclose_nolock(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl _fflush_nolock(FILE * _File); } 
extern "C" { __declspec(dllimport) size_t __cdecl _fread_nolock(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File); } 
extern "C" { __declspec(dllimport) size_t __cdecl _fread_nolock_s(void * _DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl _fseek_nolock(FILE * _File, long _Offset, int _Origin); } 
extern "C" { __declspec(dllimport) long __cdecl _ftell_nolock(FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl _fseeki64_nolock(FILE * _File, __int64 _Offset, int _Origin); } 
extern "C" { __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(FILE * _File); } 
extern "C" { __declspec(dllimport) size_t __cdecl _fwrite_nolock(const void * _DstBuf, size_t _Size, size_t _Count, FILE * _File); } 
extern "C" { __declspec(dllimport) int __cdecl _ungetc_nolock(int _Ch, FILE * _File); } 
#line 714
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _tempnam. See online help for details.")) __declspec(dllimport) char *__cdecl tempnam(const char * _Directory, const char * _FilePrefix); } 
#line 720
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fcloseall. See online help for details.")) __declspec(dllimport) int __cdecl fcloseall(); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fdopen. See online help for details.")) __declspec(dllimport) FILE *__cdecl fdopen(int _FileHandle, const char * _Format); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fgetchar. See online help for details.")) __declspec(dllimport) int __cdecl fgetchar(); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fileno. See online help for details.")) __declspec(dllimport) int __cdecl fileno(FILE * _File); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _flushall. See online help for details.")) __declspec(dllimport) int __cdecl flushall(); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fputchar. See online help for details.")) __declspec(dllimport) int __cdecl fputchar(int _Ch); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _getw. See online help for details.")) __declspec(dllimport) int __cdecl getw(FILE * _File); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _putw. See online help for details.")) __declspec(dllimport) int __cdecl putw(int _Ch, FILE * _File); } 
extern "C" { __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _rmtmp. See online help for details.")) __declspec(dllimport) int __cdecl rmtmp(); } 
#line 736
#pragma pack ( pop )
#line 34 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\cstdio"
typedef FILE _iobuf; 


namespace std { 
using ::_iobuf;

using ::fpos_t;using ::FILE;
using ::clearerr;using ::fclose;using ::feof;
using ::ferror;using ::fflush;using ::fgetc;
using ::fgetpos;using ::fgets;using ::fopen;
using ::fprintf;using ::fputc;using ::fputs;
using ::fread;using ::freopen;using ::fscanf;
using ::fseek;using ::fsetpos;using ::ftell;
using ::fwrite;using ::getc;using ::getchar;
using ::gets;using ::perror;
using ::putc;using ::putchar;
using ::printf;using ::puts;using ::remove;
using ::rename;using ::rewind;using ::scanf;
using ::setbuf;using ::setvbuf;using ::sprintf;
using ::sscanf;using ::tmpfile;using ::tmpnam;
using ::ungetc;using ::vfprintf;using ::vprintf;
using ::vsprintf;
}
#line 18 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\cstdlib"
namespace std { 
using ::div_t;using ::ldiv_t;

using ::abort;using ::abs;using ::atexit;
using ::atof;using ::atoi;using ::atol;
using ::bsearch;using ::calloc;using ::div;
using ::exit;using ::free;using ::getenv;
using ::labs;using ::ldiv;using ::malloc;
using ::mblen;using ::mbstowcs;using ::mbtowc;
using ::qsort;using ::rand;using ::realloc;
using ::srand;using ::strtod;using ::strtol;
using ::strtoul;using ::system;
#if !defined(CppTest_Stub_system_system) && defined(CPPTEST_USER_STUB_system)
using ::CppTest_Stub_system_system;
#endif
#if !defined(CppTest_Safe_Stub_system_system) && defined(CPPTEST_SAFE_STUB_system)
using ::CppTest_Safe_Stub_system_system;
#endif
#if !defined(CppTest_Auto_Stub_system_system) && defined(CPPTEST_AUTO_STUB_system)
using ::CppTest_Auto_Stub_system_system;
#endif


#line 30
using ::wcstombs;using ::wctomb;

using ::lldiv_t;

using ::llabs;using ::lldiv;
}
#line 17 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\cstring"
namespace std { 
using ::memchr;using ::memcmp;

using ::memcpy;using ::memmove;using ::memset;
using ::strcat;using ::strchr;using ::strcmp;
using ::strcoll;using ::strcpy;using ::strcspn;
using ::strerror;using ::strlen;using ::strncat;
using ::strncmp;using ::strncpy;using ::strpbrk;
using ::strrchr;using ::strspn;using ::strstr;
using ::strtok;using ::strxfrm;
}
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\new"
/* Removed pragma: #pragma warning(push,3)*/
#line 8
#pragma pack ( push, 8 )
#line 23
namespace std { 
#line 31
typedef void (__cdecl *new_handler)(void); 




struct nothrow_t { 

}; 

extern const nothrow_t nothrow; 



__declspec(dllimport) new_handler __cdecl set_new_handler(new_handler) throw(); 

}


void __cdecl operator delete(void *) throw(); 
/* Removed pragma: #pragma warning (suppress: 4985)*/
void *__cdecl operator new(size_t _Size); 



inline void *__cdecl operator new(size_t, void *_Where) throw() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(1) 
return (_Where); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

inline void __cdecl operator delete(void *, void *) throw() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




inline void *__cdecl operator new[](size_t, void *_Where) throw() 
{ 
return (_Where); 
} 

inline void __cdecl operator delete[](void *, void *) throw() 
{ 
} 


void __cdecl operator delete[](void *) throw(); 

void *__cdecl operator new[](size_t _Size); 




void *__cdecl operator new(size_t _Size, const std::nothrow_t &) throw(); 


void *__cdecl operator new[](size_t _Size, const std::nothrow_t &) throw(); 


void __cdecl operator delete(void *, const std::nothrow_t &) throw(); 


void __cdecl operator delete[](void *, const std::nothrow_t &) throw(); 
#line 99
using std::new_handler;



/* Removed pragma: #pragma warning(pop)*/
#pragma pack ( pop )
#line 25 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
#pragma pack ( push, 8 )
#line 83
extern "C" { typedef unsigned long _fsize_t; }
#line 89
extern "C" { struct _wfinddata32_t { 
unsigned attrib; 
__time32_t time_create; 
__time32_t time_access; 
__time32_t time_write; 
_fsize_t size; 
__wchar_t name[260]; 
}; }

extern "C" { struct _wfinddata32i64_t { 
unsigned attrib; 
__time32_t time_create; 
__time32_t time_access; 
__time32_t time_write; 
__int64 size; 
__wchar_t name[260]; 
}; }

extern "C" { struct _wfinddata64i32_t { 
unsigned attrib; 
__time64_t time_create; 
__time64_t time_access; 
__time64_t time_write; 
_fsize_t size; 
__wchar_t name[260]; 
}; }

extern "C" { struct _wfinddata64_t { 
unsigned attrib; 
__time64_t time_create; 
__time64_t time_access; 
__time64_t time_write; 
__int64 size; 
__wchar_t name[260]; 
}; }
#line 182
extern "C" { __declspec(dllimport) const unsigned short *__cdecl __pctype_func(); } 

extern "C" __declspec(dllimport) const unsigned short *_pctype; 
#line 195
extern "C" __declspec(dllimport) const unsigned short _wctype[]; 


extern "C" { __declspec(dllimport) const wctype_t *__cdecl __pwctype_func(); } 

extern "C" __declspec(dllimport) const wctype_t *_pwctype; 
#line 230
extern "C" { __declspec(dllimport) int __cdecl iswalpha(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswalpha_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswupper(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswupper_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswlower(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswlower_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswdigit(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswdigit_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswxdigit(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswxdigit_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswspace(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswspace_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswpunct(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswpunct_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswalnum(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswalnum_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswprint(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswprint_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswgraph(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswgraph_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswcntrl(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswcntrl_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswascii(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl isleadbyte(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _isleadbyte_l(int _C, _locale_t _Locale); } 

extern "C" { __declspec(dllimport) wint_t __cdecl towupper(wint_t _C); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _towupper_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) wint_t __cdecl towlower(wint_t _C); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _towlower_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iswctype(wint_t _C, wctype_t _Type); } 
extern "C" { __declspec(dllimport) int __cdecl _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale); } 

extern "C" { __declspec(dllimport) int __cdecl __iswcsymf(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswcsymf_l(wint_t _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl __iswcsym(wint_t _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iswcsym_l(wint_t _C, _locale_t _Locale); } 

extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instea" "d. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(wint_t _C, wctype_t _Type); } 
#line 286
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetcwd(__wchar_t * _DstBuf, int _SizeInWords); } 
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetdcwd(int _Drive, __wchar_t * _DstBuf, int _SizeInWords); } 
extern "C" { __wchar_t *__cdecl _wgetdcwd_nolock(int _Drive, __wchar_t * _DstBuf, int _SizeInWords); } 
#line 296
extern "C" { __declspec(dllimport) int __cdecl _wchdir(const __wchar_t * _Path); } 
extern "C" { __declspec(dllimport) int __cdecl _wmkdir(const __wchar_t * _Path); } 
extern "C" { __declspec(dllimport) int __cdecl _wrmdir(const __wchar_t * _Path); } 
#line 305
extern "C" { __declspec(dllimport) int __cdecl _waccess(const __wchar_t * _Filename, int _AccessMode); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _waccess_s(const __wchar_t * _Filename, int _AccessMode); } 
extern "C" { __declspec(dllimport) int __cdecl _wchmod(const __wchar_t * _Filename, int _Mode); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int __cdecl _wcreat(const __wchar_t * _Filename, int _PermissionMode); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst32(const __wchar_t * _Filename, _wfinddata32_t * _FindData); } 
extern "C" { __declspec(dllimport) int __cdecl _wfindnext32(intptr_t _FindHandle, _wfinddata32_t * _FindData); } 
extern "C" { __declspec(dllimport) int __cdecl _wunlink(const __wchar_t * _Filename); } 
extern "C" { __declspec(dllimport) int __cdecl _wrename(const __wchar_t * _OldFilename, const __wchar_t * _NewFilename); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wmktemp_s(__wchar_t * _TemplateName, size_t _SizeInWords); } 
template < size_t _Size > inline errno_t __cdecl _wmktemp_s ( wchar_t ( & _TemplateName ) [ _Size ] ) throw ( ) { return _wmktemp_s ( _TemplateName, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wmktemp_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wmktemp(__wchar_t * _TemplateName); } 

extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(const __wchar_t * _Filename, _wfinddata32i64_t * _FindData); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(const __wchar_t * _Filename, _wfinddata64i32_t * _FindData); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst64(const __wchar_t * _Filename, _wfinddata64_t * _FindData); } 
extern "C" { __declspec(dllimport) int __cdecl _wfindnext32i64(intptr_t _FindHandle, _wfinddata32i64_t * _FindData); } 
extern "C" { __declspec(dllimport) int __cdecl _wfindnext64i32(intptr_t _FindHandle, _wfinddata64i32_t * _FindData); } 
extern "C" { __declspec(dllimport) int __cdecl _wfindnext64(intptr_t _FindHandle, _wfinddata64_t * _FindData); } 

extern "C" { __declspec(dllimport) errno_t __cdecl _wsopen_s(int * _FileHandle, const __wchar_t * _Filename, int _OpenFlag, int _ShareFlag, int _PermissionFlag); } 
#line 334
__declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int __cdecl _wopen(const __wchar_t * _Filename, int _OpenFlag, int _PermissionMode = 0); 
__declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int __cdecl _wsopen(const __wchar_t * _Filename, int _OpenFlag, int _ShareFlag, int _PermissionMode = 0); 
#line 346
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wsetlocale(int _Category, const __wchar_t * _Locale); } 
#line 355
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecl(const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecle(const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexeclp(const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexeclpe(const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecv(const __wchar_t * _Filename, const __wchar_t *const * _ArgList); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecve(const __wchar_t * _Filename, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); } 

extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecvp(const __wchar_t * _Filename, const __wchar_t *const * _ArgList); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecvpe(const __wchar_t * _Filename, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); } 

extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnl(int _Mode, const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnle(int _Mode, const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnlp(int _Mode, const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnlpe(int _Mode, const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnv(int _Mode, const __wchar_t * _Filename, const __wchar_t *const * _ArgList); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnve(int _Mode, const __wchar_t * _Filename, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); } 

extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnvp(int _Mode, const __wchar_t * _Filename, const __wchar_t *const * _ArgList); } 
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnvpe(int _Mode, const __wchar_t * _Filename, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); } 
#line 453
extern "C" { typedef unsigned short _ino_t; }


extern "C" { typedef unsigned short ino_t; }
#line 462
extern "C" { typedef unsigned _dev_t; }


extern "C" { typedef unsigned dev_t; }
#line 471
extern "C" { typedef long _off_t; }


extern "C" { typedef long off_t; }
#line 481
extern "C" { struct _stat32 { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
_off_t st_size; 
__time32_t st_atime; 
__time32_t st_mtime; 
__time32_t st_ctime; 
}; }



extern "C" { struct stat { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
_off_t st_size; 
time_t st_atime; 
time_t st_mtime; 
time_t st_ctime; 
}; }



extern "C" { struct _stat32i64 { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
__int64 st_size; 
__time32_t st_atime; 
__time32_t st_mtime; 
__time32_t st_ctime; 
}; }

extern "C" { struct _stat64i32 { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
_off_t st_size; 
__time64_t st_atime; 
__time64_t st_mtime; 
__time64_t st_ctime; 
}; }

extern "C" { struct _stat64 { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
__int64 st_size; 
__time64_t st_atime; 
__time64_t st_mtime; 
__time64_t st_ctime; 
}; }
#line 587
extern "C" { __declspec(dllimport) int __cdecl _wstat32(const __wchar_t * _Name, _stat32 * _Stat); } 

extern "C" { __declspec(dllimport) int __cdecl _wstat32i64(const __wchar_t * _Name, _stat32i64 * _Stat); } 
extern "C" { __declspec(dllimport) int __cdecl _wstat64i32(const __wchar_t * _Name, _stat64i32 * _Stat); } 
extern "C" { __declspec(dllimport) int __cdecl _wstat64(const __wchar_t * _Name, _stat64 * _Stat); } 
#line 607
extern "C" { __declspec(dllimport) errno_t __cdecl _cgetws_s(__wchar_t * _Buffer, size_t _SizeInWords, size_t * _SizeRead); } 
template < size_t _Size > inline errno_t __cdecl _cgetws_s ( wchar_t ( & _Buffer ) [ _Size ], size_t * _SizeRead ) throw ( ) { return _cgetws_s ( _Buffer, _Size, _SizeRead ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _cgetws_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _cgetws(__wchar_t * _Buffer); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _getwch(); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _getwche(); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _putwch(__wchar_t _WCh); } 
extern "C" { __declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _WCh); } 
extern "C" { __declspec(dllimport) int __cdecl _cputws(const __wchar_t * _String); } 
extern "C" { __declspec(dllimport) int __cdecl _cwprintf(const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_s(const __wchar_t * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _cwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS." " See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf(const __wchar_t * _Format, ...); } 
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _cwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _cwscanf_s(const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _cwscanf_s_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf(const __wchar_t * _Format, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_s(const __wchar_t * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _cwprintf_p(const __wchar_t * _Format, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_p(const __wchar_t * _Format, va_list _ArgList); } 

extern "C" { __declspec(dllimport) int __cdecl _cwprintf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_s_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_s_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 

extern "C" { wint_t __cdecl _putwch_nolock(__wchar_t _WCh); } 
extern "C" { wint_t __cdecl _getwch_nolock(); } 
extern "C" { wint_t __cdecl _getwche_nolock(); } 
extern "C" { wint_t __cdecl _ungetwch_nolock(wint_t _WCh); } 
#line 1110
extern "C" { struct tm { 
int tm_sec; 
int tm_min; 
int tm_hour; 
int tm_mday; 
int tm_mon; 
int tm_year; 
int tm_wday; 
int tm_yday; 
int tm_isdst; 
}; }
#line 1128
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wasctime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wasctime(const tm * _Tm); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wasctime_s(__wchar_t * _Buf, size_t _SizeInWords, const tm * _Tm); } 
template < size_t _Size > inline errno_t __cdecl _wasctime_s ( wchar_t ( & _Buffer ) [ _Size ], const struct tm * _Time ) throw ( ) { return _wasctime_s ( _Buffer, _Size, _Time ); }

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wctime32_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wctime32(const __time32_t * _Time); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wctime32_s(__wchar_t * _Buf, size_t _SizeInWords, const __time32_t * _Time); } 
template < size_t _Size > inline errno_t __cdecl _wctime32_s ( wchar_t ( & _Buffer ) [ _Size ], const __time32_t * _Time ) throw ( ) { return _wctime32_s ( _Buffer, _Size, _Time ); }

extern "C" { __declspec(dllimport) size_t __cdecl wcsftime(__wchar_t * _Buf, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm); } 
extern "C" { __declspec(dllimport) size_t __cdecl _wcsftime_l(__wchar_t * _Buf, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm, _locale_t _Locale); } 

extern "C" { __declspec(dllimport) errno_t __cdecl _wstrdate_s(__wchar_t * _Buf, size_t _SizeInWords); } 
template < size_t _Size > inline errno_t __cdecl _wstrdate_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrdate_s ( _Buffer, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wstrdate_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wstrdate(__wchar_t * _Buffer); } 

extern "C" { __declspec(dllimport) errno_t __cdecl _wstrtime_s(__wchar_t * _Buf, size_t _SizeInWords); } 
template < size_t _Size > inline errno_t __cdecl _wstrtime_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrtime_s ( _Buffer, _Size ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wstrtime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wstrtime(__wchar_t * _Buffer); } 

extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _wctime64_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) __wchar_t *__cdecl _wctime64(const __time64_t * _Time); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _wctime64_s(__wchar_t * _Buf, size_t _SizeInWords, const __time64_t * _Time); } 
template < size_t _Size > inline errno_t __cdecl _wctime64_s ( wchar_t ( & _Buffer ) [ _Size ], const __time64_t * _Time ) throw ( ) { return _wctime64_s ( _Buffer, _Size, _Time ); }
#line 27 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\wtime.inl"
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4996) /* Removed pragma: #pragma warning(disable:4996)*/
#line 44
extern "C" { static __inline __wchar_t *__cdecl _wctime(const time_t *_Time) 
{ 
/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4996) /* Removed pragma: #pragma warning( disable : 4996 )*/
return _wctime64(_Time); 
/* Removed pragma: #pragma warning( pop )*/
} } 

extern "C" { static __inline errno_t __cdecl _wctime_s(__wchar_t *_Buffer, size_t _SizeInWords, const time_t *_Time) 
{ 
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
} } 


/* Removed pragma: #pragma warning(pop)*/
#line 1159 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { typedef int mbstate_t; }
extern "C" { typedef __wchar_t _Wint_t; }

extern "C" { __declspec(dllimport) wint_t __cdecl btowc(int); } 
extern "C" { __declspec(dllimport) size_t __cdecl mbrlen(const char * _Ch, size_t _SizeInBytes, mbstate_t * _State); } 

extern "C" { __declspec(dllimport) size_t __cdecl mbrtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SizeInBytes, mbstate_t * _State); } 

extern "C" { __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(size_t * _Retval, __wchar_t * _Dst, size_t _Size, const char ** _PSrc, size_t _N, mbstate_t * _State); } 
template < size_t _Size > inline errno_t __cdecl mbsrtowcs_s ( size_t * _Retval, wchar_t ( & _Dest ) [ _Size ], const char * * _PSource, size_t _Count, mbstate_t * _State ) throw ( ) { return mbsrtowcs_s ( _Retval, _Dest, _Size, _PSource, _Count, _State ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using mbsrtowcs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs(__wchar_t * _Dest, const char ** _PSrc, size_t _Count, mbstate_t * _State); } 

extern "C" { __declspec(dllimport) errno_t __cdecl wcrtomb_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, __wchar_t _Ch, mbstate_t * _State); } 

template < size_t _Size > inline errno_t __cdecl wcrtomb_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t _Source, mbstate_t * _State ) throw ( ) { return wcrtomb_s ( _Retval, _Dest, _Size, _Source, _State ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using wcrtomb_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(char * _Dest, __wchar_t _Source, mbstate_t * _State); } 
extern "C" { __declspec(dllimport) errno_t __cdecl wcsrtombs_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, const __wchar_t ** _Src, size_t _Size, mbstate_t * _State); } 

template < size_t _Size > inline errno_t __cdecl wcsrtombs_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], const wchar_t * * _PSrc, size_t _Count, mbstate_t * _State ) throw ( ) { return wcsrtombs_s ( _Retval, _Dest, _Size, _PSrc, _Count, _State ); }
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using wcsrtombs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS" ". See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(char * _Dest, const __wchar_t ** _PSource, size_t _Count, mbstate_t * _State); } 
extern "C" { __declspec(dllimport) int __cdecl wctob(wint_t _WCh); } 
#line 1187
extern "C" { CPPTEST_IMP_memmove void *__cdecl memmove(void * _Dst, const void * _Src, size_t _Size); } 

extern "C" { void *__cdecl memcpy(void * _Dst, const void * _Src, size_t _Size); } 

extern "C" { __declspec(dllimport) errno_t __cdecl memcpy_s(void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount); } 
extern "C" { CPPTEST_IMP_memmove_s errno_t __cdecl memmove_s(void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount); } 

extern "C" { __inline int __cdecl fwide(FILE *_F, int _M) 
{ (void)_F; return (_M); } } 
extern "C" { __inline int __cdecl mbsinit(const mbstate_t *_P) 
{ return (_P == 0 || *_P == 0); } } 
extern "C" { __inline const __wchar_t *__cdecl wmemchr(const __wchar_t *_S, __wchar_t _C, size_t _N) 
{ for (; 0 < _N; (++_S), (--_N)) 
if (*_S == _C) 
return (_S);     
return (0); } } 
extern "C" { __inline int __cdecl wmemcmp(const __wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
{ for (; 0 < _N; ((++_S1), (++_S2)), (--_N)) 
if (*_S1 != *_S2) 
return ((*_S1 < *_S2) ? -1 : (+1));     
return (0); } } 

extern "C" { __inline __wchar_t *__cdecl wmemcpy(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
{ 
/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4996 6386) /* Removed pragma: #pragma warning( disable : 4996 6386 )*/
return (__wchar_t *)memcpy(_S1, _S2, _N * sizeof(__wchar_t)); 
/* Removed pragma: #pragma warning( pop )*/
} } 

extern "C" { __inline __wchar_t *__cdecl wmemmove(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
{ 
/* Removed pragma: #pragma warning( push )*/
#pragma warning(disable: 4996 6386) /* Removed pragma: #pragma warning( disable : 4996 6386 )*/
#pragma warning(disable: 6387) /* Removed pragma: #pragma warning( disable : 6387)*/

return (__wchar_t *)memmove(_S1, _S2, _N * sizeof(__wchar_t)); 
/* Removed pragma: #pragma warning( pop )*/
} } 


extern "C" { errno_t __cdecl wmemcpy_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); } 
extern "C" { errno_t __cdecl wmemmove_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); } 


extern "C" { __inline __wchar_t *__cdecl wmemset(__wchar_t *_S, __wchar_t _C, size_t _N) 
{ 
__wchar_t *_Su = _S; 
for (; 0 < _N; (++_Su), (--_N)) 
{ 
*_Su = _C; 
}  
return (_S); 
} } 



inline __wchar_t *__cdecl wmemchr(__wchar_t *_S, __wchar_t _C, size_t _N) 
{ return (__wchar_t *)wmemchr((const __wchar_t *)_S, _C, _N); } 
#line 1254
#pragma pack ( pop )
#line 16 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\cwchar"
typedef mbstate_t _Mbstatet; 


namespace std { 
using ::_Mbstatet;

using ::mbstate_t;
using ::tm;using ::wint_t;

using ::btowc;using ::fgetwc;using ::fgetws;using ::fputwc;
using ::fputws;using ::fwide;using ::fwprintf;
using ::fwscanf;using ::getwc;using ::getwchar;
using ::mbrlen;using ::mbrtowc;using ::mbsrtowcs;
using ::mbsinit;using ::putwc;using ::putwchar;
using ::swprintf;using ::swscanf;using ::ungetwc;
using ::vfwprintf;using ::vswprintf;using ::vwprintf;
using ::wcrtomb;using ::wprintf;using ::wscanf;
using ::wcsrtombs;using ::wcstol;using ::wcscat;
using ::wcschr;using ::wcscmp;using ::wcscoll;
using ::wcscpy;using ::wcscspn;using ::wcslen;
using ::wcsncat;using ::wcsncmp;using ::wcsncpy;
using ::wcspbrk;using ::wcsrchr;using ::wcsspn;

using ::wcstod;using ::wcstoul;using ::wcsstr;

using ::wcstok;using ::wcsxfrm;using ::wctob;
using ::wmemchr;using ::wmemcmp;using ::wmemcpy;
using ::wmemmove;using ::wmemset;using ::wcsftime;
}
#line 20 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
#pragma pack ( push, 8 )
#line 42
extern "C" { typedef void *_HFILE; }
#line 69
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOK)(int, char *, int *); }
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOKW)(int, __wchar_t *, int *); }
#line 101
extern "C" { typedef int (__cdecl *_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int); }
#line 162
extern "C" { typedef void (__cdecl *_CRT_DUMP_CLIENT)(void *, size_t); }
#line 170
struct _CrtMemBlockHeader; 
#line 178
extern "C" { typedef 
#line 171
struct _CrtMemState { 

_CrtMemBlockHeader *pBlockHeader; 
size_t lCounts[5]; 
size_t lSizes[5]; 
size_t lHighWaterCount; 
size_t lTotalCount; 
} _CrtMemState; }
#line 368
extern "C" __declspec(dllimport) long _crtAssertBusy; 



extern "C" { __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(); } 
#line 382
extern "C" { __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(_CRT_REPORT_HOOK _PFnNewHook); } 



extern "C" { __declspec(dllimport) int __cdecl _CrtSetReportHook2(int _Mode, _CRT_REPORT_HOOK _PFnNewHook); } 




extern "C" { __declspec(dllimport) int __cdecl _CrtSetReportHookW2(int _Mode, _CRT_REPORT_HOOKW _PFnNewHook); } 
#line 415
extern "C" { __declspec(dllimport) int __cdecl _CrtSetReportMode(int _ReportType, int _ReportMode); } 




extern "C" { __declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(int _ReportType, _HFILE _ReportFile); } 




extern "C" { __declspec(dllimport) int __cdecl _CrtDbgReport(int _ReportType, const char * _Filename, int _Linenumber, const char * _ModuleName, const char * _Format, ...); } 
#line 433
extern "C" { __declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(size_t _NewDebugFillThreshold); } 
#line 440
extern "C" { __declspec(dllimport) int __cdecl _CrtDbgReportW(int _ReportType, const __wchar_t * _Filename, int _LineNumber, const __wchar_t * _ModuleName, const __wchar_t * _Format, ...); } 
#line 617
extern "C" __declspec(dllimport) long _crtBreakAlloc; 


extern "C" { __declspec(dllimport) long __cdecl _CrtSetBreakAlloc(long _BreakAlloc); } 
#line 628
extern "C" { __declspec(dllimport) void *__cdecl _malloc_dbg(size_t _Size, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 635
extern "C" { __declspec(dllimport) void *__cdecl _calloc_dbg(size_t _Count, size_t _Size, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 644
extern "C" { __declspec(dllimport) void *__cdecl _realloc_dbg(void * _Memory, size_t _NewSize, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 653
extern "C" { __declspec(dllimport) void *__cdecl _recalloc_dbg(void * _Memory, size_t _NumOfElements, size_t _SizeOfElements, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 663
extern "C" { __declspec(dllimport) void *__cdecl _expand_dbg(void * _Memory, size_t _NewSize, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 671
extern "C" { CPPTEST_IMP__free_dbg void __cdecl _free_dbg(void * _Memory, int _BlockType); } 




extern "C" { __declspec(dllimport) size_t __cdecl _msize_dbg(void * _Memory, int _BlockType); } 




extern "C" { __declspec(dllimport) size_t __cdecl _aligned_msize_dbg(void * _Memory, size_t _Alignment, size_t _Offset); } 
#line 687
extern "C" { __declspec(dllimport) void *__cdecl _aligned_malloc_dbg(size_t _Size, size_t _Alignment, const char * _Filename, int _LineNumber); } 
#line 695
extern "C" { __declspec(dllimport) void *__cdecl _aligned_realloc_dbg(void * _Memory, size_t _NewSize, size_t _Alignment, const char * _Filename, int _LineNumber); } 
#line 704
extern "C" { __declspec(dllimport) void *__cdecl _aligned_recalloc_dbg(void * _Memory, size_t _NumOfElements, size_t _SizeOfElements, size_t _Alignment, const char * _Filename, int _LineNumber); } 
#line 714
extern "C" { __declspec(dllimport) void *__cdecl _aligned_offset_malloc_dbg(size_t _Size, size_t _Alignment, size_t _Offset, const char * _Filename, int _LineNumber); } 
#line 723
extern "C" { __declspec(dllimport) void *__cdecl _aligned_offset_realloc_dbg(void * _Memory, size_t _NewSize, size_t _Alignment, size_t _Offset, const char * _Filename, int _LineNumber); } 
#line 733
extern "C" { __declspec(dllimport) void *__cdecl _aligned_offset_recalloc_dbg(void * _Memory, size_t _NumOfElements, size_t _SizeOfElements, size_t _Alignment, size_t _Offset, const char * _Filename, int _LineNumber); } 
#line 744
extern "C" { __declspec(dllimport) void __cdecl _aligned_free_dbg(void * _Memory); } 



extern "C" { __declspec(dllimport) char *__cdecl _strdup_dbg(const char * _Str, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 755
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsdup_dbg(const __wchar_t * _Str, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 762
extern "C" { __declspec(dllimport) char *__cdecl _tempnam_dbg(const char * _DirName, const char * _FilePrefix, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 770
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wtempnam_dbg(const __wchar_t * _DirName, const __wchar_t * _FilePrefix, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 778
extern "C" { __declspec(dllimport) char *__cdecl _fullpath_dbg(char * _FullPath, const char * _Path, size_t _SizeInBytes, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 787
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wfullpath_dbg(__wchar_t * _FullPath, const __wchar_t * _Path, size_t _SizeInWords, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 796
extern "C" { __declspec(dllimport) char *__cdecl _getcwd_dbg(char * _DstBuf, int _SizeInBytes, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 804
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetcwd_dbg(__wchar_t * _DstBuf, int _SizeInWords, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 812
extern "C" { __declspec(dllimport) char *__cdecl _getdcwd_dbg(int _Drive, char * _DstBuf, int _SizeInBytes, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 821
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetdcwd_dbg(int _Drive, __wchar_t * _DstBuf, int _SizeInWords, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 830
extern "C" { char *__cdecl _getdcwd_lk_dbg(int _Drive, char * _DstBuf, int _SizeInBytes, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 839
extern "C" { __wchar_t *__cdecl _wgetdcwd_lk_dbg(int _Drive, __wchar_t * _DstBuf, int _SizeInWords, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 848
extern "C" { __declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(char ** _PBuffer, size_t * _PBufferSizeInBytes, const char * _VarName, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 857
extern "C" { __declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(__wchar_t ** _PBuffer, size_t * _PBufferSizeInWords, const __wchar_t * _VarName, int _BlockType, const char * _Filename, int _LineNumber); } 
#line 882
extern "C" { __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(); } 
#line 893
extern "C" { __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(_CRT_ALLOC_HOOK _PfnNewHook); } 
#line 919
extern "C" __declspec(dllimport) int _crtDbgFlag; 


extern "C" { __declspec(dllimport) int __cdecl _CrtCheckMemory(); } 



extern "C" { __declspec(dllimport) int __cdecl _CrtSetDbgFlag(int _NewFlag); } 



extern "C" { __declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(void (__cdecl * _PFn)(void *, void *), void * _Context); } 




extern "C" { __declspec(dllimport) int __cdecl _CrtIsValidPointer(const void * _Ptr, unsigned _Bytes, int _ReadWrite); } 
#line 941
extern "C" { __declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(const void * _HeapPtr); } 



extern "C" { __declspec(dllimport) int __cdecl _CrtIsMemoryBlock(const void * _Memory, unsigned _Bytes, long * _RequestNumber, char ** _Filename, int * _LineNumber); } 
#line 953
extern "C" { __declspec(dllimport) int __cdecl _CrtReportBlockType(const void * _Memory); } 
#line 965
extern "C" { __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(); } 
#line 976
extern "C" { __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(_CRT_DUMP_CLIENT _PFnNewDump); } 
#line 991
extern "C" { __declspec(dllimport) void __cdecl _CrtMemCheckpoint(_CrtMemState * _State); } 



extern "C" { __declspec(dllimport) int __cdecl _CrtMemDifference(_CrtMemState * _State, const _CrtMemState * _OldState, const _CrtMemState * _NewState); } 
#line 1001
extern "C" { __declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(const _CrtMemState * _State); } 



extern "C" { __declspec(dllimport) void __cdecl _CrtMemDumpStatistics(const _CrtMemState * _State); } 



extern "C" { __declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(); } 



extern "C" { __declspec(dllimport) int __cdecl _CrtSetCheckCount(int _CheckCount); } 



extern "C" { __declspec(dllimport) int __cdecl _CrtGetCheckCount(); } 
#line 1077
/* Removed pragma: #pragma warning(suppress: 4985)*/
void *__cdecl operator new[](size_t _Size); 

void *__cdecl operator new(size_t _Size, int, const char *, int); 
#line 1087
/* Removed pragma: #pragma warning(suppress: 4985)*/
void *__cdecl operator new[](size_t _Size, int, const char *, int); 
#line 1095
void __cdecl operator delete[](void *); 

inline void __cdecl operator delete(void *_P, int, const char *, int) 
{ ::operator delete(_P); } 

inline void __cdecl operator delete[](void *_P, int, const char *, int) 
{ ::operator delete[](_P); } 
#line 14 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\iosfwd"
/* Removed pragma: #pragma warning(push,3)*/
#line 1131 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
#pragma pack ( pop )
#line 13 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\iosfwd"
#pragma pack ( push, 8 )


namespace std { 


typedef _Longlong streamoff; 
typedef _Longlong streamsize; 
#line 28
__declspec(dllimport) extern const streamoff _BADOFF; 



template < class _Statetype >
 class fpos{ 

typedef fpos < _Statetype > _Myt; 


public:  fpos ( streamoff _Off = 0 )
  : _Myoff ( _Off ), _Fpos ( 0 ), _Mystate ( _Stz )
  {
  }

 fpos ( _Statetype _State, fpos_t _Fileposition )
  : _Myoff ( 0 ), _Fpos ( _Fileposition ), _Mystate ( _State )
  {
  }

_Statetype state ( ) const
  {
  return ( _Mystate );
  }

void state ( _Statetype _State )
  {
  _Mystate = _State;
  }

fpos_t seekpos ( ) const
  {
  return ( _Fpos );
  }

 operator streamoff ( ) const
  {
  return ( ( streamoff ) ( _Myoff + ( ( long ) ( _Fpos ) ) ) );
  }

streamoff operator - ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this - ( streamoff ) _Right );
  }

_Myt & operator += ( streamoff _Off )
  {
  _Myoff += _Off;
  return ( * this );
  }

_Myt & operator -= ( streamoff _Off )
  {
  _Myoff -= _Off;
  return ( * this );
  }

_Myt operator + ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

_Myt operator - ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

bool operator == ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this == ( streamoff ) _Right );
  }

bool operator == ( streamoff _Right ) const
  {
  return ( ( streamoff ) * this == _Right );
  }

bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }


private: static const _Statetype _Stz; 
streamoff _Myoff; 
fpos_t _Fpos; 
_Statetype _Mystate; 
};


template < class _Statetype >
          const _Statetype fpos < _Statetype > :: _Stz = _Statetype ( );
#line 128
typedef fpos< int>  streampos; 

typedef streampos wstreampos; 


template < class _Elem,
 class _Int_type >
 struct _Char_traits{ 

typedef _Elem char_type; 
typedef _Int_type int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef _Mbstatet state_type; 

static int __cdecl compare (
                     const _Elem * _First1,
                     const _Elem * _First2, size_t _Count )


  {
  for (; 0 < _Count; -- _Count, ++ _First1, ++ _First2 )
   if ( ! eq ( * _First1, * _First2 ) )
    return ( lt ( * _First1, * _First2 ) ? - 1 : + 1 );
  return ( 0 );
  }

static size_t __cdecl length ( const _Elem * _First )
  {
  size_t _Count;
  for ( _Count = 0; ! eq ( * _First, _Elem ( ) ); ++ _First )
   ++ _Count;
  return ( _Count );
  }

static _Elem * __cdecl copy (
                    _Elem * _First1,
                     const _Elem * _First2, size_t _Count )


  {
  _Elem * _Next = _First1;
  for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
   assign ( * _Next, * _First2 );
  return ( _First1 );
  }

static _Elem * __cdecl _Copy_s (
                        _Elem * _First1, size_t _Dest_size,
                     const _Elem * _First2, size_t _Count )


  {
  { if ( ! ( _Dest_size >= _Count ) ) { ( void ) ( ( ! ! ( ( "_Dest_size >= _Count" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x6f\x73\x66\x77\x64", 175, 0, L"\x22\x5f\x44\x65\x73\x74\x5f\x73\x69\x7a\x65\x20\x3e\x3d\x20\x5f\x43\x6f\x75\x6e\x74\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x5f\x44\x65\x73\x74\x5f\x73\x69\x7a\x65\x20\x3e\x3d\x20\x5f\x43\x6f\x75\x6e\x74", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x6f\x73\x66\x77\x64", 175, 0 ); return ( 0 ); } };
  return ( copy ( _First1, _First2, _Count ) );
  }

static const _Elem * __cdecl find (
                     const _Elem * _First,
  size_t _Count, const _Elem & _Ch )


  {
  for (; 0 < _Count; -- _Count, ++ _First )
   if ( eq ( * _First, _Ch ) )
    return ( _First );
  return ( 0 );
  }

static _Elem * __cdecl move (
                    _Elem * _First1,
                     const _Elem * _First2, size_t _Count )


  {
  _Elem * _Next = _First1;
  if ( _First2 < _Next && _Next < _First2 + _Count )
   for ( _Next += _Count, _First2 += _Count; 0 < _Count; -- _Count )
    assign ( * -- _Next, * -- _First2 );
  else
   for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
    assign ( * _Next, * _First2 );
  return ( _First1 );
  }

static _Elem * __cdecl assign (
                    _Elem * _First,
  size_t _Count, _Elem _Ch )


  {
  _Elem * _Next = _First;
  for (; 0 < _Count; -- _Count, ++ _Next )
   assign ( * _Next, _Ch );
  return ( _First );
  }

static void __cdecl assign ( _Elem & _Left, const _Elem & _Right )
  {
  _Left = _Right;
  }

static bool __cdecl eq ( const _Elem & _Left, const _Elem & _Right )
  {
  return ( _Left == _Right );
  }

static bool __cdecl lt ( const _Elem & _Left, const _Elem & _Right )
  {
  return ( _Left < _Right );
  }

static _Elem __cdecl to_char_type ( const int_type & _Meta )
  {
  return ( ( _Elem ) _Meta );
  }

static int_type __cdecl to_int_type ( const _Elem & _Ch )
  {
  return ( ( int_type ) _Ch );
  }

static bool __cdecl eq_int_type ( const int_type & _Left,
  const int_type & _Right )

  {
  return ( _Left == _Right );
  }

static int_type __cdecl not_eof ( const int_type & _Meta )
  {
  return ( _Meta != eof ( ) ? ( int_type ) _Meta : ( int_type ) ! eof ( ) );
  }

static int_type __cdecl eof ( )
  {
  return ( ( int_type ) ( - 1 ) );
  }
};


template < class _Elem >
 struct char_traits
  : public _Char_traits < _Elem, long >{ 

};
#line 280
#pragma pack(8)
template<> 
#line 280
struct char_traits< __wchar_t>  { 

typedef __wchar_t _Elem; 
typedef _Elem char_type; 
typedef wint_t int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef _Mbstatet state_type; 

static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 
return (::wmemcmp(_First1, _First2, _Count)); 
} 

static size_t __cdecl length(const _Elem *_First) 
{ 
return (::wcslen(_First)); 
} 

static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 
return ((_Elem *)::wmemcpy(_First1, _First2, _Count)); 
} 

static _Elem *__cdecl _Copy_s(_Elem *
_First1, size_t _Size_in_words, const _Elem *
_First2, size_t _Count) 
{ 
::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count)); 
return _First1; 
} 

static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
_Ch) 
{ 
return ((const _Elem *)::wmemchr(_First, _Ch, _Count)); 
} 

static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 
return ((_Elem *)::wmemmove(_First1, _First2, _Count)); 
} 

static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch) 
{ 
return ((_Elem *)::wmemset(_First, _Ch, _Count)); 
} 

static void __cdecl assign(_Elem &_Left, const _Elem &_Right) 
{ 
_Left = _Right; 
} 

static bool __cdecl eq(const _Elem &_Left, const _Elem &_Right) 
{ 
return (_Left == _Right); 
} 

static bool __cdecl lt(const _Elem &_Left, const _Elem &_Right) 
{ 
return (_Left < _Right); 
} 

static _Elem __cdecl to_char_type(const int_type &_Meta) 
{ 
return (_Meta); 
} 

static int_type __cdecl to_int_type(const _Elem &_Ch) 
{ 
return (_Ch); 
} 

static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
_Right) 
{ 
return (_Left == _Right); 
} 

static int_type __cdecl not_eof(const int_type &_Meta) 
{ 
return ((_Meta != eof()) ? _Meta : (!eof())); 
} 

static int_type __cdecl eof() 
{ 
return ((wint_t)(0xffff)); 
} 
}; 
#pragma pack()


#pragma pack(8)
template<> 
#line 375
struct char_traits< unsigned short>  { 

typedef unsigned short _Elem; 
typedef _Elem char_type; 
typedef wint_t int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef _Mbstatet state_type; 

static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 
return (::wmemcmp((const __wchar_t *)_First1, (const __wchar_t *)_First2, _Count)); 

} 

static size_t __cdecl length(const _Elem *_First) 
{ 
return (::wcslen((const __wchar_t *)_First)); 
} 

static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 
return ((_Elem *)::wmemcpy((__wchar_t *)_First1, (const __wchar_t *)_First2, _Count)); 

} 

static _Elem *__cdecl _Copy_s(_Elem *
_First1, size_t _Size_in_words, const _Elem *
_First2, size_t _Count) 
{ 
::wmemcpy_s(((__wchar_t *)_First1), (_Size_in_words), ((const __wchar_t *)_First2), (_Count)); 
return _First1; 
} 

static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
_Ch) 
{ 
return ((const _Elem *)::wmemchr((const __wchar_t *)_First, _Ch, _Count)); 

} 

static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 
return ((_Elem *)::wmemmove((__wchar_t *)_First1, (const __wchar_t *)_First2, _Count)); 

} 

static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch) 
{ 
return ((_Elem *)::wmemset((__wchar_t *)_First, _Ch, _Count)); 
} 

static void __cdecl assign(_Elem &_Left, const _Elem &_Right) 
{ 
_Left = _Right; 
} 

static bool __cdecl eq(const _Elem &_Left, const _Elem &_Right) 
{ 
return (_Left == _Right); 
} 

static bool __cdecl lt(const _Elem &_Left, const _Elem &_Right) 
{ 
return (_Left < _Right); 
} 

static _Elem __cdecl to_char_type(const int_type &_Meta) 
{ 
return (_Meta); 
} 

static int_type __cdecl to_int_type(const _Elem &_Ch) 
{ 
return (_Ch); 
} 

static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
_Right) 
{ 
return (_Left == _Right); 
} 

static int_type __cdecl not_eof(const int_type &_Meta) 
{ 
return ((_Meta != eof()) ? _Meta : (!eof())); 
} 

static int_type __cdecl eof() 
{ 
return ((wint_t)(0xffff)); 
} 
}; 
#pragma pack()


#pragma pack(8)
template<> 
#line 474
struct char_traits< char>  { 

typedef char _Elem; 
typedef _Elem char_type; 
typedef int int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef _Mbstatet state_type; 

static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 
return (::memcmp(_First1, _First2, _Count)); 
} 

static size_t __cdecl length(const _Elem *_First) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(2) 
return (::strlen(_First)); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(3) 
return ((_Elem *)::memcpy(_First1, _First2, _Count)); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

static _Elem *__cdecl _Copy_s(_Elem *
_First1, size_t _Size_in_bytes, const _Elem *
_First2, size_t _Count) 
{ 
::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count)); 
return _First1; 
} 

static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
_Ch) 
{ 
return ((const _Elem *)::memchr(_First, _Ch, _Count)); 
} 

static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(4) 
return ((_Elem *)::memmove(_First1, _First2, _Count)); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(5) 
return ((_Elem *)::memset(_First, _Ch, _Count)); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

static void __cdecl assign(_Elem &_Left, const _Elem &_Right) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(6) 
_Left = _Right; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

static bool __cdecl eq(const _Elem &_Left, const _Elem &_Right) 
{ 
return (_Left == _Right); 
} 

static bool __cdecl lt(const _Elem &_Left, const _Elem &_Right) 
{ 
return ((unsigned char)_Left < (unsigned char)_Right); 
} 

static _Elem __cdecl to_char_type(const int_type &_Meta) 
{ 
return ((_Elem)_Meta); 
} 

static int_type __cdecl to_int_type(const _Elem &_Ch) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(7) 
return ((unsigned char)_Ch); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
_Right) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(8) 
return (_Left == _Right); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

static int_type __cdecl not_eof(const int_type &_Meta) 
{ 
return ((_Meta != eof()) ? _Meta : (!eof())); 
} 

static int_type __cdecl eof() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(9) 
return ((-1)); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 
}; 
#pragma pack()

template < class _Ty >
 class allocator;
class ios_base; 
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ios;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class istreambuf_iterator;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class ostreambuf_iterator;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_streambuf;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_istream;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ostream;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_iostream;
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_stringbuf;
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_istringstream;
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_ostringstream;
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_stringstream;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_filebuf;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ifstream;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ofstream;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_fstream;


template < class _Elem,
 class _InIt >
 class num_get;
template < class _Elem,
 class _OutIt >
 class num_put;
template < class _Elem >
 class collate;



typedef basic_ios< char, char_traits< char> >  ios; 
typedef basic_streambuf< char, char_traits< char> >  streambuf; 
typedef basic_istream< char, char_traits< char> >  istream; 
typedef basic_ostream< char, char_traits< char> >  ostream; 
typedef basic_iostream< char, char_traits< char> >  iostream; 

typedef basic_stringbuf< char, char_traits< char> , allocator< char> >  stringbuf; 

typedef basic_istringstream< char, char_traits< char> , allocator< char> >  istringstream; 

typedef basic_ostringstream< char, char_traits< char> , allocator< char> >  ostringstream; 

typedef basic_stringstream< char, char_traits< char> , allocator< char> >  stringstream; 
typedef basic_filebuf< char, char_traits< char> >  filebuf; 
typedef basic_ifstream< char, char_traits< char> >  ifstream; 
typedef basic_ofstream< char, char_traits< char> >  ofstream; 
typedef basic_fstream< char, char_traits< char> >  fstream; 


typedef basic_ios< __wchar_t, char_traits< __wchar_t> >  wios; 

typedef basic_streambuf< __wchar_t, char_traits< __wchar_t> >  wstreambuf; 
typedef basic_istream< __wchar_t, char_traits< __wchar_t> >  wistream; 
typedef basic_ostream< __wchar_t, char_traits< __wchar_t> >  wostream; 
typedef basic_iostream< __wchar_t, char_traits< __wchar_t> >  wiostream; 

typedef basic_stringbuf< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringbuf; 

typedef basic_istringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wistringstream; 

typedef basic_ostringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wostringstream; 

typedef basic_stringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringstream; 
typedef basic_filebuf< __wchar_t, char_traits< __wchar_t> >  wfilebuf; 
typedef basic_ifstream< __wchar_t, char_traits< __wchar_t> >  wifstream; 
typedef basic_ofstream< __wchar_t, char_traits< __wchar_t> >  wofstream; 
typedef basic_fstream< __wchar_t, char_traits< __wchar_t> >  wfstream; 




typedef num_get< char, istreambuf_iterator< char, char_traits< char> > >  numget; 

typedef num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumget; 

typedef num_put< char, ostreambuf_iterator< char, char_traits< char> > >  numput; 

typedef num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumput; 
typedef collate< char>  ncollate; 
typedef collate< __wchar_t>  wcollate; 

}

/* Removed pragma: #pragma warning(pop)*/
#pragma pack ( pop )
#line 13 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\ymath.h"
#pragma pack ( push, 8 )
#line 35
extern "C" { typedef 
#line 30
union { 
unsigned short _Word[8]; 
float _Float; 
double _Double; 
long double _Long_double; 
} _Dconst; }


extern "C" { void __cdecl _Feraise(int); } 


extern "C" { __declspec(dllimport) double __cdecl _Cosh(double, double); } 
extern "C" { __declspec(dllimport) short __cdecl _Dtest(double *); } 
extern "C" { __declspec(dllimport) short __cdecl _Exp(double *, double, short); } 
extern "C" { __declspec(dllimport) double __cdecl _Sinh(double, double); } 
extern "C" __declspec(dllimport) _Dconst _Denorm, _Hugeval, _Inf, 
_Nan, _Snan; 


extern "C" { __declspec(dllimport) float __cdecl _FCosh(float, float); } 
extern "C" { __declspec(dllimport) short __cdecl _FDtest(float *); } 
extern "C" { __declspec(dllimport) short __cdecl _FExp(float *, float, short); } 
extern "C" { __declspec(dllimport) float __cdecl _FSinh(float, float); } 
extern "C" __declspec(dllimport) _Dconst _FDenorm, _FInf, _FNan, _FSnan; 


extern "C" { __declspec(dllimport) long double __cdecl _LCosh(long double, long double); } 
extern "C" { __declspec(dllimport) short __cdecl _LDtest(long double *); } 
extern "C" { __declspec(dllimport) short __cdecl _LExp(long double *, long double, short); } 
extern "C" { __declspec(dllimport) long double __cdecl _LSinh(long double, long double); } 
extern "C" __declspec(dllimport) _Dconst _LDenorm, _LInf, _LNan, _LSnan; 
#line 67
#pragma pack ( pop )
#line 83 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\float.h"
extern "C" { __declspec(dllimport) unsigned __cdecl _clearfp(); } 
/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4141) /* Removed pragma: #pragma warning(disable: 4141)*/
extern "C" { __declspec(deprecated("This function or variable may be unsafe. Consider using _controlfp_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNING" "S. See online help for details.")) __declspec(dllimport) unsigned __cdecl _controlfp(unsigned _NewValue, unsigned _Mask); } 
/* Removed pragma: #pragma warning(pop)*/
extern "C" { __declspec(dllimport) void __cdecl _set_controlfp(unsigned _NewValue, unsigned _Mask); } 
extern "C" { __declspec(dllimport) errno_t __cdecl _controlfp_s(unsigned * _CurrentState, unsigned _NewValue, unsigned _Mask); } 
extern "C" { __declspec(dllimport) unsigned __cdecl _statusfp(); } 
extern "C" { __declspec(dllimport) void __cdecl _fpreset(); } 


extern "C" { __declspec(dllimport) void __cdecl _statusfp2(unsigned * _X86_status, unsigned * _SSE2_status); } 
#line 172
extern "C" { __declspec(dllimport) unsigned __cdecl _control87(unsigned _NewValue, unsigned _Mask); } 

extern "C" { __declspec(dllimport) int __cdecl __control87_2(unsigned _NewValue, unsigned _Mask, unsigned * _X86_cw, unsigned * _Sse2_cw); } 
#line 180
extern "C" { __declspec(dllimport) extern int *__cdecl __fpecode(); } 
#line 216
extern "C" { __declspec(dllimport) double __cdecl _scalb(double _X, long _Y); } 
extern "C" { __declspec(dllimport) double __cdecl _logb(double _X); } 
extern "C" { __declspec(dllimport) double __cdecl _nextafter(double _X, double _Y); } 
extern "C" { __declspec(dllimport) int __cdecl _finite(double _X); } 
extern "C" { __declspec(dllimport) int __cdecl _isnan(double _X); } 
extern "C" { __declspec(dllimport) int __cdecl _fpclass(double _X); } 
#line 247
extern "C" { __declspec(dllimport) void __cdecl fpreset(); } 
#line 14 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
/* Removed pragma: #pragma warning(push,3)*/
#line 13
#pragma pack ( push, 8 )


namespace std { 
#line 35
typedef 
#line 31
enum { 
denorm_indeterminate = (-1), 
denorm_absent = 0, 
denorm_present
} float_denorm_style; 
#line 45
typedef 
#line 39
enum { 
round_indeterminate = (-1), 
round_toward_zero = 0, 
round_to_nearest, 
round_toward_infinity, 
round_toward_neg_infinity
} float_round_style; 


struct __declspec(dllimport) _Num_base { 

static const float_denorm_style has_denorm = ((float_denorm_style)denorm_absent); 
static const bool has_denorm_loss = ((bool)(false)); 
static const bool has_infinity = ((bool)(false)); 
static const bool has_quiet_NaN = ((bool)(false)); 
static const bool has_signaling_NaN = ((bool)(false)); 
static const bool is_bounded = ((bool)(false)); 
static const bool is_exact = ((bool)(false)); 
static const bool is_iec559 = ((bool)(false)); 
static const bool is_integer = ((bool)(false)); 
static const bool is_modulo = ((bool)(false)); 
static const bool is_signed = ((bool)(false)); 
static const bool is_specialized = ((bool)(false)); 
static const bool tinyness_before = ((bool)(false)); 
static const bool traps = ((bool)(false)); 
static const float_round_style round_style = ((float_round_style)round_toward_zero); 
static const int digits = ((int)(0)); 
static const int digits10 = ((int)(0)); 


static const int max_digits10 = ((int)(0)); 


static const int max_exponent = ((int)(0)); 
static const int max_exponent10 = ((int)(0)); 
static const int min_exponent = ((int)(0)); 
static const int min_exponent10 = ((int)(0)); 
static const int radix = ((int)(0)); 
}; 


template < class _Ty >
 class numeric_limits
  : public _Num_base{ 


public: static _Ty ( __cdecl min ) ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

static _Ty ( __cdecl max ) ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }


static _Ty __cdecl lowest ( ) throw ( )
  {
  return ( ( min ) ( ) );
  }


static _Ty __cdecl epsilon ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

static _Ty __cdecl round_error ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

static _Ty __cdecl denorm_min ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

static _Ty __cdecl infinity ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

static _Ty __cdecl quiet_NaN ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

static _Ty __cdecl signaling_NaN ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }
};

template < class _Ty >
 class numeric_limits < const _Ty >
  : public numeric_limits < _Ty >{ 

};

template < class _Ty >
 class numeric_limits < volatile _Ty >
  : public numeric_limits < _Ty >{ 

};

template < class _Ty >
 class numeric_limits < const volatile _Ty >
  : public numeric_limits < _Ty >{ 

};


struct __declspec(dllimport) _Num_int_base : public _Num_base { 


static const bool is_bounded = ((bool)(true)); 
static const bool is_exact = ((bool)(true)); 
static const bool is_integer = ((bool)(true)); 
static const bool is_modulo = ((bool)(true)); 
static const bool is_specialized = ((bool)(true)); 
static const int radix = ((int)(2)); 
}; 


struct __declspec(dllimport) _Num_float_base : public _Num_base { 


static const float_denorm_style has_denorm = ((float_denorm_style)denorm_present); 
static const bool has_denorm_loss = ((bool)(true)); 
static const bool has_infinity = ((bool)(true)); 
static const bool has_quiet_NaN = ((bool)(true)); 
static const bool has_signaling_NaN = ((bool)(true)); 
static const bool is_bounded = ((bool)(true)); 
static const bool is_exact = ((bool)(false)); 
static const bool is_iec559 = ((bool)(true)); 
static const bool is_integer = ((bool)(false)); 
static const bool is_modulo = ((bool)(false)); 
static const bool is_signed = ((bool)(true)); 
static const bool is_specialized = ((bool)(true)); 
static const bool tinyness_before = ((bool)(true)); 
static const bool traps = ((bool)(true)); 
static const float_round_style round_style = ((float_round_style)round_to_nearest); 
static const int radix = ((int)(2)); 
}; 


template<> class numeric_limits< char>  : public _Num_int_base { 



public: typedef char _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIcE3minEv static inline _Ty __cdecl min() throw() 
{ 
return ((-128)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIcE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (127); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIcE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIcE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIcE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIcE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIcE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIcE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIcE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)((-128) != 0)); 
__declspec(dllimport) static const int digits = ((int)(8 - (((-128) != 0) ? 1 : 0))); 
__declspec(dllimport) static const int digits10 = ((int)((8 - (((-128) != 0) ? 1 : 0)) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 - (((-128) != 0) ? 1 : 0)) * 301L / 1000)); 


}; 


template<> class numeric_limits< __wchar_t>  : public _Num_int_base { 



public: typedef __wchar_t _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIwE3minEv static inline _Ty __cdecl min() throw() 
{ 
return ((_Ty)0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIwE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return ((_Ty)0xffff); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIwE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIwE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIwE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIwE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIwE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIwE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIwE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(0 != 0)); 
__declspec(dllimport) static const int digits = ((int)(8 * sizeof(__wchar_t) - ((0 != 0) ? 1 : 0))); 

__declspec(dllimport) static const int digits10 = ((int)((8 * sizeof(__wchar_t) - ((0 != 0) ? 1 : 0)) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 * sizeof(__wchar_t) - ((0 != 0) ? 1 : 0)) * 301L / 1000)); 


}; 


template<> class numeric_limits< bool>  : public _Num_int_base { 



public: typedef bool _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIbE3minEv static inline _Ty __cdecl min() throw() 
{ 
return (false); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIbE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (true); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIbE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIbE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIbE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIbE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIbE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIbE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIbE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_modulo = ((bool)(false)); 
__declspec(dllimport) static const bool is_signed = ((bool)(false)); 
__declspec(dllimport) static const int digits = ((int)(1)); 
__declspec(dllimport) static const int digits10 = ((int)(0)); 


__declspec(dllimport) static const int max_digits10 = ((int)(0)); 

}; 


template<> class numeric_limits< signed char>  : public _Num_int_base { 



public: typedef signed char _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIaE3minEv static inline _Ty __cdecl min() throw() 
{ 
return ((-128)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIaE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (127); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIaE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIaE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIaE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIaE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIaE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIaE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIaE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(true)); 
__declspec(dllimport) static const int digits = ((int)(8 - 1)); 
__declspec(dllimport) static const int digits10 = ((int)((8 - 1) * 301L / 1000)); 


__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 - 1) * 301L / 1000)); 

}; 


template<> class numeric_limits< unsigned char>  : public _Num_int_base { 



public: typedef unsigned char _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIhE3minEv static inline _Ty __cdecl min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIhE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (0xff); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIhE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIhE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIhE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIhE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIhE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIhE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIhE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(false)); 
__declspec(dllimport) static const int digits = ((int)(8)); 
__declspec(dllimport) static const int digits10 = ((int)(8 * 301L / 1000)); 


__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8) * 301L / 1000)); 

}; 


template<> class numeric_limits< short>  : public _Num_int_base { 



public: typedef short _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIsE3minEv static inline _Ty __cdecl min() throw() 
{ 
return ((-32768)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIsE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (32767); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIsE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIsE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIsE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIsE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIsE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIsE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIsE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(true)); 
__declspec(dllimport) static const int digits = ((int)(8 * sizeof(short) - 1)); 
__declspec(dllimport) static const int digits10 = ((int)((8 * sizeof(short) - 1) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 * sizeof(short) - 1) * 301L / 1000)); 


}; 



template<> class numeric_limits< unsigned short>  : public _Num_int_base { 



public: typedef unsigned short _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsItE3minEv static inline _Ty __cdecl min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsItE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (0xffff); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsItE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsItE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsItE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsItE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsItE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsItE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsItE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(false)); 
__declspec(dllimport) static const int digits = ((int)(8 * sizeof(unsigned short))); 
__declspec(dllimport) static const int digits10 = ((int)((8 * sizeof(unsigned short)) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 * sizeof(unsigned short)) * 301L / 1000)); 


}; 
#line 701
template<> class numeric_limits< int>  : public _Num_int_base { 



public: typedef int _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIiE3minEv static inline _Ty __cdecl min() throw() 
{ 
return ((-2147483647 - 1)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIiE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (2147483647); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIiE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIiE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIiE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIiE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIiE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIiE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIiE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(true)); 
__declspec(dllimport) static const int digits = ((int)(8 * sizeof(int) - 1)); 
__declspec(dllimport) static const int digits10 = ((int)((8 * sizeof(int) - 1) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 * sizeof(int) - 1) * 301L / 1000)); 


}; 


template<> class numeric_limits< unsigned>  : public _Num_int_base { 



public: typedef unsigned _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIjE3minEv static inline _Ty __cdecl min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIjE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (0xffffffffU); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIjE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIjE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIjE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIjE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIjE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIjE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIjE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(false)); 
__declspec(dllimport) static const int digits = ((int)(8 * sizeof(unsigned))); 
__declspec(dllimport) static const int digits10 = ((int)((8 * sizeof(unsigned)) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 * sizeof(unsigned)) * 301L / 1000)); 


}; 


template<> class numeric_limits< long>  : public _Num_int_base { 



public: typedef long _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIlE3minEv static inline _Ty __cdecl min() throw() 
{ 
return ((-2147483647L - 1)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIlE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (2147483647L); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIlE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIlE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIlE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIlE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIlE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIlE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIlE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(true)); 
__declspec(dllimport) static const int digits = ((int)(8 * sizeof(long) - 1)); 
__declspec(dllimport) static const int digits10 = ((int)((8 * sizeof(long) - 1) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 * sizeof(long) - 1) * 301L / 1000)); 


}; 


template<> class numeric_limits< unsigned long>  : public _Num_int_base { 



public: typedef unsigned long _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsImE3minEv static inline _Ty __cdecl min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsImE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (0xffffffffUL); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsImE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsImE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsImE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsImE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsImE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsImE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsImE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(false)); 
__declspec(dllimport) static const int digits = ((int)(8 * sizeof(unsigned long))); 
__declspec(dllimport) static const int digits10 = ((int)((8 * sizeof(unsigned long)) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 * sizeof(unsigned long)) * 301L / 1000)); 


}; 
#line 1024
template<> class numeric_limits< __int64>  : public _Num_int_base { 



public: typedef __int64 _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIxE3minEv static inline _Ty __cdecl min() throw() 
{ 
return (-0x7fffffffffffffffi64 - 1); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIxE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (0x7fffffffffffffffi64); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIxE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIxE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIxE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIxE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIxE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIxE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIxE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(true)); 
__declspec(dllimport) static const int digits = ((int)(8 * sizeof(__int64) - 1)); 
__declspec(dllimport) static const int digits10 = ((int)((8 * sizeof(__int64) - 1) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 * sizeof(__int64) - 1) * 301L / 1000)); 


}; 


template<> class numeric_limits< unsigned __int64>  : public _Num_int_base { 



public: typedef unsigned __int64 _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIyE3minEv static inline _Ty __cdecl min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIyE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return (0xffffffffffffffffUi64); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIyE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (min()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIyE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIyE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIyE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIyE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIyE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (0); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIyE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (0); 
} 

__declspec(dllimport) static const bool is_signed = ((bool)(false)); 
__declspec(dllimport) static const int digits = ((int)(8 * sizeof(unsigned __int64))); 
__declspec(dllimport) static const int digits10 = ((int)((8 * sizeof(unsigned __int64)) * 301L / 1000)); 



__declspec(dllimport) static const int max_digits10 = ((int)(2 + (8 * sizeof(unsigned __int64)) * 301L / 1000)); 


}; 



template<> class numeric_limits< float>  : public _Num_float_base { 



public: typedef float _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIfE3minEv static inline _Ty __cdecl min() throw() 
{ 
return ((1.175494351e-038F)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIfE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return ((3.402823466e+038F)); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIfE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (-max()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIfE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return ((1.192092896e-007F)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIfE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return ((0.5)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIfE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (::_FDenorm._Float); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIfE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (::_FInf._Float); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIfE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (::_FNan._Float); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIfE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (::_FSnan._Float); 
} 

__declspec(dllimport) static const int digits = ((int)(24)); 
__declspec(dllimport) static const int digits10 = ((int)(6)); 


__declspec(dllimport) static const int max_digits10 = ((int)(2 + 6)); 


__declspec(dllimport) static const int max_exponent = ((int)((int)128)); 
__declspec(dllimport) static const int max_exponent10 = ((int)((int)38)); 
__declspec(dllimport) static const int min_exponent = ((int)((int)(-125))); 
__declspec(dllimport) static const int min_exponent10 = ((int)((int)(-37))); 
}; 


template<> class numeric_limits< double>  : public _Num_float_base { 



public: typedef double _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIdE3minEv static inline _Ty __cdecl min() throw() 
{ 
return ((2.2250738585072014e-308)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIdE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return ((1.7976931348623157e+308)); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIdE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (-max()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIdE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return ((2.2204460492503131e-016)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIdE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return ((0.5)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIdE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (::_Denorm._Double); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIdE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (::_Inf._Double); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIdE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (::_Nan._Double); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIdE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (::_Snan._Double); 
} 

__declspec(dllimport) static const int digits = ((int)(53)); 
__declspec(dllimport) static const int digits10 = ((int)(15)); 


__declspec(dllimport) static const int max_digits10 = ((int)(2 + 15)); 


__declspec(dllimport) static const int max_exponent = ((int)((int)1024)); 
__declspec(dllimport) static const int max_exponent10 = ((int)((int)308)); 
__declspec(dllimport) static const int min_exponent = ((int)((int)(-1021))); 
__declspec(dllimport) static const int min_exponent10 = ((int)((int)(-307))); 
}; 


template<> class numeric_limits< long double>  : public _Num_float_base { 



public: typedef long double _Ty; 

CPPTEST_IMP__ZNSt14numeric_limitsIeE3minEv static inline _Ty __cdecl min() throw() 
{ 
return ((2.2250738585072014e-308)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIeE3maxEv static inline _Ty __cdecl max() throw() 
{ 
return ((1.7976931348623157e+308)); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIeE6lowestEv static inline _Ty __cdecl lowest() throw() 
{ 
return (-max()); 
} 


CPPTEST_IMP__ZNSt14numeric_limitsIeE7epsilonEv static inline _Ty __cdecl epsilon() throw() 
{ 
return ((2.2204460492503131e-016)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIeE11round_errorEv static inline _Ty __cdecl round_error() throw() 
{ 
return ((0.5)); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIeE10denorm_minEv static inline _Ty __cdecl denorm_min() throw() 
{ 
return (::_LDenorm._Long_double); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIeE8infinityEv static inline _Ty __cdecl infinity() throw() 
{ 
return (::_LInf._Long_double); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIeE9quiet_NaNEv static inline _Ty __cdecl quiet_NaN() throw() 
{ 
return (::_LNan._Long_double); 
} 

CPPTEST_IMP__ZNSt14numeric_limitsIeE13signaling_NaNEv static inline _Ty __cdecl signaling_NaN() throw() 
{ 
return (::_LSnan._Long_double); 
} 

__declspec(dllimport) static const int digits = ((int)(53)); 
__declspec(dllimport) static const int digits10 = ((int)(15)); 


__declspec(dllimport) static const int max_digits10 = ((int)(2 + 15)); 


__declspec(dllimport) static const int max_exponent = ((int)((int)1024)); 
__declspec(dllimport) static const int max_exponent10 = ((int)((int)308)); 
__declspec(dllimport) static const int min_exponent = ((int)((int)(-1021))); 
__declspec(dllimport) static const int min_exponent10 = ((int)((int)(-307))); 
}; 
#line 1637
}
/* Removed pragma: #pragma warning(pop)*/
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xtr1common"
/* Removed pragma: #pragma warning(push,3)*/
#line 1639 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
#pragma pack ( pop )
#line 8 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xtr1common"
#pragma pack ( push, 8 )
#line 151
namespace std { 

template < class _T1,
 class _Ret >
 struct unary_function;


template < class _T1,
 class _T2,
 class _Ret >
 struct binary_function;

namespace tr1 { 

#pragma pack(8)
#line 165
struct _Nil { 

}; 
#pragma pack()
#line 168
static _Nil _Nil_obj; 


template < class _Ty,
 _Ty _Val >
 struct integral_constant{ 

static const _Ty value = _Val; 

typedef _Ty value_type; 
typedef integral_constant < _Ty, _Val > type; 
};

typedef integral_constant< bool, true>  true_type; 
typedef integral_constant< bool, false>  false_type; 


template < bool _First,
 bool _Second >
 struct _Or;

template<> struct _Or< false, false>  : public false_type { 


}; 


template<> struct _Or< false, true>  : public true_type { 


}; 


template<> struct _Or< true, false>  : public true_type { 


}; 


template<> struct _Or< true, true>  : public true_type { 


}; 


template < bool >
 struct _Cat_base;

template<> struct _Cat_base< false>  : public false_type { 


}; 


template<> struct _Cat_base< true>  : public true_type { 


}; 


template < class _Ty >
 struct _Is_integral
  : false_type{ 

};


template<> struct _Is_integral< bool>  : public true_type { 


}; 


template<> struct _Is_integral< char>  : public true_type { 


}; 


template<> struct _Is_integral< unsigned char>  : public true_type { 


}; 


template<> struct _Is_integral< signed char>  : public true_type { 


}; 



template<> struct _Is_integral< __wchar_t>  : public true_type { 


}; 



template<> struct _Is_integral< unsigned short>  : public true_type { 


}; 


template<> struct _Is_integral< signed short>  : public true_type { 


}; 


template<> struct _Is_integral< unsigned>  : public true_type { 


}; 


template<> struct _Is_integral< signed int>  : public true_type { 


}; 


template<> struct _Is_integral< unsigned long>  : public true_type { 


}; 


template<> struct _Is_integral< signed long>  : public true_type { 


}; 



template<> struct _Is_integral< __int64>  : public true_type { 


}; 


template<> struct _Is_integral< unsigned __int64>  : public true_type { 


}; 



template < class _Ty >
 struct _Is_floating_point
  : false_type{ 

};


template<> struct _Is_floating_point< float>  : public true_type { 


}; 


template<> struct _Is_floating_point< double>  : public true_type { 


}; 


template<> struct _Is_floating_point< long double>  : public true_type { 


}; 


template < class _Ty >
 struct _Remove_reference{ 

typedef _Ty _Type; 
};

template < class _Ty >
 struct _Remove_reference < _Ty & >{ 

typedef _Ty _Type; 
};

template < class _Ty >
 struct _Remove_reference < _Ty && >{ 

typedef _Ty _Type; 
};


template < class _Ty >
 struct _Remove_rvalue_reference{ 

typedef _Ty _Type; 
};

template < class _Ty >
 struct _Remove_rvalue_reference < _Ty && >{ 

typedef _Ty _Type; 
};


template < class _Tgt,
 class _Src >
 struct _Copy_cv{ 

typedef typename _Remove_reference < _Tgt > :: _Type _Tgtx; 
typedef _Tgtx & _Type; 
};

template < class _Tgt,
 class _Src >
 struct _Copy_cv < _Tgt, const _Src >{ 

typedef typename _Remove_reference < _Tgt > :: _Type _Tgtx; 
typedef const _Tgtx & _Type; 
};

template < class _Tgt,
 class _Src >
 struct _Copy_cv < _Tgt, volatile _Src >{ 

typedef typename _Remove_reference < _Tgt > :: _Type _Tgtx; 
typedef volatile _Tgtx & _Type; 
};

template < class _Tgt,
 class _Src >
 struct _Copy_cv < _Tgt, const volatile _Src >{ 

typedef typename _Remove_reference < _Tgt > :: _Type _Tgtx; 
typedef const volatile _Tgtx & _Type; 
};

template < class _Tgt,
 class _Src >
 struct _Copy_cv < _Tgt, _Src & >{ 

typedef typename _Copy_cv < _Tgt, _Src > :: _Type _Type; 
};
#line 422
_No _Has_result_type(...); 

template < class _Ty >
 _Yes _Has_result_type ( _Ty *,
  typename _Remove_reference < typename _Ty :: result_type > :: _Type * = 0 );



}
}
/* Removed pragma: #pragma warning(pop)*/
#line 10 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
/* Removed pragma: #pragma warning(push,3)*/
#line 433 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xtr1common"
#pragma pack ( pop )
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
#pragma pack ( push, 8 )
#line 50
namespace std { 
namespace tr1 { 

template < class _Ty >
 struct _Ptr_traits{ 

};

template < class _Ty >
 struct _Ptr_traits < _Ty * >{ 

static const bool _Is_const = false; 
static const bool _Is_volatile = false; 
};

template < class _Ty >
 struct _Ptr_traits < const _Ty * >{ 

static const bool _Is_const = true; 
static const bool _Is_volatile = false; 
};

template < class _Ty >
 struct _Ptr_traits < volatile _Ty * >{ 

static const bool _Is_const = false; 
static const bool _Is_volatile = true; 
};

template < class _Ty >
 struct _Ptr_traits < const volatile _Ty * >{ 

static const bool _Is_const = true; 
static const bool _Is_volatile = true; 
};

template < class _Ty >
 struct _Is_funptr
  : false_type{ 

};

template < class _Ty >
 struct _Is_memfunptr
  : false_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret >
 struct _Is_funptr < _Ret ( * ) ( ) >
 : true_type{ 

};

template < class _Ret >
 struct _Is_funptr < _Ret ( * ) ( ... ) >
 : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( ) >
  : true_type{ 

};

template < class _Ret, class _Arg0 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( ... ) const volatile >
  : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1 ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1 ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1 ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1 ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1 ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1 ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1 ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1 ... ) const volatile >
  : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2 ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2 ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2 ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2 ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2 ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2 ... ) const volatile >
  : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ... ) const volatile >
  : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ... ) const volatile >
  : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ... ) const volatile >
  : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ... ) const volatile >
  : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ... ) const volatile >
  : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ... ) const volatile >
  : true_type{ 

};
#line 4 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
 : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_funptr < _Ret ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ... ) >
 : true_type{ 

};


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ... ) >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ... ) const >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ... ) volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile >
  : true_type{ 

};

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Is_memfunptr < _Ret ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ... ) const volatile >
  : true_type{ 

};
#line 103 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
template < class _Ty >
 struct remove_const{ 

typedef _Ty type; 
};

template < class _Ty >
 struct remove_const < const _Ty >{ 

typedef _Ty type; 
};

template < class _Ty >
 struct remove_const < const _Ty [ ] >{ 

typedef _Ty type [ ]; 
};

template < class _Ty, unsigned int _Nx >
 struct remove_const < const _Ty [ _Nx ] >{ 

typedef _Ty type [ _Nx ]; 
};


template < class _Ty >
 struct remove_volatile{ 

typedef _Ty type; 
};

template < class _Ty >
 struct remove_volatile < volatile _Ty >{ 

typedef _Ty type; 
};

template < class _Ty >
 struct remove_volatile < volatile _Ty [ ] >{ 

typedef _Ty type [ ]; 
};

template < class _Ty, unsigned int _Nx >
 struct remove_volatile < volatile _Ty [ _Nx ] >{ 

typedef _Ty type [ _Nx ]; 
};


template < class _Ty >
 struct remove_cv{ 


typedef typename remove_const < typename remove_volatile < _Ty > :: type > :: type type; 
};


template < class _Ty >
 struct add_const{ 

typedef const _Ty type; 
};

template < class _Ty >
 struct add_const < _Ty & >{ 

typedef _Ty & type; 
};


template < class _Ty >
 struct add_volatile{ 

typedef volatile _Ty type; 
};

template < class _Ty >
 struct add_volatile < _Ty & >{ 

typedef _Ty & type; 
};


template < class _Ty >
 struct add_cv{ 

typedef typename add_const < typename add_volatile < _Ty > :: type > :: type type; 
};


template < class _Ty >
 struct remove_reference
 : _Remove_reference < _Ty >{ 

typedef typename _Remove_reference < _Ty > :: _Type type; 
};


template < class _Ty >
 struct add_reference{ 

typedef typename _Remove_reference < _Ty > :: _Type & type; 
};


template<> struct add_reference< void>  { 

typedef void type; 
}; 


template<> struct add_reference< const void>  { 

typedef const void type; 
}; 


template<> struct add_reference< volatile void>  { 

typedef volatile void type; 
}; 


template<> struct add_reference< const volatile void>  { 

typedef const volatile void type; 
}; 


template < class _Ty >
 struct add_lvalue_reference{ 

typedef typename add_reference < _Ty > :: type type; 
};


template < class _Ty >
 struct add_rvalue_reference{ 

typedef _Ty && type; 
};

template < class _Ty >
 struct add_rvalue_reference < _Ty & >{ 

typedef _Ty & type; 
};


template<> struct add_rvalue_reference< void>  { 

typedef void type; 
}; 


template<> struct add_rvalue_reference< const void>  { 

typedef const void type; 
}; 


template<> struct add_rvalue_reference< volatile void>  { 

typedef volatile void type; 
}; 


template<> struct add_rvalue_reference< const volatile void>  { 

typedef const volatile void type; 
}; 


template < class _Ty >
 struct remove_extent{ 

typedef _Ty type; 
};

template < class _Ty, unsigned int _Ix >
 struct remove_extent < _Ty [ _Ix ] >{ 

typedef _Ty type; 
};

template < class _Ty >
 struct remove_extent < _Ty [ ] >{ 

typedef _Ty type; 
};


template < class _Ty >
 struct remove_all_extents{ 

typedef _Ty type; 
};

template < class _Ty, unsigned int _Ix >
 struct remove_all_extents < _Ty [ _Ix ] >{ 

typedef typename remove_all_extents < _Ty > :: type type; 
};

template < class _Ty >
 struct remove_all_extents < _Ty [ ] >{ 

typedef typename remove_all_extents < _Ty > :: type type; 
};


template < class _Ty >
 struct remove_pointer{ 

typedef _Ty type; 
};

template < class _Ty >
 struct remove_pointer < _Ty * >{ 

typedef _Ty type; 
};

template < class _Ty >
 struct remove_pointer < _Ty * const >{ 

typedef _Ty type; 
};

template < class _Ty >
 struct remove_pointer < _Ty * volatile >{ 

typedef _Ty type; 
};

template < class _Ty >
 struct remove_pointer < _Ty * const volatile >{ 

typedef _Ty type; 
};


template < class _Ty >
 struct add_pointer{ 

typedef typename remove_reference < _Ty > :: type * type; 
};



template < class _Ty >
 struct _Is_void
 : false_type{ 

};


template<> struct _Is_void< void>  : public true_type { 


}; 

template < class _Ty >
 struct is_void
 : _Is_void < typename remove_cv < _Ty > :: type >{ 

};


template < class _Ty >
 struct is_integral
 : _Is_integral < typename remove_cv < _Ty > :: type >{ 

};


template < class _Ty >
 struct is_floating_point
 : _Is_floating_point < typename remove_cv < _Ty > :: type >{ 

};


template < class _Ty >
 struct is_array
 : false_type{ 

};

template < class _Ty, size_t _Nx >
 struct is_array < _Ty [ _Nx ] >
 : true_type{ 

};

template < class _Ty >
 struct is_array < _Ty [ ] >
 : true_type{ 

};



template < class _Ty >
 struct is_lvalue_reference
 : false_type{ 

};

template < class _Ty >
 struct is_lvalue_reference < _Ty & >
 : true_type{ 

};


template < class _Ty >
 struct is_rvalue_reference
 : false_type{ 

};

template < class _Ty >
 struct is_rvalue_reference < _Ty && >
 : true_type{ 

};


template < class _Ty >
 struct is_reference
 : _Cat_base < is_lvalue_reference < _Ty > :: value
  || is_rvalue_reference < _Ty > :: value >{ 

};
#line 456
template < class _Ty >
 struct _Is_member_object_pointer
 : false_type{ 

};

template < class _Ty1, class _Ty2 >
 struct _Is_member_object_pointer < _Ty1 _Ty2 :: * >
 : _Cat_base < ! _Is_memfunptr < _Ty1 _Ty2 :: * > :: value >{ 

};

template < class _Ty >
 struct is_member_object_pointer
 : _Is_member_object_pointer < typename remove_cv < _Ty > :: type >{ 

};


template < class _Ty >
 struct is_member_function_pointer
 : _Cat_base < _Is_memfunptr < typename remove_cv < _Ty > :: type > :: value >{ 

};


template < class _Ty >
 struct _Is_pointer
 : false_type{ 

};

template < class _Ty >
 struct _Is_pointer < _Ty * >
 : _Cat_base < ! is_member_object_pointer < _Ty * > :: value
  && ! is_member_function_pointer < _Ty * > :: value >{ 

};

template < class _Ty >
 struct is_pointer
 : _Is_pointer < typename remove_cv < _Ty > :: type >{ 

};


template < class _Ty >
 struct is_union : _Cat_base < __is_union ( _Ty ) >{ 

};


template < class _Ty >
 struct is_class : _Cat_base < __is_class ( _Ty ) >{ 

};


template < class _Ty >
 struct is_function
 : _Cat_base < _Is_funptr < typename remove_cv < _Ty > :: type * > :: value >{ 

};

template < class _Ty >
 struct is_function < _Ty & >
 : false_type{ 

};


template < class _Ty >
 struct is_arithmetic
 : _Cat_base < is_integral < _Ty > :: value
  || is_floating_point < _Ty > :: value >{ 

};


template < class _Ty >
 struct is_fundamental
 : _Cat_base < is_arithmetic < _Ty > :: value
  || is_void < _Ty > :: value >{ 

};


template < class _Ty >
 struct is_object
 : _Cat_base < ! is_function < _Ty > :: value
  && ! is_reference < _Ty > :: value
  && ! is_void < _Ty > :: value >{ 

};



template < class _From, class _To >
 struct is_convertible : _Cat_base < is_void < _From > :: value && is_void < _To > :: value || __is_convertible_to ( _From, _To ) >{ 

};



template < class _Ty >
 struct is_enum : _Cat_base < __is_enum ( _Ty ) >{ 

};


template < class _Ty >
 struct is_compound
 : _Cat_base < ! is_fundamental < _Ty > :: value >{ 

};


template < class _Ty >
 struct is_member_pointer
 : _Cat_base < is_member_object_pointer < _Ty > :: value
  || is_member_function_pointer < _Ty > :: value >{ 

};


template < class _Ty >
 struct is_scalar
 : _Cat_base < is_arithmetic < _Ty > :: value
  || is_enum < _Ty > :: value
  || is_pointer < _Ty > :: value
  || is_member_pointer < _Ty > :: value >{ 

};

template < class _Ty >
 struct is_scalar < _Ty & >
 : false_type{ 

};


template < class _Ty >
 struct is_const
 : _Cat_base < _Ptr_traits < _Ty * > :: _Is_const
  && ! is_function < _Ty > :: value >{ 

};

template < class _Ty, unsigned int _Nx >
 struct is_const < _Ty [ _Nx ] >
 : false_type{ 

};

template < class _Ty, unsigned int _Nx >
 struct is_const < const _Ty [ _Nx ] >
 : true_type{ 

};

template < class _Ty >
 struct is_const < _Ty & >
 : false_type{ 

};


template < class _Ty >
 struct is_volatile
 : _Cat_base < _Ptr_traits < _Ty * > :: _Is_volatile
  && ! is_function < _Ty > :: value >{ 

};

template < class _Ty >
 struct is_volatile < _Ty & >
 : false_type{ 

};


template < class _Ty >
 struct _Is_pod : _Cat_base < is_void < _Ty > :: value || is_scalar < _Ty > :: value || __has_trivial_constructor ( _Ty ) && __is_pod ( _Ty ) >{ 

};

template < class _Ty >
 struct is_pod
 : _Is_pod < typename :: std :: tr1 :: remove_all_extents < _Ty > :: type >{ 

};


template < class _Ty >
 struct is_empty : _Cat_base < __is_empty ( _Ty ) >{ 

};


template < class _Ty >
 struct is_polymorphic : _Cat_base < __is_polymorphic ( _Ty ) >{ 

};


template < class _Ty >
 struct is_abstract : _Cat_base < __is_abstract ( _Ty ) >{ 

};



template < class _Ty >
 struct is_standard_layout : is_pod < _Ty >{ 

};


template < class _Ty >
 struct is_trivial : is_pod < _Ty >{ 

};



template < class _Ty >
 struct has_trivial_constructor : _Cat_base < is_pod < _Ty > :: value || __has_trivial_constructor ( _Ty ) >{ 

};


template < class _Ty >
 struct has_trivial_copy : _Cat_base < is_pod < _Ty > :: value || __has_trivial_copy ( _Ty ) >{ 

};



template < class _Ty >
 struct has_trivial_default_constructor : _Cat_base < is_pod < _Ty > :: value || __has_trivial_constructor ( _Ty ) >{ 

};


template < class _Ty >
 struct has_trivial_copy_constructor : _Cat_base < is_pod < _Ty > :: value || __has_trivial_copy ( _Ty ) >{ 

};



template < class _Ty >
 struct has_trivial_assign : _Cat_base < is_pod < _Ty > :: value || __has_trivial_assign ( _Ty ) >{ 

};


template < class _Ty >
 struct has_trivial_destructor : _Cat_base < ! is_void < _Ty > :: value && ( is_pod < _Ty > :: value || __has_trivial_destructor ( _Ty ) ) >{ 

};


template < class _Ty >
 struct has_nothrow_constructor : _Cat_base < is_pod < _Ty > :: value || __has_nothrow_constructor ( _Ty ) >{ 

};


template < class _Ty >
 struct has_nothrow_copy : _Cat_base < is_pod < _Ty > :: value || __has_nothrow_copy ( _Ty ) >{ 

};



template < class _Ty >
 struct has_nothrow_default_constructor : _Cat_base < is_pod < _Ty > :: value || __has_nothrow_constructor ( _Ty ) >{ 

};


template < class _Ty >
 struct has_nothrow_copy_constructor : _Cat_base < is_pod < _Ty > :: value || __has_nothrow_copy ( _Ty ) >{ 

};



template < class _Ty >
 struct has_nothrow_assign : _Cat_base < is_pod < _Ty > :: value || __has_nothrow_assign ( _Ty ) >{ 

};


template < class _Ty >
 struct has_virtual_destructor : _Cat_base < __has_virtual_destructor ( _Ty ) >{ 

};


template < class _Ty >
 struct _Has_signed_vals
 : _Cat_base < ( typename remove_cv < _Ty > :: type ) ( - 1 )
  < ( typename remove_cv < _Ty > :: type ) ( 0 ) >{ 

};

template < class _Ty >
 struct is_signed
 : _Cat_base < is_floating_point < _Ty > :: value || is_integral < _Ty > :: value
  && _Has_signed_vals <
   typename _If < is_integral < _Ty > :: value, _Ty, int > :: _Type > :: value >{ 

};


template < class _Ty >
 struct is_unsigned
 : _Cat_base < is_integral < _Ty > :: value
  && ! _Has_signed_vals <
   typename _If < is_integral < _Ty > :: value, _Ty, int > :: _Type > :: value >{ 

};


template < class _Ty >
 struct make_signed{ 

static const size_t _Bytes = sizeof ( _Ty ); 
#line 793
typedef typename _If < is_signed < _Ty > :: value, _Ty, typename _If < _Bytes <= sizeof ( char ), signed char, typename _If < _Bytes <= sizeof ( short ), short, typename _If < _Bytes <= sizeof ( int ), int, typename _If < _Bytes <= sizeof ( long ), long, _Longlong > :: _Type > :: _Type > :: _Type > :: _Type > :: _Type type; 
};


template < class _Ty >
 struct make_unsigned{ 

static const size_t _Bytes = sizeof ( _Ty ); 
#line 808
typedef typename _If < is_unsigned < _Ty > :: value, _Ty, typename _If < _Bytes <= sizeof ( char ), unsigned char, typename _If < _Bytes <= sizeof ( short ), unsigned short, typename _If < _Bytes <= sizeof ( int ), unsigned int, typename _If < _Bytes <= sizeof ( long ), unsigned long, _ULonglong > :: _Type > :: _Type > :: _Type > :: _Type > :: _Type type; 
};


template < class _Ty >
 struct _Get_align{ 

_Ty _Elt0; 
char _Elt1; 
_Ty _Elt2; 
};



template < class _Ty >
 struct alignment_of
 : integral_constant < size_t, ( sizeof ( _Get_align < _Ty > ) - 2 * sizeof ( _Ty ) ) >{ 

};

template < class _Ty >
 struct alignment_of < _Ty & >
 : integral_constant < size_t, ( sizeof ( _Get_align < _Ty * > ) - 2 * sizeof ( _Ty * ) ) >{ 

};
#line 839
template < class _Ty, size_t _Len > union _Align_type{ 

_Ty _Val; 
char _Pad [ _Len ]; 
};

template < size_t _Len, size_t _Align, class _Ty, bool _Ok >
 struct _Aligned;

template < size_t _Len, size_t _Align, class _Ty >
 struct _Aligned < _Len, _Align, _Ty, true >{ 

typedef _Align_type < _Ty, _Len > _Type; 
};

template < size_t _Len, size_t _Align >
 struct _Aligned < _Len, _Align, long, false >{ 

typedef _Align_type < double, _Len > _Type; 
};

template < size_t _Len, size_t _Align >
 struct _Aligned < _Len, _Align, int, false >{ 

typedef typename _Aligned < _Len, _Align, long, _Align == ( sizeof ( _Get_align < long > ) - 2 * sizeof ( long ) ) > :: _Type _Type; 
};

template < size_t _Len, size_t _Align >
 struct _Aligned < _Len, _Align, short, false >{ 

typedef typename _Aligned < _Len, _Align, int, _Align == ( sizeof ( _Get_align < int > ) - 2 * sizeof ( int ) ) > :: _Type _Type; 
};

template < size_t _Len, size_t _Align >
 struct _Aligned < _Len, _Align, char, false >{ 

typedef typename _Aligned < _Len, _Align, short, _Align == ( sizeof ( _Get_align < short > ) - 2 * sizeof ( short ) ) > :: _Type _Type; 
};

template < size_t _Len, size_t _Align >
 struct aligned_storage{ 

typedef typename _Aligned < _Len, _Align, char, _Align == ( sizeof ( _Get_align < char > ) - 2 * sizeof ( char ) ) > :: _Type type; 
};
#line 889
template < class _Ty >
 struct rank
 : integral_constant < size_t, 0 >{ 

};

template < class _Ty, unsigned int _Ix >
 struct rank < _Ty [ _Ix ] >
 : integral_constant < size_t, rank < _Ty > :: value + 1 >{ 

};

template < class _Ty >
 struct rank < _Ty [ ] >
 : integral_constant < size_t, rank < _Ty > :: value + 1 >{ 

};


template < class _Ty, unsigned int _Nx >
 struct _Extent
 : integral_constant < size_t, 0 >{ 

};

template < class _Ty, unsigned int _Ix >
 struct _Extent < _Ty [ _Ix ], 0 >
 : integral_constant < size_t, _Ix >{ 

};

template < class _Ty, unsigned int _Nx, unsigned int _Ix >
 struct _Extent < _Ty [ _Ix ], _Nx >
 : _Extent < _Ty, _Nx - 1 >{ 

};

template < class _Ty, unsigned int _Nx >
 struct _Extent < _Ty [ ], _Nx >
 : _Extent < _Ty, _Nx - 1 >{ 

};

template < class _Ty, unsigned int _Nx = 0 >
 struct extent
 : _Extent < _Ty, _Nx >{ 

};


template < class _Ty1, class _Ty2 >
 struct is_same
 : false_type{ 

};

template < class _Ty1 >
 struct is_same < _Ty1, _Ty1 >
 : true_type{ 

};


template < class _Base, class _Der >
 struct is_base_of : _Cat_base < __is_base_of ( _Base, _Der ) >{ 

};



template < class _Ty >
 struct decay{ 

typedef typename remove_reference < _Ty > :: type _Ty1; 
#line 968
typedef typename _If < is_array < _Ty1 > :: value, typename remove_extent < _Ty1 > :: type *, typename _If < is_function < _Ty1 > :: value, typename add_pointer < _Ty1 > :: type, typename remove_cv < _Ty1 > :: type > :: _Type > :: _Type type; 
};


template < bool _Test,
 class _Type = void >
 struct enable_if{ 

};

template < class _Type >
 struct enable_if < true, _Type >{ 

typedef _Type type; 
};


template < bool _Test,
 class _Ty1,
 class _Ty2 >
 struct conditional{ 

typedef _Ty2 type; 
};

template < class _Ty1,
 class _Ty2 >
 struct conditional < true, _Ty1, _Ty2 >{ 

typedef _Ty1 type; 
};

}


using tr1::add_const;
using tr1::add_cv;
using tr1::add_pointer;
using tr1::add_lvalue_reference;
using tr1::add_reference;
using tr1::add_rvalue_reference;
using tr1::add_volatile;
using tr1::aligned_storage;
using tr1::alignment_of;
using tr1::conditional;
using tr1::decay;
using tr1::enable_if;
using tr1::extent;
using tr1::false_type;
using tr1::has_nothrow_assign;
using tr1::has_nothrow_constructor;
using tr1::has_nothrow_copy;
using tr1::has_nothrow_copy_constructor;
using tr1::has_nothrow_default_constructor;
using tr1::has_trivial_assign;
using tr1::has_trivial_constructor;
using tr1::has_trivial_copy;
using tr1::has_trivial_copy_constructor;
using tr1::has_trivial_default_constructor;
using tr1::has_trivial_destructor;
using tr1::has_virtual_destructor;
using tr1::integral_constant;
using tr1::is_abstract;
using tr1::is_arithmetic;
using tr1::is_array;
using tr1::is_base_of;
using tr1::is_class;
using tr1::is_compound;
using tr1::is_const;
using tr1::is_convertible;
using tr1::is_empty;
using tr1::is_enum;
using tr1::is_floating_point;
using tr1::is_function;
using tr1::is_fundamental;
using tr1::is_integral;
using tr1::is_lvalue_reference;
using tr1::is_member_function_pointer;
using tr1::is_member_object_pointer;
using tr1::is_member_pointer;
using tr1::is_object;
using tr1::is_pod;
using tr1::is_pointer;
using tr1::is_polymorphic;
using tr1::is_reference;
using tr1::is_rvalue_reference;
using tr1::is_same;
using tr1::is_scalar;
using tr1::is_signed;
using tr1::is_standard_layout;
using tr1::is_trivial;
using tr1::is_union;
using tr1::is_unsigned;
using tr1::is_void;
using tr1::is_volatile;
using tr1::make_signed;
using tr1::make_unsigned;
using tr1::rank;
using tr1::remove_all_extents;
using tr1::remove_const;
using tr1::remove_cv;
using tr1::remove_extent;
using tr1::remove_pointer;
using tr1::remove_reference;
using tr1::_Remove_rvalue_reference;
using tr1::remove_volatile;
using tr1::true_type;




template < class _Ty >
 struct _Arithmetic_traits;


template<> struct _Arithmetic_traits< bool>  { 

static const int _Rank = 1; 
}; 


template<> struct _Arithmetic_traits< char>  { 

static const int _Rank = (std::_Arithmetic_traits< bool> ::_Rank + 1); 
}; 


template<> struct _Arithmetic_traits< signed char>  { 

static const int _Rank = std::_Arithmetic_traits< char> ::_Rank; 
}; 


template<> struct _Arithmetic_traits< unsigned char>  { 

static const int _Rank = std::_Arithmetic_traits< char> ::_Rank; 
}; 


template<> struct _Arithmetic_traits< short>  { 

static const int _Rank = (std::_Arithmetic_traits< char> ::_Rank + 1); 
}; 


template<> struct _Arithmetic_traits< unsigned short>  { 

static const int _Rank = std::_Arithmetic_traits< short> ::_Rank; 
}; 


template<> struct _Arithmetic_traits< int>  { 

static const int _Rank = (std::_Arithmetic_traits< short> ::_Rank + 1); 
}; 


template<> struct _Arithmetic_traits< unsigned>  { 

static const int _Rank = std::_Arithmetic_traits< int> ::_Rank; 
}; 


template<> struct _Arithmetic_traits< long>  { 

static const int _Rank = (std::_Arithmetic_traits< int> ::_Rank + 1); 
}; 


template<> struct _Arithmetic_traits< unsigned long>  { 

static const int _Rank = std::_Arithmetic_traits< long> ::_Rank; 
}; 


template<> struct _Arithmetic_traits< __int64>  { 

static const int _Rank = (std::_Arithmetic_traits< long> ::_Rank + 1); 
}; 


template<> struct _Arithmetic_traits< unsigned __int64>  { 

static const int _Rank = std::_Arithmetic_traits< __int64> ::_Rank; 
}; 


template<> struct _Arithmetic_traits< float>  { 

static const int _Rank = (std::_Arithmetic_traits< __int64> ::_Rank + 1); 
}; 


template<> struct _Arithmetic_traits< double>  { 

static const int _Rank = (std::_Arithmetic_traits< float> ::_Rank + 1); 
}; 


template<> struct _Arithmetic_traits< long double>  { 

static const int _Rank = (std::_Arithmetic_traits< double> ::_Rank + 1); 
}; 

template < bool _Unsigned > struct _Pickinteger{ 

typedef int _Type; 
};


template<> struct _Pickinteger< true>  { 

typedef unsigned _Type; 
}; 

template < class _Ty,
 bool _Small >
 struct _Promote_to_int;

template < class _Ty >
 struct _Promote_to_int < _Ty, true >{ 

typedef int _Type; 
};

template < class _Ty >
 struct _Promote_to_int < _Ty, false >{ 

typedef typename _Pickinteger < tr1 :: is_unsigned < _Ty > :: value > :: _Type _Type; 
};

template < class _Ty,
 bool _Small >
 struct _Maybepromote;

template < class _Ty >
 struct _Maybepromote < _Ty, false >{ 

typedef _Ty _Type; 
};

template < class _Ty >
 struct _Maybepromote < _Ty, true >{ 


typedef typename _Promote_to_int < _Ty, sizeof ( _Ty ) < sizeof ( int ) > :: _Type _Type; 
};

template < class _Ty >
 struct _Ipromo{ 

static const bool _Lessthan =
  _Arithmetic_traits < _Ty > :: _Rank < _Arithmetic_traits < int > :: _Rank; 
typedef typename _Maybepromote < _Ty, _Lessthan > :: _Type _Type; 
};

template < class _Ty0,
 class _Ty1,
 bool _Second >
 struct _Common_typeX{ 

typedef _Ty1 _Type; 
};

template < class _Ty0,
 class _Ty1 >
 struct _Common_typeX < _Ty0, _Ty1, false >{ 

typedef _Ty0 _Type; 
};

template < class _Ty0,
 class _Ty1,
 bool _Uns0,
 bool _Uns1 >
 struct _Common_typeY{ 

typedef _Ty0 _Type; 
};

template < class _Ty0,
 class _Ty1 >
 struct _Common_typeY < _Ty0, _Ty1, false, true >{ 

typedef _Ty1 _Type; 
};

template < class _Ty0,
 class _Ty1,
 int _Rank0,
 int _Rank1 >
 struct _Common_type{ 

typedef typename _Common_typeX < _Ty0, _Ty1, _Rank0 < _Rank1 > :: _Type _Type; 
};

template < class _Ty0,
 class _Ty1,
 int _Rank >
 struct _Common_type < _Ty0, _Ty1, _Rank, _Rank >{ 



typedef typename _Common_typeY < _Ty0, _Ty1, tr1 :: is_unsigned < _Ty0 > :: value, tr1 :: is_unsigned < _Ty1 > :: value > :: _Type _Type; 
};

template < class _Ty0,
 class _Ty1 >
 struct common_type{ 

typedef typename _Ipromo < _Ty0 > :: _Type _PromoTy0; 
typedef typename _Ipromo < _Ty1 > :: _Type _PromoTy1; 


typedef typename _Common_type < _PromoTy0, _PromoTy1, _Arithmetic_traits < _PromoTy0 > :: _Rank, _Arithmetic_traits < _PromoTy1 > :: _Rank > :: _Type type; 
};


}
/* Removed pragma: #pragma warning(pop)*/
#line 12 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
/* Removed pragma: #pragma warning(push,3)*/

#pragma warning(disable: 4180 4512) /* Removed pragma: #pragma warning(disable: 4180 4512)*/
#line 1288 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
#pragma pack ( pop )
#line 11 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
#pragma pack ( push, 8 )




namespace std { 
namespace tr1 { 

template < class _Type >
 class reference_wrapper;


template < class _Type >
 struct _Unrefwrap{ 

typedef typename decay < _Type > :: type type; 
};

template < class _Type >
 struct _Unrefwrap < reference_wrapper < _Type > >{ 

typedef _Type & type; 
};

template < class _Type >
 struct _Unrefwrap < const reference_wrapper < _Type > >{ 

typedef _Type & type; 
};

template < class _Type >
 struct _Unrefwrap < volatile reference_wrapper < _Type > >{ 

typedef _Type & type; 
};

template < class _Type >
 struct _Unrefwrap < const volatile reference_wrapper < _Type > >{ 

typedef _Type & type; 
};
#line 60
}
using tr1::_Unrefwrap;


template < class _Ty >
 struct identity{ 

typedef _Ty type; 

const _Ty & operator ( ) ( const _Ty & _Left ) const
  {
  return ( _Left );
  }
};


template < class _Ty > inline
 _Ty && forward ( typename identity < _Ty > :: type & _Arg )
 {
 return ( ( _Ty && ) _Arg );
 }


template < class _Ty > inline
 typename tr1 :: _Remove_reference < _Ty > :: _Type &&
  move ( _Ty && _Arg )
 {
 return ( ( typename tr1 :: _Remove_reference < _Ty > :: _Type && ) _Arg );
 }


template < class _Ty > inline
 typename tr1 :: _Remove_reference < _Ty > :: _Type &&
  _Move ( _Ty && _Arg )
 {
 return ( ( typename tr1 :: _Remove_reference < _Ty > :: _Type && ) _Arg );
 }


template < class _Ty > inline
 void swap ( _Ty & _Left, _Ty & _Right )
 {
 _Ty _Tmp = _Move ( _Left );
 _Left = _Move ( _Right );
 _Right = _Move ( _Tmp );
 }


template < class _Ty > inline
 void _Swap_adl ( _Ty & _Left, _Ty & _Right )
 {
 swap ( _Left, _Right );
 }



template < class _Ty1,
 class _Ty2 >
 struct _Pair_base{ 

typedef _Pair_base < _Ty1, _Ty2 > _Myt; 
typedef _Ty1 first_type; 
typedef _Ty2 second_type; 

 _Pair_base ( )
  : first ( _Ty1 ( ) ), second ( _Ty2 ( ) )
  {
  }

 _Pair_base ( const _Pair_base < _Ty1, _Ty2 > & _Right )
  : first ( _Right . first ), second ( _Right . second )
  {
  }

 _Pair_base ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
  : first ( _Val1 ), second ( _Val2 )
  {
  }

typedef typename tr1 :: remove_reference < _Ty1 > :: type _Ty1x; 
typedef typename tr1 :: remove_reference < _Ty2 > :: type _Ty2x; 

 _Pair_base ( _Ty1x && _Val1, _Ty2x && _Val2 )
  : first ( :: std :: move ( _Val1 ) ),
   second ( :: std :: move ( _Val2 ) )
  {
  }

 _Pair_base ( const _Ty1x & _Val1, _Ty2x && _Val2 )
  : first ( _Val1 ), second ( :: std :: move ( _Val2 ) )
  {
  }

 _Pair_base ( _Ty1x && _Val1, const _Ty2x & _Val2 )
  : first ( :: std :: move ( _Val1 ) ), second ( _Val2 )
  {
  }

template < class _Other1,
  class _Other2 >
  _Pair_base ( _Other1 && _Val1, _Other2 && _Val2 )
  : first ( :: std :: forward < _Other1 > ( _Val1 ) ),
   second ( :: std :: forward < _Other2 > ( _Val2 ) )
  {
  }

_Ty1 first; 
_Ty2 second; 
};

template < class _Ty1,
 class _Ty2 >
 struct pair
  : public _Pair_base < _Ty1, _Ty2 >{ 

typedef _Pair_base < _Ty1, _Ty2 > _Mybase; 

typedef pair < _Ty1, _Ty2 > _Myt; 
typedef _Ty1 first_type; 
typedef _Ty2 second_type; 

 pair ( )
  : _Mybase ( )
  {
  }

 pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
  : _Mybase ( _Val1, _Val2 )
  {
  }

template < class _Other1,
  class _Other2 >
  pair ( pair < _Other1, _Other2 > & _Right )
  : _Mybase ( _Right . first, _Right . second )
  {
  }

template < class _Other1,
  class _Other2 >
  pair ( const pair < _Other1, _Other2 > & _Right )
  : _Mybase ( _Right . first, _Right . second )
  {
  }

void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Swap_adl ( this -> first, _Right . first );
   _Swap_adl ( this -> second, _Right . second );
   }
  }

_Myt & operator = ( const _Myt & _Right )
  {
  this -> first = _Right . first;
  this -> second = _Right . second;
  return ( * this );
  }

typedef typename tr1 :: remove_reference < _Ty1 > :: type _Ty1x; 
typedef typename tr1 :: remove_reference < _Ty2 > :: type _Ty2x; 

 pair ( _Ty1x && _Val1, _Ty2x && _Val2 )
  : _Mybase ( :: std :: move ( _Val1 ),
   :: std :: move ( _Val2 ) )
  {
  }

 pair ( const _Ty1x & _Val1, _Ty2x && _Val2 )
  : _Mybase ( _Val1,
   :: std :: move ( _Val2 ) )
  {
  }

 pair ( _Ty1x && _Val1, const _Ty2x & _Val2 )
  : _Mybase ( :: std :: move ( _Val1 ),
   _Val2 )
  {
  }

template < class _Other1,
  class _Other2 >
  pair ( _Other1 && _Val1, _Other2 && _Val2 )
  : _Mybase ( :: std :: forward < _Other1 > ( _Val1 ),
   :: std :: forward < _Other2 > ( _Val2 ) )
  {
  }

template < class _Other1,
  class _Other2 >
  pair ( pair < _Other1, _Other2 > && _Right )
  : _Mybase ( :: std :: forward < _Other1 > ( _Right . first ),
   :: std :: forward < _Other2 > ( _Right . second ) )
  {
  }

pair & operator = ( pair < _Ty1, _Ty2 > && _Right )
  {
  this -> first = :: std :: move ( _Right . first );
  this -> second = :: std :: move ( _Right . second );
  return ( * this );
  }

void swap ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   this -> first = :: std :: move ( _Right . first );
   this -> second = :: std :: move ( _Right . second );
   }
  }
};



template < class _Ty1,
 class _Ty2 > inline
 void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > & _Right )
 {
 _Left . swap ( _Right );
 }

template < class _Ty1,
 class _Ty2 > inline
 void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > && _Right )
 {
 typedef pair < _Ty1, _Ty2 > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 void swap ( pair < _Ty1, _Ty2 > && _Left, pair < _Ty1, _Ty2 > & _Right )
 {
 typedef pair < _Ty1, _Ty2 > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator == ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first == _Right . first && _Left . second == _Right . second );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator != ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator < ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first < _Right . first ||
  ! ( _Right . first < _Left . first ) && _Left . second < _Right . second );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator > ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Right < _Left );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator <= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator >= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }



template < class _Ty1,
 class _Ty2 > inline
 pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( _Ty1 && _Val1, _Ty2 && _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( :: std :: forward < _Ty1 > ( _Val1 ),
  :: std :: forward < _Ty2 > ( _Val2 ) ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( const _Ty1 & _Val1, _Ty2 && _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( ( typename _Unrefwrap < _Ty1 > :: type ) _Val1,
  :: std :: forward < _Ty2 > ( _Val2 ) ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( _Ty1 && _Val1, const _Ty2 & _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( :: std :: forward < _Ty1 > ( _Val1 ),
  ( typename _Unrefwrap < _Ty2 > :: type ) _Val2 ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( ( typename _Unrefwrap < _Ty1 > :: type ) _Val1,
  ( typename _Unrefwrap < _Ty2 > :: type ) _Val2 ) );
 }


template < class _InIt > inline
 _InIt begin ( const pair < _InIt, _InIt > & _Pair )
 {
 return ( _Pair . first );
 }

template < class _InIt > inline
 _InIt end ( const pair < _InIt, _InIt > & _Pair )
 {
 return ( _Pair . second );
 }



namespace rel_ops { 

template < class _Ty > inline
 bool operator != ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _Ty > inline
 bool operator > ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Right < _Left );
 }

template < class _Ty > inline
 bool operator <= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _Ty > inline
 bool operator >= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
}
}


namespace std { 
namespace tr1 { 

template < class _Tuple >
 struct tuple_size;
template < size_t _Idx,
 class _Tuple >
 struct tuple_element;
template < class _Ty1,
 class _Ty2 >
 struct tuple_size < :: std :: pair < _Ty1, _Ty2 > >{ 

static const int value = 2; 
};

template < int _Idx,
 class _Ty >
 struct _Pair_data;
template < class _Ty1,
 class _Ty2 >
 struct _Pair_data < 0, :: std :: pair < _Ty1, _Ty2 > >{ 

typedef _Ty1 & _Type; 
typedef const _Ty1 & _CType; 

static _Type _Val ( :: std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . first );
  }

static _CType _Val ( const :: std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . first );
  }
};

template < class _Ty1,
 class _Ty2 >
 struct _Pair_data < 1, :: std :: pair < _Ty1, _Ty2 > >{ 

typedef _Ty2 & _Type; 
typedef const _Ty2 & _CType; 

static _Type _Val ( :: std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . second );
  }

static _CType _Val ( const :: std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . second );
  }
};

template < class _Ty1,
 class _Ty2 >
 struct tuple_element < 0, :: std :: pair < _Ty1, _Ty2 > >{ 

typedef _Ty1 type; 
};

template < class _Ty1,
 class _Ty2 >
 struct tuple_element < 1, :: std :: pair < _Ty1, _Ty2 > >{ 

typedef _Ty2 type; 
};

template < int _Idx,
 class _Ty1,
 class _Ty2 >
 typename _Pair_data < _Idx, :: std :: pair < _Ty1, _Ty2 > > :: _Type
  get ( :: std :: pair < _Ty1, _Ty2 > & _Pr )
 {
 return ( _Pair_data < _Idx, :: std :: pair < _Ty1, _Ty2 > > :: _Val ( _Pr ) );
 }

template < int _Idx,
 class _Ty1,
 class _Ty2 >
 typename _Pair_data < _Idx, :: std :: pair < _Ty1, _Ty2 > > :: _CType
  get ( const :: std :: pair < _Ty1, _Ty2 > & _Pr )
 {
 return ( _Pair_data < _Idx, :: std :: pair < _Ty1, _Ty2 > > :: _Val ( _Pr ) );
 }
}
}



namespace std { 
using tr1::get;
using tr1::tuple_element;
using tr1::tuple_size;
}


/* Removed pragma: #pragma warning(pop)*/
#line 11 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
/* Removed pragma: #pragma warning(push,3)*/
#line 541 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
#pragma pack ( pop )
#line 10 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
#pragma pack ( push, 8 )


namespace std { 
#line 23
typedef const __wchar_t *_Dbfile_t; 
typedef unsigned _Dbline_t; 

CPPTEST_IMP__ZSt14_Debug_messagePKwS0_j void __cdecl _Debug_message(const __wchar_t *, const __wchar_t *, unsigned); 
#line 34
struct _Container_base0 { 

CPPTEST_IMP__ZNSt16_Container_base011_Orphan_allEv inline void _Orphan_all() 
{ 
} 

CPPTEST_IMP__ZNSt16_Container_base09_Swap_allERS_ inline void _Swap_all(_Container_base0 &) 
{ 
} 
}; 

struct _Iterator_base0 { 

void _Adopt(const void *) 
{ 
} 

const _Container_base0 *_Getcont() const 
{ 
return (0); 
} 
}; 

struct _Container_base12; 
struct _Iterator_base12; 


struct _Container_proxy { 

_Container_proxy() : _Mycont((0)), _Myfirstiter((0)) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

const _Container_base12 *_Mycont; 
_Iterator_base12 *_Myfirstiter; 
}; 

struct _Container_base12 { 


CPPTEST_IMP__ZNSt17_Container_base12C9Ev inline _Container_base12() : _Myproxy((0)) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt17_Container_base12C9ERKS_ inline _Container_base12(const _Container_base12 &) : _Myproxy((0)) 

{ 
} 

CPPTEST_IMP__ZNSt17_Container_base12aSERKS_ inline _Container_base12 &operator=(const _Container_base12 &) 
{ 
return (*this); 
} 

CPPTEST_IMP__ZNSt17_Container_base12D9Ev inline ~_Container_base12() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(10) 
this->_Orphan_all(); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNKSt17_Container_base1210_GetpfirstEv inline _Iterator_base12 **_Getpfirst() const 
{ 
return ((_Myproxy == 0) ? 0 : (&(_Myproxy->_Myfirstiter))); 
} 

CPPTEST_IMP__ZNSt17_Container_base1211_Orphan_allEv inline void _Orphan_all(); 
CPPTEST_IMP__ZNSt17_Container_base129_Swap_allERS_ inline void _Swap_all(_Container_base12 &); 

_Container_proxy *_Myproxy; 
}; 

struct _Iterator_base12 { 


_Iterator_base12() : _Myproxy((0)), _Mynextiter((0)) 

{ 
} 

_Iterator_base12(const _Iterator_base12 &_Right) : _Myproxy((0)), _Mynextiter((0)) 

{ 
(*this = _Right); 
} 

_Iterator_base12 &operator=(const _Iterator_base12 &_Right) 
{ 
if (_Myproxy != _Right._Myproxy) 
this->_Adopt(_Right._Myproxy->_Mycont);   
return (*this); 
} 

~_Iterator_base12() 
{ 

_Lockit _Lock(3); 
this->_Orphan_me(); 

} 

void _Adopt(const _Container_base12 *_Parent) 
{ 
if (_Parent != 0) 
{ 
_Container_proxy *_Parent_proxy = _Parent->_Myproxy; 


if (_Myproxy != _Parent_proxy) 
{ 
_Lockit _Lock(3); 
this->_Orphan_me(); 
_Mynextiter = _Parent_proxy->_Myfirstiter; 
_Parent_proxy->_Myfirstiter = this; 
_Myproxy = _Parent_proxy; 
}  



}  
} 

void _Clrcont() 
{ 
_Myproxy = 0; 
} 

const _Container_base12 *_Getcont() const 
{ 
return ((_Myproxy == 0) ? 0 : (_Myproxy->_Mycont)); 
} 

_Iterator_base12 **_Getpnext() 
{ 
return (&(_Mynextiter)); 
} 

void _Orphan_me() 
{ 

if (_Myproxy != 0) 
{ 
_Iterator_base12 **_Pnext = &(_Myproxy->_Myfirstiter); 
while (*_Pnext != 0 && *_Pnext != this) 
_Pnext = &((*_Pnext)->_Mynextiter);   

if (*_Pnext == 0) 
_Debug_message(L"\x49\x54\x45\x52\x41\x54\x4f\x52\x20\x4c\x49\x53\x54\x20\x43\x4f\x52\x52\x55\x50\x54\x45\x44\x21", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 181);   
*_Pnext = _Mynextiter; 
_Myproxy = 0; 
}  

} 

_Container_proxy *_Myproxy; 
_Iterator_base12 *_Mynextiter; 
}; 


CPPTEST_IMP__ZNSt17_Container_base1211_Orphan_allEv inline void _Container_base12::_Orphan_all() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 

if ((CPPTEST_STACK_TRACE_IF_COND_INFO(11) , _Myproxy != 0)) 
{ 
CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_0, 12) _Lockit _Lock(3); CPPTEST_STACK_TRACE_STMT_INFO(13) 

for (_Iterator_base12 **_Pnext = &(_Myproxy->_Myfirstiter); *_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter) { CPPTEST_STACK_TRACE_STMT_INFO(14) 

(*_Pnext)->_Myproxy = 0; }  CPPTEST_STACK_TRACE_STMT_INFO(15) 
_Myproxy->_Myfirstiter = 0; CPPTEST_STACK_TRACE_BLOCK_END_INFO(16) 
}  CPPTEST_STACK_TRACE_EXIT_ROUTINE() 

} 

CPPTEST_IMP__ZNSt17_Container_base129_Swap_allERS_ inline void _Container_base12::_Swap_all(_Container_base12 &_Right) 
{ 

_Lockit _Lock(3); 


_Container_proxy *_Temp = _Myproxy; 
_Myproxy = _Right._Myproxy; 
_Right._Myproxy = _Temp; 

if (_Myproxy != 0) 
_Myproxy->_Mycont = (_Container_base12 *)this;   
if (_Right._Myproxy != 0) 
_Right._Myproxy->_Mycont = (_Container_base12 *)(&_Right);   
} 
#line 228
typedef _Container_base12 _Container_base; 
typedef _Iterator_base12 _Iterator_base; 
#line 237
tr1::_No _Has_unchecked_type(...); 

template < class _Ty >
 :: std :: tr1 :: _Yes _Has_unchecked_type ( _Ty *,
  typename _Ty :: _Unchecked_type * = 0 );

template < class _Iter,
 bool >
 struct _Unchecked_helper{ 

typedef _Iter type; 
};

template < class _Iter >
 struct _Unchecked_helper < _Iter, true >{ 

typedef typename _Iter :: _Unchecked_type type; 
};

template < class _Iter >
 struct _Get_unchecked_type{ 


typedef typename _Unchecked_helper < _Iter, ( sizeof ( _Has_unchecked_type ( ( _Iter * ) 0 ) ) == sizeof ( :: std :: tr1 :: _Yes ) ) > :: type type; 
};


template < class _Iter > inline
 _Iter _Unchecked ( _Iter _Src )
 {
 return ( _Src );
 }


template < class _Iter,
 class _UIter > inline
 _Iter & _Rechecked ( _Iter & _Dest, _UIter _Src )
 {
 _Dest = _Src;
 return ( _Dest );
 }


template < class _Iter >
 struct _Is_checked_helper
 : public :: std :: tr1 :: integral_constant < bool, ( sizeof ( _Has_unchecked_type ( ( _Iter * ) 0 ) ) == sizeof ( :: std :: tr1 :: _Yes ) ) >{ 

};


template < class _Iter > inline
 _Is_checked_helper < _Iter > _Is_checked ( _Iter )
 {
 return ( _Is_checked_helper < _Iter > ( ) );
 }



struct input_iterator_tag { 

}; 

struct output_iterator_tag { 

}; 

struct forward_iterator_tag : public input_iterator_tag, public output_iterator_tag { 


}; 

struct bidirectional_iterator_tag : public forward_iterator_tag { 


}; 

struct random_access_iterator_tag : public bidirectional_iterator_tag { 


}; 

struct _Int_iterator_tag { 

}; 


struct _Nonscalar_ptr_iterator_tag { 

}; 
struct _Scalar_ptr_iterator_tag { 

}; 


template < class _Category,
 class _Ty,
 class _Diff = ptrdiff_t,
 class _Pointer = _Ty *,
 class _Reference = _Ty & >
 struct iterator{ 

typedef _Category iterator_category; 
typedef _Ty value_type; 
typedef _Diff difference_type; 
typedef _Diff distance_type; 
typedef _Pointer pointer; 
typedef _Reference reference; 
};

template < class _Category,
 class _Ty,
 class _Diff,
 class _Pointer,
 class _Reference,
 class _Base >
 struct _Iterator012
  : public _Base{ 

typedef _Category iterator_category; 
typedef _Ty value_type; 
typedef _Diff difference_type; 
typedef _Diff distance_type; 
typedef _Pointer pointer; 
typedef _Reference reference; 
};

struct _Outit : public iterator< output_iterator_tag, void, void, void, void>  { 



}; 


template < class _Iter >
 struct iterator_traits{ 

typedef typename _Iter :: iterator_category iterator_category; 
typedef typename _Iter :: value_type value_type; 
typedef typename _Iter :: difference_type difference_type; 
typedef difference_type distance_type; 
typedef typename _Iter :: pointer pointer; 
typedef typename _Iter :: reference reference; 
};

template < class _Ty >
 struct iterator_traits < _Ty * >{ 

typedef random_access_iterator_tag iterator_category; 
typedef _Ty value_type; 
typedef ptrdiff_t difference_type; 
typedef ptrdiff_t distance_type; 
typedef _Ty * pointer; 
typedef _Ty & reference; 
};

template < class _Ty >
 struct iterator_traits < const _Ty * >{ 

typedef random_access_iterator_tag iterator_category; 
typedef _Ty value_type; 
typedef ptrdiff_t difference_type; 
typedef ptrdiff_t distance_type; 
typedef const _Ty * pointer; 
typedef const _Ty & reference; 
};

template<> struct iterator_traits< bool>  { 

typedef _Int_iterator_tag iterator_category; 
}; 

template<> struct iterator_traits< char>  { 

typedef _Int_iterator_tag iterator_category; 
}; 

template<> struct iterator_traits< signed char>  { 

typedef _Int_iterator_tag iterator_category; 
}; 

template<> struct iterator_traits< unsigned char>  { 

typedef _Int_iterator_tag iterator_category; 
}; 


template<> struct iterator_traits< __wchar_t>  { 

typedef _Int_iterator_tag iterator_category; 
}; 


template<> struct iterator_traits< short>  { 

typedef _Int_iterator_tag iterator_category; 
}; 

template<> struct iterator_traits< unsigned short>  { 

typedef _Int_iterator_tag iterator_category; 
}; 

template<> struct iterator_traits< int>  { 

typedef _Int_iterator_tag iterator_category; 
}; 

template<> struct iterator_traits< unsigned>  { 

typedef _Int_iterator_tag iterator_category; 
}; 

template<> struct iterator_traits< long>  { 

typedef _Int_iterator_tag iterator_category; 
}; 

template<> struct iterator_traits< unsigned long>  { 

typedef _Int_iterator_tag iterator_category; 
}; 


template<> struct iterator_traits< __int64>  { 

typedef _Int_iterator_tag iterator_category; 
}; 

template<> struct iterator_traits< unsigned __int64>  { 

typedef _Int_iterator_tag iterator_category; 
}; 



template < class _Iter > inline
 typename iterator_traits < _Iter > :: iterator_category
  _Iter_cat ( const _Iter & )
 {
 typename iterator_traits < _Iter > :: iterator_category _Cat;
 return ( _Cat );
 }


template < class _Iter1,
 class _Iter2 > inline
 _Nonscalar_ptr_iterator_tag _Ptr_cat ( _Iter1 &, _Iter2 & )
 {
 _Nonscalar_ptr_iterator_tag _Cat;
 return ( _Cat );
 }

template < class _Elem1,
 class _Elem2 >
 struct _Ptr_cat_helper{ 

typedef _Nonscalar_ptr_iterator_tag _Type; 
};

template < class _Elem >
 struct _Ptr_cat_helper < _Elem, _Elem >{ 




typedef typename :: std :: tr1 :: conditional < :: std :: tr1 :: is_scalar < _Elem > :: value, _Scalar_ptr_iterator_tag, _Nonscalar_ptr_iterator_tag > :: type _Type; 
};

template < class _Anything >
 struct _Ptr_cat_helper < _Anything *, const _Anything * >{ 

typedef _Scalar_ptr_iterator_tag _Type; 
};

template < class _Elem1,
 class _Elem2 > inline
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: _Type
  _Ptr_cat ( _Elem1 *, _Elem2 * )
 {
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: _Type _Cat;
 return ( _Cat );
 }

template < class _Elem1,
 class _Elem2 > inline
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: _Type
  _Ptr_cat ( const _Elem1 *, _Elem2 * )
 {
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: _Type _Cat;
 return ( _Cat );
 }
#line 588
template < class _Ty1, class _Ty2 > inline
 bool _Debug_lt ( const _Ty1 & _Left, const _Ty2 & _Right,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( ! ( _Left < _Right ) )
  return ( false );
 else if ( _Right < _Left )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x70\x65\x72\x61\x74\x6f\x72\x3c", _File, _Line );
 return ( true );
 }

template < class _Ty1, class _Ty2 > inline
 bool _Debug_lt ( const _Ty1 & _Left, _Ty2 & _Right,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( ! ( _Left < _Right ) )
  return ( false );
 else if ( _Right < _Left )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x70\x65\x72\x61\x74\x6f\x72\x3c", _File, _Line );
 return ( true );
 }

template < class _Ty1, class _Ty2 > inline
 bool _Debug_lt ( _Ty1 & _Left, const _Ty2 & _Right,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( ! ( _Left < _Right ) )
  return ( false );
 else if ( _Right < _Left )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x70\x65\x72\x61\x74\x6f\x72\x3c", _File, _Line );
 return ( true );
 }

template < class _Ty1, class _Ty2 > inline
 bool _Debug_lt ( _Ty1 & _Left, _Ty2 & _Right,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( ! ( _Left < _Right ) )
  return ( false );
 else if ( _Right < _Left )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x70\x65\x72\x61\x74\x6f\x72\x3c", _File, _Line );
 return ( true );
 }


template < class _Pr, class _Ty1, class _Ty2 > inline
 bool _Debug_lt_pred ( _Pr _Pred,
  const _Ty1 & _Left, const _Ty2 & _Right,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( ! _Pred ( _Left, _Right ) )
  return ( false );
 else if ( _Pred ( _Right, _Left ) )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x70\x65\x72\x61\x74\x6f\x72\x3c", _File, _Line );
 return ( true );
 }

template < class _Pr, class _Ty1, class _Ty2 > inline
 bool _Debug_lt_pred ( _Pr _Pred,
  const _Ty1 & _Left, _Ty2 & _Right,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( ! _Pred ( _Left, _Right ) )
  return ( false );
 else if ( _Pred ( _Right, _Left ) )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x70\x65\x72\x61\x74\x6f\x72\x3c", _File, _Line );
 return ( true );
 }

template < class _Pr, class _Ty1, class _Ty2 > inline
 bool _Debug_lt_pred ( _Pr _Pred,
  _Ty1 & _Left, const _Ty2 & _Right,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( ! _Pred ( _Left, _Right ) )
  return ( false );
 else if ( _Pred ( _Right, _Left ) )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x70\x65\x72\x61\x74\x6f\x72\x3c", _File, _Line );
 return ( true );
 }

template < class _Pr, class _Ty1, class _Ty2 > inline
 bool _Debug_lt_pred ( _Pr _Pred,
  _Ty1 & _Left, _Ty2 & _Right,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( ! _Pred ( _Left, _Right ) )
  return ( false );
 else if ( _Pred ( _Right, _Left ) )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x70\x65\x72\x61\x74\x6f\x72\x3c", _File, _Line );
 return ( true );
 }


template < class _InIt > inline
 void _Debug_pointer ( _InIt &, _Dbfile_t, _Dbline_t )
 {
 }

template < class _Ty > inline
 void _Debug_pointer ( const _Ty * _First, _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( _First == 0 )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6e\x75\x6c\x6c\x20\x70\x6f\x69\x6e\x74\x65\x72", _File, _Line );
 }

template < class _Ty > inline
 void _Debug_pointer ( _Ty * _First, _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( _First == 0 )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6e\x75\x6c\x6c\x20\x70\x6f\x69\x6e\x74\x65\x72", _File, _Line );
 }


template < class _InIt > inline
 void _Debug_range2 ( _InIt _First, _InIt _Last, _Dbfile_t, _Dbline_t,
  input_iterator_tag )
 {
 bool _Ans = _First == _Last;
 _Ans = _Ans;
 }

template < class _RanIt > inline
 void _Debug_range2 ( _RanIt _First, _RanIt _Last,
  _Dbfile_t _File, _Dbline_t _Line,
  random_access_iterator_tag )
 {
 if ( _First != _Last )
  {
  _Debug_pointer ( _First, _File, _Line );
  _Debug_pointer ( _Last, _File, _Line );
  if ( _Last < _First )
   _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x72\x61\x6e\x67\x65", _File, _Line );
  }
 }

template < class _InIt > inline
 void _Debug_range ( _InIt _First, _InIt _Last,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 _Debug_range2 ( _First, _Last, _File, _Line, _Iter_cat ( _First ) );
 }


template < class _InIt > inline
 void _Debug_order2 ( _InIt, _InIt,
  _Dbfile_t, _Dbline_t, input_iterator_tag )
 {
 }

template < class _FwdIt > inline
 void _Debug_order2 ( _FwdIt _First, _FwdIt _Last,
  _Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag )
 {
 for ( _FwdIt _Next = _First; _First != _Last && ++ _Next != _Last; ++ _First )
  if ( _Debug_lt ( * _Next, * _First, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 743 ) )
   _Debug_message ( L"\x73\x65\x71\x75\x65\x6e\x63\x65\x20\x6e\x6f\x74\x20\x6f\x72\x64\x65\x72\x65\x64", _File, _Line );
 }

template < class _InIt > inline
 void _Debug_order ( _InIt _First, _InIt _Last,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 _Debug_range ( _First, _Last, _File, _Line );
 _Debug_order2 ( _First, _Last, _File, _Line, _Iter_cat ( _First ) );
 }


template < class _InIt,
 class _Pr > inline
 void _Debug_order2 ( _InIt, _InIt, _Pr,
  _Dbfile_t, _Dbline_t, input_iterator_tag )
 {
 }

template < class _FwdIt,
 class _Pr > inline
 void _Debug_order2 ( _FwdIt _First, _FwdIt _Last, _Pr _Pred,
  _Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag )
 {
 for ( _FwdIt _Next = _First; _First != _Last && ++ _Next != _Last; ++ _First )
  if ( _Debug_lt_pred ( _Pred, * _Next, * _First, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 769 ) )
   _Debug_message ( L"\x73\x65\x71\x75\x65\x6e\x63\x65\x20\x6e\x6f\x74\x20\x6f\x72\x64\x65\x72\x65\x64", _File, _Line );
 }

template < class _InIt,
 class _Pr > inline
 void _Debug_order ( _InIt _First, _InIt _Last, _Pr _Pred,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 _Debug_range ( _First, _Last, _File, _Line );
 _Debug_pointer ( _Pred, _File, _Line );
 _Debug_order2 ( _First, _Last, _Pred, _File, _Line, _Iter_cat ( _First ) );
 }
#line 787
template < class _Iter > inline
 typename iterator_traits < _Iter > :: value_type * _Val_type ( _Iter )
 {
 return ( 0 );
 }


template < class _InIt,
 class _Diff > inline
 void advance ( _InIt & _Where, _Diff _Off )
 {
 _Advance ( _Where, _Off, _Iter_cat ( _Where ) );
 }

template < class _InIt,
 class _Diff > inline
 void _Advance ( _InIt & _Where, _Diff _Off, input_iterator_tag )
 {





 for (; 0 < _Off; -- _Off )
  ++ _Where;
 }

template < class _FI,
 class _Diff > inline
 void _Advance ( _FI & _Where, _Diff _Off, forward_iterator_tag )
 {





 for (; 0 < _Off; -- _Off )
  ++ _Where;
 }

template < class _BI,
 class _Diff > inline
 void _Advance ( _BI & _Where, _Diff _Off, bidirectional_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  ++ _Where;
 for (; _Off < 0; ++ _Off )
  -- _Where;
 }

template < class _RI,
 class _Diff > inline
 void _Advance ( _RI & _Where, _Diff _Off, random_access_iterator_tag )
 {
 _Where += _Off;
 }



template < class _Iter > inline
 typename iterator_traits < _Iter > :: difference_type
  * _Dist_type ( _Iter )
 {
 return ( 0 );
 }


template < class _InIt,
 class _Diff > inline
  void _Distance2 ( _InIt _First, _InIt _Last, _Diff & _Off,
   input_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }

template < class _FwdIt,
 class _Diff > inline
  void _Distance2 ( _FwdIt _First, _FwdIt _Last, _Diff & _Off,
   forward_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }

template < class _BidIt,
 class _Diff > inline
  void _Distance2 ( _BidIt _First, _BidIt _Last, _Diff & _Off,
   bidirectional_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }

template < class _RanIt,
 class _Diff > inline
  void _Distance2 ( _RanIt _First, _RanIt _Last, _Diff & _Off,
   random_access_iterator_tag )
 {

 if ( _First != _Last )
  {
  _Debug_pointer ( _First, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 889 );
  _Debug_pointer ( _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 890 );
  }


 _Off += _Last - _First;
 }

template < class _InIt > inline
 typename iterator_traits < _InIt > :: difference_type
  distance ( _InIt _First, _InIt _Last )
 {
 typename iterator_traits < _InIt > :: difference_type _Off = 0;
 _Distance2 ( _First, _Last, _Off, _Iter_cat ( _First ) );
 return ( _Off );
 }

template < class _InIt,
 class _Diff > inline
  void _Distance ( _InIt _First, _InIt _Last, _Diff & _Off )
 {
 _Distance2 ( _First, _Last, _Off, _Iter_cat ( _First ) );
 }



template < class _InIt,
 class _Diff > inline
  _InIt _Increment ( _InIt _First, _Diff _Off,
   input_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  ++ _First;
 return ( _First );
 }

template < class _FwdIt,
 class _Diff > inline
  _FwdIt _Increment ( _FwdIt _First, _Diff _Off,
   forward_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  ++ _First;
 return ( _First );
 }

template < class _BidIt,
 class _Diff > inline
  _BidIt _Increment ( _BidIt _First, _Diff _Off,
   bidirectional_iterator_tag )
 {
 for (; _Off < 0; ++ _Off )
  -- _First;
 for (; 0 < _Off; -- _Off )
  ++ _First;
 return ( _First );
 }

template < class _RanIt,
 class _Diff > inline
  _RanIt _Increment ( _RanIt _First, _Diff _Off,
   random_access_iterator_tag )
 {
 return ( _First + _Off );
 }

template < class _InIt > inline
 _InIt next ( _InIt _First,
  typename iterator_traits < _InIt > :: difference_type _Off = 1 )
 {
 return ( _Increment ( _First, _Off, _Iter_cat ( _First ) ) );
 }

template < class _InIt > inline
 _InIt prev ( _InIt _First,
  typename iterator_traits < _InIt > :: difference_type _Off = 1 )
 {
 return ( _Increment ( _First, - _Off, _Iter_cat ( _First ) ) );
 }

template < class _Container > inline
 typename _Container :: iterator begin ( _Container & _Cont )
 {
 return ( _Cont . begin ( ) );
 }

template < class _Container > inline
 typename _Container :: const_iterator begin ( const _Container & _Cont )
 {
 return ( _Cont . begin ( ) );
 }

template < class _Container > inline
 typename _Container :: iterator end ( _Container & _Cont )
 {
 return ( _Cont . end ( ) );
 }

template < class _Container > inline
 typename _Container :: const_iterator end ( const _Container & _Cont )
 {
 return ( _Cont . end ( ) );
 }

template < class _Ty,
 size_t _Size > inline
 _Ty * begin ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( & _Array [ 0 ] );
 }

template < class _Ty,
 size_t _Size > inline
 _Ty * end ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( & _Array [ 0 ] + _Size );
 }



template < class _RanIt,
 class _Base >
 class _Revranit
  : public _Base{ 


public: typedef _Revranit < _RanIt, _Base > _Myt; 
typedef typename _Base :: difference_type difference_type; 
typedef typename _Base :: pointer pointer; 
typedef typename _Base :: reference reference; 
typedef _RanIt iterator_type; 

 _Revranit ( )
  {
  }

explicit _Revranit ( _RanIt _Right )
  : current ( _Right )
  {
  }

template < class _RanIt2,
  class _Base2 >
  _Revranit ( const _Revranit < _RanIt2, _Base2 > & _Right )
  : current ( _Right . base ( ) )
  {
  }

_RanIt base ( ) const
  {
  return ( current );
  }

reference operator * ( ) const
  {
  _RanIt _Tmp = current;
  return ( * -- _Tmp );
  }

pointer operator -> ( ) const
  {
  return ( & * * this );
  }

_Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

_Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

_Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

_Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

template < class _RanIt2,
  class _Base2 >
  bool _Equal ( const _Revranit < _RanIt2, _Base2 > & _Right ) const
  {
  return ( current == _Right . base ( ) );
  }



_Myt & operator += ( difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

_Myt operator + ( difference_type _Off ) const
  {
  return ( _Myt ( current - _Off ) );
  }

_Myt & operator -= ( difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

_Myt operator - ( difference_type _Off ) const
  {
  return ( _Myt ( current + _Off ) );
  }

reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

template < class _RanIt2,
  class _Base2 >
  bool _Less ( const _Revranit < _RanIt2, _Base2 > & _Right ) const
  {
  return ( _Right . base ( ) < current );
  }

difference_type operator - ( const _Myt & _Right ) const
  {
  return ( _Right . base ( ) - current );
  }


protected: _RanIt current; 
};


template < class _RanIt,
 class _Base,
 class _Diff > inline
 _Revranit < _RanIt, _Base >
  operator + ( _Diff _Off,
  const _Revranit < _RanIt, _Base > & _Right )
 {
 return ( _Right + _Off );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 typename _Base1 :: difference_type operator - (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Right . base ( ) - _Left . base ( ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator == (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator != (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator < (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator > (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Right < _Left );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator <= (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator >= (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }


template < class _RanIt >
 class reverse_iterator
  : public _Revranit < _RanIt, iterator <
   typename iterator_traits < _RanIt > :: iterator_category,
   typename iterator_traits < _RanIt > :: value_type,
   typename iterator_traits < _RanIt > :: difference_type,
   typename iterator_traits < _RanIt > :: pointer,
   typename iterator_traits < _RanIt > :: reference > >{ 

typedef reverse_iterator < _RanIt > _Myt; 
#line 1235
typedef _Revranit < _RanIt, iterator < typename iterator_traits < _RanIt > :: iterator_category, typename iterator_traits < _RanIt > :: value_type, typename iterator_traits < _RanIt > :: difference_type, typename iterator_traits < _RanIt > :: pointer, typename iterator_traits < _RanIt > :: reference > > _Mybase; 


public: typedef typename iterator_traits < _RanIt > :: difference_type difference_type; 
typedef typename iterator_traits < _RanIt > :: pointer pointer; 
typedef typename iterator_traits < _RanIt > :: reference reference; 
typedef _RanIt iterator_type; 

 reverse_iterator ( )
  {
  }

explicit reverse_iterator ( _RanIt _Right )
  : _Mybase ( _Right )
  {
  }

template < class _Other >
  reverse_iterator ( const reverse_iterator < _Other > & _Right )
  : _Mybase ( _Right . base ( ) )
  {
  }

 reverse_iterator ( _Mybase _Right )
  : _Mybase ( _Right )
  {
  }

_Myt & operator ++ ( )
  {
  ++ * ( ( _Mybase * ) this );
  return ( * this );
  }

_Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

_Myt & operator -- ( )
  {
  -- * ( ( _Mybase * ) this );
  return ( * this );
  }

_Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

_Myt & operator += ( difference_type _Off )
  {
  * ( ( _Mybase * ) this ) += _Off;
  return ( * this );
  }

_Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

_Myt & operator -= ( difference_type _Off )
  {
  * ( ( _Mybase * ) this ) -= _Off;
  return ( * this );
  }

_Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }
};

template < class _RanIt >
 struct _Is_checked_helper < reverse_iterator < _RanIt > >
 : public _Is_checked_helper < _RanIt >{ 

};


template < class _RanIt,
 class _Diff > inline
 reverse_iterator < _RanIt > operator + ( _Diff _Off,
  const reverse_iterator < _RanIt > & _Right )
 {
 return ( _Right + _Off );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 typename reverse_iterator < _RanIt1 > :: difference_type
  operator - ( const reverse_iterator < _RanIt1 > & _Left,
   const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Right . base ( ) - _Left . base ( ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool operator == ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool operator != ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool operator < ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool operator > ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Right < _Left );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool operator <= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool operator >= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }


template < class _BidIt,
 class _Ty,
 class _Reference = _Ty &,
 class _Pointer = _Ty *,
 class _Diff = ptrdiff_t >
 class reverse_bidirectional_iterator
  : public iterator < bidirectional_iterator_tag, _Ty, _Diff,
   _Pointer, _Reference >{ 



public: typedef reverse_bidirectional_iterator < _BidIt, _Ty, _Reference, _Pointer, _Diff > _Myt; 
typedef _BidIt iterator_type; 

 reverse_bidirectional_iterator ( )
  {
  }

explicit reverse_bidirectional_iterator ( _BidIt _Right )
  : current ( _Right )
  {
  }

_BidIt base ( ) const
  {
  return ( current );
  }

_Reference operator * ( ) const
  {
  _BidIt _Tmp = current;
  return ( * -- _Tmp );
  }

_Pointer operator -> ( ) const
  {
  _Reference _Tmp = * * this;
  return ( & _Tmp );
  }

_Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

_Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

_Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

_Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

bool operator == ( const _Myt & _Right ) const
  {
  return ( current == _Right . current );
  }

bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }


protected: _BidIt current; 
};


template < class _BidIt,
 class _BidIt2 = _BidIt >
 class _Revbidit
  : public iterator <
   typename iterator_traits < _BidIt > :: iterator_category,
   typename iterator_traits < _BidIt > :: value_type,
   typename iterator_traits < _BidIt > :: difference_type,
   typename iterator_traits < _BidIt > :: pointer,
   typename iterator_traits < _BidIt > :: reference >{ 


public: typedef _Revbidit < _BidIt, _BidIt2 > _Myt; 
typedef typename iterator_traits < _BidIt > :: difference_type _Diff; 
typedef typename iterator_traits < _BidIt > :: pointer _Pointer; 
typedef typename iterator_traits < _BidIt > :: reference _Reference; 
typedef _BidIt iterator_type; 

 _Revbidit ( )
  {
  }

explicit _Revbidit ( _BidIt _Right )
  : current ( _Right )
  {
  }

 _Revbidit ( const _Revbidit < _BidIt2 > & _Other )
  : current ( _Other . base ( ) )
  {
  }

_BidIt base ( ) const
  {
  return ( current );
  }

_Reference operator * ( ) const
  {
  _BidIt _Tmp = current;
  return ( * -- _Tmp );
  }

_Pointer operator -> ( ) const
  {
  _Reference _Tmp = * * this;
  return ( & _Tmp );
  }

_Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

_Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

_Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

_Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

bool operator == ( const _Myt & _Right ) const
  {
  return ( current == _Right . current );
  }

bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }


protected: _BidIt current; 
};


template < class _Ty,
 size_t _Size >
 class _Array_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty &,
   _Iterator_base >{ 


public: typedef _Array_const_iterator < _Ty, _Size > _Myiter; 
typedef random_access_iterator_tag iterator_category; 

typedef _Ty value_type; 
typedef size_t size_type; 
typedef ptrdiff_t difference_type; 
typedef const _Ty * pointer; 
typedef const _Ty & reference; 
enum { _EEN_SIZE = _Size}; 
enum { _EEN_IDL =
  2
}; 
#line 1706
 _Array_const_iterator ( )
  {
  _Ptr = 0;
  _Idx = 0;
  }

explicit _Array_const_iterator ( pointer _Parg, size_t _Off = 0 )
  {
  _Ptr = _Parg;
  _Idx = _Off;
  }

typedef pointer _Unchecked_type; 

_Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  _Idx = _Right - _Ptr;
  return ( * this );
  }

_Unchecked_type _Unchecked ( ) const
  {
  return ( _Ptr + _Idx );
  }

reference operator * ( ) const
  {

  if ( _Ptr == 0
   || _Size <= _Idx )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62\x6c" L"\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1737 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1738, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1738, 0 ); };
   }






                              ;

  return ( _Ptr [ _Idx ] );
  }

pointer operator -> ( ) const
  {
  return ( & * * this );
  }

_Myiter & operator ++ ( )
  {

  if ( _Ptr == 0
   || _Size <= _Idx )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c\x65" L"", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1762 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1763, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1763, 0 ); };
   }






  ++ _Idx;
  return ( * this );
  }

_Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

_Myiter & operator -- ( )
  {

  if ( _Ptr == 0
   || _Idx <= 0 )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c\x65" L"", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1788 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1789, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1789, 0 ); };
   }






  -- _Idx;
  return ( * this );
  }

_Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

_Myiter & operator += ( difference_type _Off )
  {

  if ( _Size < _Idx + _Off )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x2b\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72" L"\x61\x6e\x67\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1813 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1814, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1814, 0 ); };
   }





  _Idx += _Off;
  return ( * this );
  }

_Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

_Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

_Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

difference_type operator - ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Idx < _Right . _Idx
   ? - ( difference_type ) ( _Right . _Idx - _Idx )
   : ( difference_type ) _Idx - _Right . _Idx );
  }

reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

bool operator == ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Idx == _Right . _Idx );
  }

bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

bool operator < ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Idx < _Right . _Idx );
  }

bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }


void _Compat ( const _Myiter & _Right ) const
  {
  if ( _Ptr != _Right . _Ptr )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1892 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Invalid Argument" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1893, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x49\x6e\x76\x61\x6c\x69\x64\x20" L"\x41\x72\x67\x75\x6d\x65\x6e\x74\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 1893, 0 ); };
   }
  }
#line 1904
pointer _Ptr; 
size_t _Idx; 

};

template < class _Ty,
 size_t _Size > inline
 typename _Array_const_iterator < _Ty, _Size > :: _Unchecked_type
  _Unchecked ( _Array_const_iterator < _Ty, _Size > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }

template < class _Ty,
 size_t _Size > inline
 _Array_const_iterator < _Ty, _Size > &
  _Rechecked ( _Array_const_iterator < _Ty, _Size > & _Iter,
   typename _Array_const_iterator < _Ty, _Size >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }

template < class _Ty,
 size_t _Size > inline
 _Array_const_iterator < _Ty, _Size > operator + (
  typename _Array_const_iterator < _Ty, _Size > :: difference_type _Off,
  _Array_const_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }


template < class _Ty,
 size_t _Size >
 class _Array_iterator
  : public _Array_const_iterator < _Ty, _Size >{ 


public: typedef _Array_iterator < _Ty, _Size > _Myiter; 
typedef _Array_const_iterator < _Ty, _Size > _Mybase; 
typedef random_access_iterator_tag iterator_category; 

typedef _Ty value_type; 
typedef size_t size_type; 
typedef ptrdiff_t difference_type; 
typedef _Ty * pointer; 
typedef _Ty & reference; 

 _Array_iterator ( )
  {
  }

explicit _Array_iterator ( pointer _Parg, size_t _Off = 0 )
  : _Mybase ( _Parg, _Off )
  {
  }
enum { _EEN_SIZE = _Size}; 
enum { _EEN_IDL =
  2
}; 

typedef pointer _Unchecked_type; 

_Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  ( ( _Mybase * ) this ) -> _Rechecked ( _Right );
  return ( * this );
  }

_Unchecked_type _Unchecked ( ) const
  {
  return ( ( pointer ) ( ( _Mybase * ) this ) -> _Unchecked ( ) );
  }

reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

pointer operator -> ( ) const
  {
  return ( & * * this );
  }

_Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

_Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

_Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

_Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

_Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

_Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

_Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

_Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
};

template < class _Ty,
 size_t _Size > inline
 typename _Array_iterator < _Ty, _Size > :: _Unchecked_type
  _Unchecked ( _Array_iterator < _Ty, _Size > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }

template < class _Ty,
 size_t _Size > inline
 _Array_iterator < _Ty, _Size > &
  _Rechecked ( _Array_iterator < _Ty, _Size > & _Iter,
   typename _Array_iterator < _Ty, _Size >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }

template < class _Ty,
 size_t _Size > inline
 _Array_iterator < _Ty, _Size > operator + (
  typename _Array_iterator < _Ty, _Size > :: difference_type _Off,
  _Array_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }



template < class _Ty > inline
 const _Ty & ( max ) ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Debug_lt ( _Left, _Right, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2080 ) ? _Right : _Left );
 }


template < class _Ty,
 class _Pr > inline
 const _Ty & ( max ) ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred )
 {
 return ( _Debug_lt_pred ( _Pred, _Left, _Right, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2088 ) ? _Right : _Left );
 }


template < class _Ty > inline
 const _Ty & ( min ) ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Debug_lt ( _Right, _Left, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2095 ) ? _Right : _Left );
 }


template < class _Ty,
 class _Pr > inline
 const _Ty & ( min ) ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred )
 {
 return ( _Debug_lt_pred ( _Pred, _Right, _Left, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2103 ) ? _Right : _Left );
 }




template < class _Ty > inline
 pair < const _Ty, const _Ty >
  minmax ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Right < _Left
  ? pair < const _Ty, const _Ty > ( _Right, _Left )
  : pair < const _Ty, const _Ty > ( _Left, _Right ) );
 }


template < class _Ty,
 class _Pr > inline
 pair < const _Ty, const _Ty >
  minmax ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred )
 {
 return ( _Pred ( _Right, _Left )
  ? pair < const _Ty, const _Ty > ( _Right, _Left )
  : pair < const _Ty, const _Ty > ( _Left, _Right ) );
 }


template < class _FwdIt1,
 class _FwdIt2 > inline
 void iter_swap ( _FwdIt1 _Left, _FwdIt2 _Right )
 {
 swap ( * _Left, * _Right );
 }


template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ++ _First )
  * _Dest = * _First;
 return ( _Dest );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Copy_impl ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2180
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, input_iterator_tag, output_iterator_tag )
 {
 return ( _Copy_impl ( _First, _Last,
  _Dest ) );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag )
 {
 _OutIt _Ans = _Dest + ( _Last - _First );
 _Copy_impl ( _First, _Last,
  _Unchecked ( _Dest ) );
 return ( _Ans );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, :: std :: tr1 :: true_type )
 {
 return ( _Copy_impl ( _First, _Last,
  _Dest, _Iter_cat ( _First ), _Iter_cat ( _Dest ) ) );
 }

template < class _InIt,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, :: std :: tr1 :: false_type )
 {
 return ( _Copy_impl ( _First, _Last,
  _Dest, _Iter_cat ( _First ), _Iter_cat ( _Dest ) ) );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2224 );
 _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2225 );
 return ( _Copy_impl ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Is_checked ( _Dest ) ) );
 }

template < class _InIt,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * copy ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( _Unchecked (
  :: std :: copy ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ) ) ) );
 }




template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag )
 {
 * _Dest = * _First;
 while ( 0 < -- _Count )
  * ++ _Dest = * ++ _First;
 return ( ++ _Dest );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag )
 {
 for (; 0 < _Count; -- _Count, ++ _Dest, ++ _First )
  * _Dest = * _First;
 return ( _Dest );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 return ( _Copy_n ( _First, _Count,
  _Dest, _Iter_cat ( _First ) ) );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest )
 {
 return ( _Copy_n ( _First, _Count,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2314
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n2 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, output_iterator_tag )
 {
 return ( _Copy_n ( _First, _Count,
  _Dest ) );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n2 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, random_access_iterator_tag )
 {
 _OutIt _Ans = _Dest + _Count;
 _Copy_n ( _First, _Count,
  _Unchecked ( _Dest ) );
 return ( _Ans );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n1 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag )
 {
 return ( _Copy_n2 ( _First, _Count,
  _Dest, _Iter_cat ( _Dest ) ) );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n1 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, random_access_iterator_tag )
 {
 _InIt _Last = _First + _Count;
 _Last = _Last;
 return ( _Copy_n2 ( _Unchecked ( _First ), _Count,
  _Dest, _Iter_cat ( _Dest ) ) );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, :: std :: tr1 :: true_type )
 {
 return ( _Copy_n1 ( _First, _Count,
  _Dest, _Iter_cat ( _First ) ) );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, :: std :: tr1 :: false_type )
 {
 return ( _Copy_n1 ( _First, _Count,
  _Dest, _Iter_cat ( _First ) ) );
 }

template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest )
 {
 _Debug_pointer ( _First, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2385 );
 _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2386 );
 if ( _Count <= 0 )
  return ( _Dest );
 else
  return ( _Copy_n ( _First, _Count,
   _Dest, _Is_checked ( _Dest ) ) );
 }

template < class _InTy,
 size_t _InSize,
 class _Diff,
 class _OutIt > inline
 _OutIt copy_n ( _InTy ( & _First ) [ _InSize ], _Diff _Count,
  _OutIt _Dest )
 {
 return ( :: std :: copy_n ( _Array_iterator < _InTy, _InSize > ( _First ), _Count,
  _Dest ) );
 }

template < class _InIt,
 class _Diff,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * copy_n ( _InIt _First, _Diff _Count,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( _Unchecked (
  :: std :: copy_n ( _First, _Count,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ) ) ) );
 }

template < class _InTy,
 size_t _InSize,
 class _Diff,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * copy_n ( _InTy ( & _First ) [ _InSize ], _Diff _Count,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( _Unchecked (
  :: std :: copy_n ( _Array_iterator < _InTy, _InSize > ( _First ), _Count,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ) ) ) );
 }
#line 2434
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = * -- _Last;
 return ( _Dest );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_backward ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest - _Count, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest - _Count );
 }

template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Copy_backward ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2476
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, :: std :: tr1 :: true_type )
 {
 return ( _Copy_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest ) );
 }

template < class _BidIt1,
 class _BidIt2 > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 _BidIt2 _Copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, :: std :: tr1 :: false_type )
 {
 return ( _Copy_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest ) );
 }

template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2500 );
 _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2501 );
 return ( _Copy_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Is_checked ( _Dest ) ) );
 }



template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ++ _First )
  * _Dest = :: std :: move ( * _First );
 return ( _Dest );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Move ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2550
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, input_iterator_tag, output_iterator_tag )
 {
 return ( _Move ( _First, _Last,
  _Dest ) );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag )
 {
 _OutIt _Ans = _Dest + ( _Last - _First );
 _Move ( _First, _Last,
  _Unchecked ( _Dest ) );
 return ( _Ans );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, :: std :: tr1 :: true_type )
 {
 return ( _Move ( _First, _Last,
  _Dest, _Iter_cat ( _First ), _Iter_cat ( _Dest ) ) );
 }

template < class _InIt,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, :: std :: tr1 :: false_type )
 {
 return ( _Move ( _First, _Last,
  _Dest, _Iter_cat ( _First ), _Iter_cat ( _Dest ) ) );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt move ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2594 );
 _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2595 );
 return ( _Move ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Is_checked ( _Dest ) ) );
 }

template < class _InIt,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * move ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( _Unchecked (
  :: std :: move ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ) ) ) );
 }



template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = :: std :: move ( * -- _Last );
 return ( _Dest );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_backward ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest - _Count, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest - _Count );
 }

template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Move_backward ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2655
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, :: std :: tr1 :: true_type )
 {
 return ( _Move_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest ) );
 }

template < class _BidIt1,
 class _BidIt2 > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 _BidIt2 _Move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, :: std :: tr1 :: false_type )
 {
 return ( _Move_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest ) );
 }

template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2679 );
 _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2680 );
 return ( _Move_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Is_checked ( _Dest ) ) );
 }



template < class _FwdIt,
 class _Ty > inline
 void _Fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First )
  * _First = _Val;
 }

inline void _Fill(char *_First, char *_Last, int _Val) 
{ 
::memset(_First, _Val, _Last - _First); 
} 

inline void _Fill(signed char *_First, signed char *_Last, int _Val) 
{ 
::memset(_First, _Val, _Last - _First); 
} 

inline void _Fill(unsigned char *_First, unsigned char *_Last, int _Val) 
{ 
::memset(_First, _Val, _Last - _First); 
} 

template < class _FwdIt,
 class _Ty > inline
 void fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2714 );
 _Fill ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val );
 }


template < class _OutIt,
 class _Diff,
 class _Ty > inline
 void _Fill_n ( _OutIt _Dest, _Diff _Count, const _Ty & _Val )
 {
 for (; 0 < _Count; -- _Count, ++ _Dest )
  * _Dest = _Val;
 }

inline void _Fill_n(char *_Dest, size_t _Count, int _Val) 
{ 
::memset(_Dest, _Val, _Count); 
} 

inline void _Fill_n(signed char *_Dest, size_t _Count, int _Val) 
{ 
::memset(_Dest, _Val, _Count); 
} 

inline void _Fill_n(unsigned char *_Dest, size_t _Count, int _Val) 
{ 
::memset(_Dest, _Val, _Count); 
} 
#line 2753
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 void _Fill_n1 ( _OutIt _Dest, _Diff _Count, const _Ty & _Val,
  output_iterator_tag )
 {
 _Fill_n ( _Dest, _Count, _Val );
 }

template < class _OutIt,
 class _Diff,
 class _Ty > inline
 void _Fill_n1 ( _OutIt _Dest, _Diff _Count, const _Ty & _Val,
  random_access_iterator_tag )
 {
 _OutIt _Ans = _Dest + _Count;
 _Ans = _Ans;
 _Fill_n ( _Unchecked ( _Dest ), _Count, _Val );
 }

template < class _OutIt,
 class _Diff,
 class _Ty > inline
 void _Fill_n ( _OutIt _Dest, _Diff _Count, const _Ty & _Val,
  :: std :: tr1 :: true_type )
 {
 _Fill_n1 ( _Dest, _Count, _Val,
  _Iter_cat ( _Dest ) );
 }

template < class _OutIt,
 class _Diff,
 class _Ty > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 void _Fill_n ( _OutIt _Dest, _Diff _Count, const _Ty & _Val,
  :: std :: tr1 :: false_type )
 {
 _Fill_n1 ( _Dest, _Count, _Val,
  _Iter_cat ( _Dest ) );
 }

template < class _OutIt,
 class _Diff,
 class _Ty > inline
 void fill_n ( _OutIt _Dest, _Diff _Count, const _Ty & _Val )
 {
 _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2799 );
 _Fill_n ( _Dest, _Count, _Val,
  _Is_checked ( _Dest ) );
 }

template < class _OutTy,
 size_t _OutSize,
 class _Diff,
 class _Ty > inline
 void fill_n ( _OutTy ( & _Dest ) [ _OutSize ], _Diff _Count, const _Ty & _Val )
 {
 :: std :: fill_n ( _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Count, _Val );
 }



template < class _InIt1,
 class _InIt2 > inline
 pair < _InIt1, _InIt2 >
  _Mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2 )
 {
 for (; _First1 != _Last1 && * _First1 == * _First2; )
  ++ _First1, ++ _First2;
 return ( pair < _InIt1, _InIt2 > ( _First1, _First2 ) );
 }
#line 2842
template < class _InIt1,
 class _InIt2 > inline
 pair < _InIt1, _InIt2 >
  _Mismatch1 ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, :: std :: tr1 :: true_type )
 {
 return ( :: std :: _Mismatch ( _First1, _Last1,
  _First2 ) );
 }

template < class _InIt1,
 class _InIt2 > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 pair < _InIt1, _InIt2 >
  _Mismatch1 ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, :: std :: tr1 :: false_type )
 {
 return ( :: std :: _Mismatch ( _First1, _Last1,
  _First2 ) );
 }

template < class _InIt1,
 class _InIt2 > inline
 pair < _InIt1, _InIt2 >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2 )
 {
 _Debug_range ( _First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2869 );
 _Debug_pointer ( _First2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2870 );
 :: std :: pair < typename _Get_unchecked_type < _InIt1 > :: type, _InIt2 > _Ans (
  :: std :: _Mismatch1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _First2, _Is_checked ( _First2 ) ) );
 return ( :: std :: pair < _InIt1, _InIt2 > (
  _Rechecked ( _First1, _Ans . first ),
  _Ans . second ) );
 }

template < class _InIt1,
 class _InTy,
 size_t _InSize > inline
 pair < _InIt1, _InTy * >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InTy ( & _First2 ) [ _InSize ] )
 {
 :: std :: pair < _InIt1, _Array_iterator < _InTy, _InSize > > _Ans (
  :: std :: mismatch ( _First1, _Last1,
   _Array_iterator < _InTy, _InSize > ( _First2 ) ) );
 return ( :: std :: pair < _InIt1, _InTy * > (
  _Ans . first,
  _Unchecked ( _Ans . second ) ) );
 }




template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  _Mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _Pred ( * _First1, * _First2 ); )
  ++ _First1, ++ _First2;
 return ( pair < _InIt1, _InIt2 > ( _First1, _First2 ) );
 }
#line 2926
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  _Mismatch2 ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred, :: std :: tr1 :: true_type )
 {
 return ( :: std :: _Mismatch ( _First1, _Last1,
  _First2, _Pred ) );
 }

template < class _InIt1,
 class _InIt2,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 pair < _InIt1, _InIt2 >
  _Mismatch2 ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred, :: std :: tr1 :: false_type )
 {
 return ( :: std :: _Mismatch ( _First1, _Last1,
  _First2, _Pred ) );
 }

template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2956 );
 _Debug_pointer ( _First2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2957 );
 _Debug_pointer ( _Pred, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 2958 );
 :: std :: pair < typename _Get_unchecked_type < _InIt1 > :: type, _InIt2 > _Ans (
  :: std :: _Mismatch2 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _First2, _Pred, _Is_checked ( _First2 ) ) );
 return ( :: std :: pair < _InIt1, _InIt2 > (
  _Rechecked ( _First1, _Ans . first ),
  _Ans . second ) );
 }

template < class _InIt1,
 class _InTy,
 size_t _InSize,
 class _Pr > inline
 pair < _InIt1, _InTy * >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InTy ( & _First2 ) [ _InSize ], _Pr _Pred )
 {
 :: std :: pair < _InIt1, _Array_iterator < _InTy, _InSize > > _Ans (
  :: std :: mismatch ( _First1, _Last1,
   _Array_iterator < _InTy, _InSize > ( _First2 ), _Pred ) );
 return ( :: std :: pair < _InIt1, _InTy * > (
  _Ans . first,
  _Unchecked ( _Ans . second ) ) );
 }



template < class _InIt1,
 class _InIt2 > inline
 bool _Equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  if ( ! ( * _First1 == * _First2 ) )
   return ( false );
 return ( true );
 }

inline bool _Equal(const char *_First1, const char *_Last1, const char *
_First2) 
{ 
return (::memcmp(_First1, _First2, _Last1 - _First1) == 0); 
} 

inline bool _Equal(const signed char *_First1, const signed char *_Last1, const signed char *
_First2) 
{ 
return (::memcmp(_First1, _First2, _Last1 - _First1) == 0); 
} 

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1, const unsigned char *
_First2) 
{ 
return (::memcmp(_First1, _First2, _Last1 - _First1) == 0); 
} 
#line 3024
template < class _InIt1,
 class _InIt2 > inline
 bool _Equal1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, :: std :: tr1 :: true_type )
 {
 return ( _Equal ( _First1, _Last1,
  _First2 ) );
 }

template < class _InIt1,
 class _InIt2 > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 bool _Equal1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, :: std :: tr1 :: false_type )
 {
 return ( _Equal ( _First1, _Last1,
  _First2 ) );
 }

template < class _InIt1,
 class _InIt2 > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2 )
 {
 _Debug_range ( _First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3048 );
 _Debug_pointer ( _First2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3049 );
 return ( _Equal1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _First2, _Is_checked ( _First2 ) ) );
 }

template < class _InIt1,
 class _InTy,
 size_t _InSize > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InTy ( & _First2 ) [ _InSize ] )
 {
 return ( :: std :: equal ( _First1, _Last1,
  _Array_iterator < _InTy, _InSize > ( _First2 ) ) );
 }



template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  if ( ! _Pred ( * _First1, * _First2 ) )
   return ( false );
 return ( true );
 }
#line 3090
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal2 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred, :: std :: tr1 :: true_type )
 {
 return ( _Equal ( _First1, _Last1,
  _First2, _Pred ) );
 }

template < class _InIt1,
 class _InIt2,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 bool _Equal2 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred, :: std :: tr1 :: false_type )
 {
 return ( _Equal ( _First1, _Last1,
  _First2, _Pred ) );
 }

template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3117 );
 _Debug_pointer ( _First2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3118 );
 return ( _Equal2 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _First2, _Pred, _Is_checked ( _First2 ) ) );
 }

template < class _InIt1,
 class _InTy,
 size_t _InSize,
 class _Pr > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InTy ( & _First2 ) [ _InSize ], _Pr _Pred )
 {
 return ( :: std :: equal ( _First1, _Last1,
  _Array_iterator < _InTy, _InSize > ( _First2 ), _Pred ) );
 }



template < class _InIt1,
 class _InIt2 > inline
 bool _Lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( _Debug_lt ( * _First1, * _First2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3142 ) )
   return ( true );
  else if ( * _First2 < * _First1 )
   return ( false );
 return ( _First1 == _Last1 && _First2 != _Last2 );
 }

inline bool _Lexicographical_compare(const unsigned char *
_First1, const unsigned char *_Last1, const unsigned char *
_First2, const unsigned char *_Last2) 
{ 
ptrdiff_t _Num1 = _Last1 - _First1; 
ptrdiff_t _Num2 = _Last2 - _First2; 
int _Ans = ::memcmp(_First1, _First2, (_Num1 < _Num2) ? _Num1 : _Num2); 
return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2); 
} 
#line 3171
template < class _InIt1,
 class _InIt2 > inline
 bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 _Debug_range ( _First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3176 );
 _Debug_range ( _First2, _Last2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3177 );
 return ( _Lexicographical_compare ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ) ) );
 }


template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( _Debug_lt_pred ( _Pred, * _First1, * _First2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3190 ) )
   return ( true );
  else if ( _Pred ( * _First2, * _First1 ) )
   return ( false );
 return ( _First1 == _Last1 && _First2 != _Last2 );
 }

template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3203 );
 _Debug_range ( _First2, _Last2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3204 );
 _Debug_pointer ( _Pred, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3205 );
 return ( _Lexicographical_compare ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) );
 }


template < class _BidIt > inline
 void _Reverse ( _BidIt _First, _BidIt _Last, bidirectional_iterator_tag )
 {
 for (; _First != _Last && _First != -- _Last; ++ _First )
  :: std :: iter_swap ( _First, _Last );
 }

template < class _BidIt > inline
 void reverse ( _BidIt _First, _BidIt _Last )
 {
 _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3221 );
 _Reverse ( _Unchecked ( _First ), _Unchecked ( _Last ), _Iter_cat ( _First ) );
 }


template < class _FwdIt > inline
 void _Rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag )
 {
 for ( _FwdIt _Next = _Mid;; )
  {
  :: std :: iter_swap ( _First, _Next );
  if ( ++ _First == _Mid )
   if ( ++ _Next == _Last )
    break;
   else
    _Mid = _Next;
  else if ( ++ _Next == _Last )
   _Next = _Mid;
  }
 }

template < class _BidIt > inline
 void _Rotate ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag )
 {
 :: std :: reverse ( _First, _Mid );
 :: std :: reverse ( _Mid, _Last );
 :: std :: reverse ( _First, _Last );
 }

template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Rotate ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty * )
 {
 _Diff _Shift = _Mid - _First;
 _Diff _Count = _Last - _First;

 for ( _Diff _Factor = _Shift; _Factor != 0; )
  {
  _Diff _Tmp = _Count % _Factor;
  _Count = _Factor;
  _Factor = _Tmp;
  }

 if ( _Count < _Last - _First )
  for (; 0 < _Count; -- _Count )
   {
   _RanIt _Hole = _First + _Count;
   _RanIt _Next = _Hole;
   _RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
   for (;; )
    {
    iter_swap ( _Next, _Next1 );
    _Next = _Next1;
    _Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
     : _First + ( _Shift - ( _Last - _Next1 ) );
    if ( _Next1 == _Hole )
     break;
    }
   }
 }

template < class _RanIt > inline
 void _Rotate ( _RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag )
 {
 _Rotate ( _First, _Mid, _Last, _Dist_type ( _First ), _Val_type ( _First ) );
 }

template < class _FwdIt > inline
 _FwdIt rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last )
 {
 _Debug_range ( _First, _Mid, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3295 );
 _Debug_range ( _Mid, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x75\x74\x69\x6c\x69\x74" L"\x79", 3296 );
 if ( _First != _Mid && _Mid != _Last )
  {
  _Rotate ( _Unchecked ( _First ), _Unchecked ( _Mid ), _Unchecked ( _Last ),
   _Iter_cat ( _First ) );
  :: std :: advance ( _First, :: std :: distance ( _Mid, _Last ) );
  }
 return ( _First );
 }


template < class _Elem >
 class __declspec ( dllimport ) _Yarn{ 


public: typedef _Yarn < _Elem > _Myt; 

 _Yarn ( )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  }

 _Yarn ( const _Myt & _Right )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  * this = _Right;
  }

 _Yarn ( const _Elem * _Right )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  * this = _Right;
  }

_Myt & operator = ( const _Myt & _Right )
  {
  return ( * this = _Right . _Myptr );
  }

_Myt & operator = ( const _Elem * _Right )
  {
  if ( _Myptr != _Right )
   {
   _Tidy ( );

   if ( _Right != 0 )
    {
    const _Elem * _Ptr = _Right;
    while ( * _Ptr != ( _Elem ) 0 )
     ++ _Ptr;
    size_t _Count = ( ( const char * ) ++ _Ptr - ( const char * ) _Right )
     * sizeof ( _Elem );


    _Myptr = ( _Elem * ) _malloc_dbg ( _Count, 2,
     "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xutility", 3351 );





    if ( _Myptr != 0 )
     :: memcpy ( _Myptr, _Right, _Count );
    }
   }
  return ( * this );
  }

 ~ _Yarn ( )
  {
  _Tidy ( );
  }

bool empty ( ) const
  {
  return ( _Myptr == 0 );
  }

const _Elem * c_str ( ) const
  {
  return ( _Myptr != 0 ? _Myptr : & _Nul );
  }

bool _Empty ( ) const
  {
  return ( _Myptr == 0 );
  }

const _Elem * _C_str ( ) const
  {
  return ( _Myptr != 0 ? _Myptr : & _Nul );
  }


private: void _Tidy ( )
  {
  if ( _Myptr != 0 )


   _free_dbg ( _Myptr, 2 );





  _Myptr = 0;
  }

_Elem * _Myptr; 
_Elem _Nul; 
};

__declspec(dllimport) __declspec(noreturn) void __cdecl _Xinvalid_argument(const char *); 
CPPTEST_IMP__ZSt14_Xlength_errorPKc __declspec(noreturn) void __cdecl _Xlength_error(const char *); 
CPPTEST_IMP__ZSt14_Xout_of_rangePKc __declspec(noreturn) void __cdecl _Xout_of_range(const char *); 
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xoverflow_error(const char *); 
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xruntime_error(const char *); 
}
/* Removed pragma: #pragma warning(pop)*/
#line 11 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xmemory"
/* Removed pragma: #pragma warning(push,3)*/
#line 18
#pragma warning(disable: 4100) /* Removed pragma: #pragma warning(disable: 4100)*/
#line 3415 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
#pragma pack ( pop )
#line 10 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xmemory"
#pragma pack ( push, 8 )
#line 26
namespace std { 

template < class _Ty > inline
 _Ty * _Allocate ( size_t _Count, _Ty * )
 {
 void * _Ptr = 0;

 if ( _Count <= 0 )
  _Count = 0;
 else if ( ( ( size_t ) ( - 1 ) / sizeof ( _Ty ) < _Count )
  || ( _Ptr = :: operator new ( _Count * sizeof ( _Ty ) ) ) == 0 )
  throw bad_alloc ( 0 );

 return ( ( _Ty * ) _Ptr );
 }


template < class _Ty1,
 class _Ty2 > inline
 void _Construct ( _Ty1 * _Ptr, _Ty2 && _Val )
 {
 void * _Vptr = _Ptr;
 :: new ( _Vptr ) _Ty1 ( :: std :: forward < _Ty2 > ( _Val ) );
 }

template < class _Ty1 > inline
 void _Construct ( _Ty1 * _Ptr )
 {
 void * _Vptr = _Ptr;

 :: new ( _Vptr ) _Ty1 ( );
 }


template < class _Ty > inline
 void _Destroy ( _Ty * _Ptr )
 {
 _Ptr -> ~ _Ty ( );
 }


template<> inline void _Destroy(char *) 
{ 
} 


template<> inline void _Destroy(__wchar_t *) 
{ 
} 



template<> inline void _Destroy(unsigned short *) 
{ 
} 



template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al )
 {
 _Destroy_range ( _First, _Last, _Al, _Ptr_cat ( _First, _Last ) );
 }

template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al,
  _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  _Dest_val ( _Al, _First );
 }

template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al,
  _Scalar_ptr_iterator_tag )
 {
 }


template < class _Ty > inline
 _Ty * addressof ( _Ty & _Val )
 {
 return ( ( _Ty * ) & ( char & ) _Val );
 }


template < class _Ty >
 struct _Allocator_base{ 

typedef _Ty value_type; 
};


template < class _Ty >
 struct _Allocator_base < const _Ty >{ 

typedef _Ty value_type; 
};


template < class _Ty >
 class allocator
  : public _Allocator_base < _Ty >{ 


public: typedef _Allocator_base < _Ty > _Mybase; 
typedef typename _Mybase :: value_type value_type; 

typedef value_type * pointer; 
typedef value_type & reference; 
typedef const value_type * const_pointer; 
typedef const value_type & const_reference; 

typedef size_t size_type; 
typedef ptrdiff_t difference_type; 

template < class _Other >
  struct rebind{ 

typedef allocator < _Other > other; 
};

pointer address ( reference _Val ) const
  {
  return ( ( pointer ) & ( char & ) _Val );
  }

const_pointer address ( const_reference _Val ) const
  {
  return ( ( const_pointer ) & ( char & ) _Val );
  }

 allocator ( ) throw ( )
  {
  }

 allocator ( const allocator < _Ty > & ) throw ( )
  {
  }

template < class _Other >
  allocator ( const allocator < _Other > & ) throw ( )
  {
  }

template < class _Other >
  allocator < _Ty > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }

void deallocate ( pointer _Ptr, size_type )
  {
  :: operator delete ( _Ptr );
  }

pointer allocate ( size_type _Count )
  {
  return ( _Allocate ( _Count, ( pointer ) 0 ) );
  }

pointer allocate ( size_type _Count, const void * )
  {
  return ( allocate ( _Count ) );
  }

void construct ( pointer _Ptr, const _Ty & _Val )
  {
  _Construct ( _Ptr, _Val );
  }

void construct ( pointer _Ptr, _Ty && _Val )
  {
  :: new ( ( void * ) _Ptr ) _Ty ( :: std :: forward < _Ty > ( _Val ) );
  }

template < class _Other >
  void construct ( pointer _Ptr, _Other && _Val )
  {
  :: new ( ( void * ) _Ptr ) _Ty ( :: std :: forward < _Other > ( _Val ) );
  }

void destroy ( pointer _Ptr )
  {
  _Destroy ( _Ptr );
  }

size_t max_size ( ) const throw ( )
  {
  size_t _Count = ( size_t ) ( - 1 ) / sizeof ( _Ty );
  return ( 0 < _Count ? _Count : 1 );
  }
};


template<> class allocator< void>  { 


public: typedef void _Ty; 
typedef _Ty *pointer; 
typedef const _Ty *const_pointer; 
typedef _Ty value_type; 

template < class _Other >
  struct rebind{ 

typedef allocator < _Other > other; 
};

allocator() throw() 
{ 
} 

allocator(const std::allocator< void>  &) throw() 
{ 
} 

template < class _Other >
  allocator ( const allocator < _Other > & ) throw ( )
  {
  }

template < class _Other >
  allocator < _Ty > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }
}; 

template < class _Ty,
 class _Other > inline
 bool operator == ( const allocator < _Ty > &,
  const allocator < _Other > & ) throw ( )
 {
 return ( true );
 }

template < class _Ty,
 class _Other > inline
 bool operator != ( const allocator < _Ty > & _Left,
  const allocator < _Other > & _Right ) throw ( )
 {
 return ( ! ( _Left == _Right ) );
 }


template < class _Alloc,
 class _Ty1,
 class _Ty2 >
 void _Cons_val ( _Alloc & _Alval, _Ty1 * _Pdest, _Ty2 && _Src )
 {
 _Alval . construct ( _Pdest, :: std :: forward < _Ty2 > ( _Src ) );
 }

template < class _Alloc,
 class _Ty1 >
 void _Dest_val ( _Alloc & _Alval, _Ty1 * _Pdest )
 {
 _Alval . destroy ( _Pdest );
 }
}



/* Removed pragma: #pragma warning(pop)*/
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
/* Removed pragma: #pragma warning(push,3)*/
#line 294 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xmemory"
#pragma pack ( pop )
#line 8 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
#pragma pack ( push, 8 )


namespace std { 
#pragma warning(disable: 4251) /* Removed pragma: #pragma warning(disable: 4251)*/

template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Ax = allocator < _Elem > >
 class basic_string;
#line 24
template < class _Elem,
 class _Traits,
 class _Alloc >
 class _String_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   typename _Alloc :: value_type,
   typename _Alloc :: difference_type,
   typename _Alloc :: const_pointer,
   typename _Alloc :: const_reference,
   _Iterator_base >{ 


public: typedef _String_const_iterator < _Elem, _Traits, _Alloc > _Myiter; 
typedef basic_string < _Elem, _Traits, _Alloc > _Mystr; 
typedef random_access_iterator_tag iterator_category; 

typedef typename _Alloc :: value_type value_type; 
typedef typename _Alloc :: difference_type difference_type; 
typedef typename _Alloc :: const_pointer pointer; 
typedef typename _Alloc :: const_reference reference; 

 _String_const_iterator ( )
  {
  this -> _Ptr = 0;
  }

 _String_const_iterator ( pointer _Parg, const _Container_base * _Pstring )
  {
  this -> _Adopt ( _Pstring );
  this -> _Ptr = _Parg;
  }

typedef pointer _Unchecked_type; 

_Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = _Right;
  return ( * this );
  }

_Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( this -> _Ptr ) );
  }

reference operator * ( ) const
  {

  if ( this -> _Getcont ( ) == 0
   || this -> _Ptr == 0
   || this -> _Ptr < ( ( _Mystr * ) this -> _Getcont ( ) ) -> _Myptr ( )
   || ( ( _Mystr * ) this -> _Getcont ( ) ) -> _Myptr ( )
    + ( ( _Mystr * ) this -> _Getcont ( ) ) -> _Mysize <= this -> _Ptr )
   {
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62" L"\x6c\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 78 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 79, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 79, 0 ); };
   }









                                    ;

  return ( * this -> _Ptr );
  }

pointer operator -> ( ) const
  {
  return ( & * * this );
  }

_Myiter & operator ++ ( )
  {

  if ( this -> _Getcont ( ) == 0
   || this -> _Ptr == 0
   || ( ( _Mystr * ) this -> _Getcont ( ) ) -> _Myptr ( )
    + ( ( _Mystr * ) this -> _Getcont ( ) ) -> _Mysize <= this -> _Ptr )
   {
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c" L"\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 108 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 109, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 109, 0 ); };
   }








  ++ this -> _Ptr;
  return ( * this );
  }

_Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

_Myiter & operator -- ( )
  {

  if ( this -> _Getcont ( ) == 0
   || this -> _Ptr == 0
   || this -> _Ptr <= ( ( _Mystr * ) this -> _Getcont ( ) ) -> _Myptr ( ) )
   {
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c" L"\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 137 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 138, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 138, 0 ); };
   }







  -- this -> _Ptr;
  return ( * this );
  }

_Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

_Myiter & operator += ( difference_type _Off )
  {

  if ( this -> _Getcont ( ) == 0
   || this -> _Ptr == 0
   || this -> _Ptr + _Off < ( ( _Mystr * ) this -> _Getcont ( ) ) -> _Myptr ( )
   || ( ( _Mystr * ) this -> _Getcont ( ) ) -> _Myptr ( )
    + ( ( _Mystr * ) this -> _Getcont ( ) ) -> _Mysize < this -> _Ptr + _Off )
   {
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x2b\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20" L"\x72\x61\x6e\x67\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 167 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 168, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 168, 0 ); };
   }









  _Ptr += _Off;
  return ( * this );
  }

_Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

_Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

_Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

difference_type operator - ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr - _Right . _Ptr );
  }

reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

bool operator == ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr == _Right . _Ptr );
  }

bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

bool operator < ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr < _Right . _Ptr );
  }

bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }


void _Compat ( const _Myiter & _Right ) const
  {
  if ( this -> _Getcont ( ) == 0
   || this -> _Getcont ( ) != _Right . _Getcont ( ) )
   {
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 249 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Invalid Argument" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 250, 0, L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x49\x6e\x76\x61\x6c\x69\x64\x20" L"\x41\x72\x67\x75\x6d\x65\x6e\x74\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", __LPREFIX ( __FUNCTION__ ), L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 250, 0 ); };
   }
  }
#line 267
pointer _Ptr; 
};

template < class _Elem,
 class _Traits,
 class _Alloc > inline
 typename _String_const_iterator < _Elem, _Traits, _Alloc > :: _Unchecked_type
  _Unchecked ( _String_const_iterator < _Elem, _Traits, _Alloc > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }

template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_const_iterator < _Elem, _Traits, _Alloc >
  _Rechecked ( _String_const_iterator < _Elem, _Traits, _Alloc > & _Iter,
   typename _String_const_iterator < _Elem, _Traits, _Alloc >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }

template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_const_iterator < _Elem, _Traits, _Alloc > operator + (
  typename _String_const_iterator < _Elem, _Traits, _Alloc >
   :: difference_type _Off,
  _String_const_iterator < _Elem, _Traits, _Alloc > _Next )
 {
 return ( _Next += _Off );
 }


template < class _Elem,
 class _Traits,
 class _Alloc >
 class _String_iterator
  : public _String_const_iterator < _Elem, _Traits, _Alloc >{ 


public: typedef _String_iterator < _Elem, _Traits, _Alloc > _Myiter; 
typedef _String_const_iterator < _Elem, _Traits, _Alloc > _Mybase; 
typedef basic_string < _Elem, _Traits, _Alloc > _Mystr; 
typedef random_access_iterator_tag iterator_category; 

typedef typename _Mystr :: value_type value_type; 
typedef typename _Mystr :: difference_type difference_type; 
typedef typename _Mystr :: pointer pointer; 
typedef typename _Mystr :: reference reference; 

 _String_iterator ( )
  {
  }

 _String_iterator ( pointer _Parg, const _Container_base * _Pstring )
  : _Mybase ( _Parg, _Pstring )
  {
  }

typedef pointer _Unchecked_type; 

_Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = _Right;
  return ( * this );
  }

_Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( this -> _Ptr ) );
  }

reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

pointer operator -> ( ) const
  {
  return ( & * * this );
  }

_Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

_Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

_Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

_Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

_Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

_Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

_Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

_Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( ( _Mybase ) * this - _Right );
  }

reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
};

template < class _Elem,
 class _Traits,
 class _Alloc > inline
 typename _String_iterator < _Elem, _Traits, _Alloc > :: _Unchecked_type
  _Unchecked ( _String_iterator < _Elem, _Traits, _Alloc > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }

template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_iterator < _Elem, _Traits, _Alloc >
  _Rechecked ( _String_iterator < _Elem, _Traits, _Alloc > & _Iter,
   typename _String_iterator < _Elem, _Traits, _Alloc >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }

template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_iterator < _Elem, _Traits, _Alloc > operator + (
  typename _String_iterator < _Elem, _Traits, _Alloc >
   :: difference_type _Off,
  _String_iterator < _Elem, _Traits, _Alloc > _Next )
 {
 return ( _Next += _Off );
 }


template < class _Elem,
 class _Alloc >
 class _String_val
  : public _Container_base{ 
#line 462
public: typedef typename _Alloc :: template rebind < _Elem > :: other _Alty; 

 _String_val ( _Alty _Al = _Alty ( ) )
  : _Alval ( _Al )
  {
  typename _Alloc :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Alval );
  this -> _Myproxy = _Alproxy . allocate ( 1 );
  _Cons_val ( _Alproxy, this -> _Myproxy, _Container_proxy ( ) );
  this -> _Myproxy -> _Mycont = this;
  }

 ~ _String_val ( )
  {
  typename _Alloc :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Alval );
  this -> _Orphan_all ( );
  _Dest_val ( _Alproxy, this -> _Myproxy );
  _Alproxy . deallocate ( this -> _Myproxy, 1 );
  this -> _Myproxy = 0;
  }


typedef typename _Alty :: size_type size_type; 
typedef typename _Alty :: difference_type difference_type; 
typedef typename _Alty :: pointer pointer; 
typedef typename _Alty :: const_pointer const_pointer; 
typedef typename _Alty :: reference reference; 
typedef typename _Alty :: const_reference const_reference; 
typedef typename _Alty :: value_type value_type; 


enum { 
_BUF_SIZE = 16 / sizeof ( _Elem ) < 1 ? 1
   : 16 / sizeof ( _Elem )
}; 

enum { 
_ALLOC_MASK = sizeof ( _Elem ) <= 1 ? 15
   : sizeof ( _Elem ) <= 2 ? 7
   : sizeof ( _Elem ) <= 4 ? 3
   : sizeof ( _Elem ) <= 8 ? 1 : 0


}; 

union _Bxty { 

_Elem _Buf [ _BUF_SIZE ]; 
_Elem * _Ptr; 
char _Alias [ _BUF_SIZE ]; 
} _Bx; 

size_type _Mysize; 
size_type _Myres; 
_Alty _Alval; 
};


template < class _Elem,
 class _Traits,
 class _Ax >
 class basic_string
  : public _String_val < _Elem, _Ax >{ 


public: typedef basic_string < _Elem, _Traits, _Ax > _Myt; 
typedef _String_val < _Elem, _Ax > _Mybase; 
typedef typename _Mybase :: _Alty _Alloc; 
typedef typename _Alloc :: size_type size_type; 
typedef typename _Alloc :: difference_type difference_type; 
typedef typename _Alloc :: pointer pointer; 
typedef typename _Alloc :: const_pointer const_pointer; 
typedef typename _Alloc :: reference reference; 
typedef typename _Alloc :: const_reference const_reference; 
typedef typename _Alloc :: value_type value_type; 

typedef _String_iterator < _Elem, _Traits, _Alloc > iterator; 
typedef _String_const_iterator < _Elem, _Traits, _Alloc > const_iterator; 

typedef :: std :: reverse_iterator < iterator > reverse_iterator; 
typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator; 

 basic_string ( const _Myt & _Right )
  : _Mybase ( _Right . _Alval )
  {
  _Tidy ( );
  assign ( _Right, 0, npos );
  }

 basic_string ( )
  : _Mybase ( )
  {
  _Tidy ( );
  }

explicit basic_string ( const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  }

 basic_string ( const _Myt & _Right, size_type _Roff,
  size_type _Count = npos )

  : _Mybase ( _Right . _Alval )
  {
  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

 basic_string ( const _Myt & _Right, size_type _Roff, size_type _Count,
  const _Alloc & _Al )

  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

 basic_string ( const _Elem * _Ptr, size_type _Count )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * _Ptr, size_type _Count, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * _Ptr )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

 basic_string ( const _Elem * _Ptr, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

 basic_string ( size_type _Count, _Elem _Ch )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

 basic_string ( size_type _Count, _Elem _Ch, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

template < class _It >
  basic_string ( _It _First, _It _Last )
  : _Mybase ( )
  {
  _Tidy ( );
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

template < class _It >
  basic_string ( _It _First, _It _Last, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

template < class _It >
  void _Construct ( _It _Count,
   _It _Ch, _Int_iterator_tag )
  {
  assign ( ( size_type ) _Count, ( _Elem ) _Ch );
  }

template < class _It >
  void _Construct ( _It _First,
   _It _Last, input_iterator_tag )
  {
  try {
  for (; _First != _Last; ++ _First )
   append ( ( size_type ) 1, ( _Elem ) * _First );
  } catch ( ... ) {
  _Tidy ( true );
  throw;
  }
  }

template < class _It >
  void _Construct ( _It _First,
   _It _Last, forward_iterator_tag )
  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 658 );
  size_type _Count = 0;
  _Distance ( _First, _Last, _Count );
  reserve ( _Count );

  try {
  for (; _First != _Last; ++ _First )
   append ( ( size_type ) 1, ( _Elem ) * _First );
  } catch ( ... ) {
  _Tidy ( true );
  throw;
  }
  }

 basic_string ( const_pointer _First, const_pointer _Last )
  : _Mybase ( )
  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 675 );
  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

 basic_string ( const_pointer _First, const_pointer _Last,
  const _Alloc & _Al )

  : _Mybase ( _Al )
  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 685 );
  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

 basic_string ( const_iterator _First, const_iterator _Last )
  : _Mybase ( )
  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 694 );
  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

 basic_string ( _Myt && _Right )
  : _Mybase ( :: std :: forward < _Alloc > ( _Right . _Alval ) )
  {
  _Tidy ( );
  assign ( :: std :: forward < _Myt > ( _Right ) );
  }

_Myt & operator = ( _Myt && _Right )
  {
  return ( assign ( :: std :: forward < _Myt > ( _Right ) ) );
  }

_Myt & assign ( _Myt && _Right )
  {
  if ( this == & _Right )
   ;
  else if ( get_allocator ( ) != _Right . get_allocator ( )
   && this -> _BUF_SIZE <= _Right . _Myres )
   * this = _Right;
  else
   {
   _Tidy ( true );
   if ( _Right . _Myres < this -> _BUF_SIZE )
    _Traits :: move ( this -> _Bx . _Buf, _Right . _Bx . _Buf,
     _Right . _Mysize + 1 );
   else
    {
    this -> _Bx . _Ptr = _Right . _Bx . _Ptr;
    _Right . _Bx . _Ptr = 0;
    }
   this -> _Mysize = _Right . _Mysize;
   this -> _Myres = _Right . _Myres;

   _Right . _Mysize = 0;
   _Right . _Myres = 0;
   }
  return ( * this );
  }

void swap ( _Myt && _Right )
  {
  if ( this != & _Right )
   {

   this -> _Orphan_all ( );
   this -> _Swap_all ( _Right );


   assign ( :: std :: forward < _Myt > ( _Right ) );
   }
  }

 ~ basic_string ( )
  {
  _Tidy ( true );
  }

typedef _Traits traits_type; 
typedef _Alloc allocator_type; 

static const size_type npos; 

_Myt & operator = ( const _Myt & _Right )
  {
  return ( assign ( _Right ) );
  }

_Myt & operator = ( const _Elem * _Ptr )
  {
  return ( assign ( _Ptr ) );
  }

_Myt & operator = ( _Elem _Ch )
  {
  return ( assign ( 1, _Ch ) );
  }

_Myt & operator += ( const _Myt & _Right )
  {
  return ( append ( _Right ) );
  }

_Myt & operator += ( const _Elem * _Ptr )
  {
  return ( append ( _Ptr ) );
  }

_Myt & operator += ( _Elem _Ch )
  {
  return ( append ( ( size_type ) 1, _Ch ) );
  }

_Myt & append ( const _Myt & _Right )
  {
  return ( append ( _Right, 0, npos ) );
  }

_Myt & append ( const _Myt & _Right,
  size_type _Roff, size_type _Count )

  {
  if ( _Right . size ( ) < _Roff )
   _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: copy ( _Myptr ( ) + this -> _Mysize,
    _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

_Myt & append ( const _Elem * _Ptr, size_type _Count )
  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 821 );


  if ( _Inside ( _Ptr ) )
   return ( append ( * this, _Ptr - _Myptr ( ), _Count ) );
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: copy ( _Myptr ( ) + this -> _Mysize, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

_Myt & append ( const _Elem * _Ptr )
  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 840 );
  return ( append ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

_Myt & append ( size_type _Count, _Elem _Ch )
  {
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Chassign ( this -> _Mysize, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

template < class _It >
  _Myt & append ( _It _First, _It _Last )
  {
  return ( _Append ( _First, _Last, _Iter_cat ( _First ) ) );
  }

template < class _It >
  _Myt & _Append ( _It _Count, _It _Ch, _Int_iterator_tag )
  {
  return ( append ( ( size_type ) _Count, ( _Elem ) _Ch ) );
  }

template < class _It >
  _Myt & _Append ( _It _First, _It _Last, input_iterator_tag )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

_Myt & append ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

_Myt & append ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

_Myt & assign ( const _Myt & _Right )
  {
  return ( assign ( _Right, 0, npos ) );
  }

_Myt & assign ( const _Myt & _Right,
  size_type _Roff, size_type _Count )

  {
  if ( _Right . size ( ) < _Roff )
   _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Count < _Num )
   _Num = _Count;

  if ( this == & _Right )
   erase ( ( size_type ) ( _Roff + _Num ) ), erase ( 0, _Roff );
  else if ( _Grow ( _Num ) )
   {
   _Traits :: copy ( _Myptr ( ), _Right . _Myptr ( ) + _Roff, _Num );
   _Eos ( _Num );
   }
  return ( * this );
  }

_Myt & assign ( const _Elem * _Ptr, size_type _Count )
  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 914 );


  if ( _Inside ( _Ptr ) )
   return ( assign ( * this, _Ptr - _Myptr ( ), _Count ) );

  if ( _Grow ( _Count ) )
   {
   _Traits :: copy ( _Myptr ( ), _Ptr, _Count );
   _Eos ( _Count );
   }
  return ( * this );
  }

_Myt & assign ( const _Elem * _Ptr )
  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 930 );
  return ( assign ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

_Myt & assign ( size_type _Count, _Elem _Ch )
  {
  if ( _Count == npos )
   _Xlen ( );

  if ( _Grow ( _Count ) )
   {
   _Chassign ( 0, _Count, _Ch );
   _Eos ( _Count );
   }
  return ( * this );
  }

template < class _It >
  _Myt & assign ( _It _First, _It _Last )
  {
  return ( _Assign ( _First, _Last, _Iter_cat ( _First ) ) );
  }

template < class _It >
  _Myt & _Assign ( _It _Count, _It _Ch, _Int_iterator_tag )
  {
  return ( assign ( ( size_type ) _Count, ( _Elem ) _Ch ) );
  }

template < class _It >
  _Myt & _Assign ( _It _First, _It _Last, input_iterator_tag )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

_Myt & assign ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

_Myt & assign ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

_Myt & insert ( size_type _Off, const _Myt & _Right )
  {
  return ( insert ( _Off, _Right, 0, npos ) );
  }

_Myt & insert ( size_type _Off,
  const _Myt & _Right, size_type _Roff, size_type _Count )

  {
  if ( this -> _Mysize < _Off || _Right . size ( ) < _Roff )
   _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off, this -> _Mysize - _Off );
   if ( this == & _Right )
    _Traits :: move ( _Myptr ( ) + _Off,
     _Myptr ( ) + ( _Off < _Roff ? _Roff + _Count : _Roff ),
      _Count );
   else
    _Traits :: copy ( _Myptr ( ) + _Off,
     _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

_Myt & insert ( size_type _Off,
  const _Elem * _Ptr, size_type _Count )

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1012 );


  if ( _Inside ( _Ptr ) )
   return ( insert ( _Off, * this,
    _Ptr - _Myptr ( ), _Count ) );
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );
  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off, this -> _Mysize - _Off );
   _Traits :: copy ( _Myptr ( ) + _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

_Myt & insert ( size_type _Off, const _Elem * _Ptr )
  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1035 );
  return ( insert ( _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

_Myt & insert ( size_type _Off,
  size_type _Count, _Elem _Ch )

  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );
  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off, this -> _Mysize - _Off );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

iterator insert ( const_iterator _Where )
  {
  return ( insert ( _Where, _Elem ( ) ) );
  }

iterator insert ( const_iterator _Where, _Elem _Ch )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  insert ( _Off, 1, _Ch );
  return ( begin ( ) + _Off );
  }

void insert ( const_iterator _Where, size_type _Count, _Elem _Ch )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  insert ( _Off, _Count, _Ch );
  }

template < class _It >
  void insert ( const_iterator _Where, _It _First, _It _Last )
  {
  _Insert ( _Where, _First, _Last, _Iter_cat ( _First ) );
  }

template < class _It >
  void _Insert ( const_iterator _Where, _It _Count, _It _Ch,
   _Int_iterator_tag )
  {
  insert ( _Where, ( size_type ) _Count, ( _Elem ) _Ch );
  }

template < class _It >
  void _Insert ( const_iterator _Where, _It _First, _It _Last,
   input_iterator_tag )
  {
  replace ( _Where, _Where, _First, _Last );
  }

void insert ( const_iterator _Where,
  const_pointer _First, const_pointer _Last )

  {
  replace ( _Where, _Where, _First, _Last );
  }

void insert ( const_iterator _Where,
  const_iterator _First, const_iterator _Last )

  {
  replace ( _Where, _Where, _First, _Last );
  }

_Myt & erase ( size_type _Off = 0,
  size_type _Count = npos )

  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _Count )
   _Count = this -> _Mysize - _Off;
  if ( 0 < _Count )
   {
   _Traits :: move ( _Myptr ( ) + _Off, _Myptr ( ) + _Off + _Count,
    this -> _Mysize - _Off - _Count );
   size_type _Newsize = this -> _Mysize - _Count;
   _Eos ( _Newsize );
   }
  return ( * this );
  }

iterator erase ( const_iterator _Where )
  {
  size_type _Count = _Pdif ( _Where, begin ( ) );
  erase ( _Count, 1 );
  return ( iterator ( _Myptr ( ) + _Count, this ) );
  }

iterator erase ( const_iterator _First, const_iterator _Last )
  {
  size_type _Count = _Pdif ( _First, begin ( ) );
  erase ( _Count, _Pdif ( _Last, _First ) );
  return ( iterator ( _Myptr ( ) + _Count, this ) );
  }

void clear ( )
  {
  _Eos ( 0 );
  }

_Myt & replace ( size_type _Off, size_type _N0, const _Myt & _Right )
  {
  return ( replace ( _Off, _N0, _Right, 0, npos ) );
  }

_Myt & replace ( size_type _Off,
  size_type _N0, const _Myt & _Right, size_type _Roff, size_type _Count )

  {
  if ( this -> _Mysize < _Off || _Right . size ( ) < _Roff )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - _Count <= this -> _Mysize - _N0 )
   _Xlen ( );

  size_type _Nm = this -> _Mysize - _N0 - _Off;
  size_type _Newsize = this -> _Mysize + _Count - _N0;
  if ( this -> _Mysize < _Newsize )
   _Grow ( _Newsize );

  if ( this != & _Right )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: copy ( _Myptr ( ) + _Off,
    _Right . _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Count <= _N0 )
   {
   _Traits :: move ( _Myptr ( ) + _Off,
    _Myptr ( ) + _Roff, _Count );
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   }
  else if ( _Roff <= _Off )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( _Myptr ( ) + _Off,
    _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Off + _N0 <= _Roff )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( _Myptr ( ) + _Off,
    _Myptr ( ) + ( _Roff + _Count - _N0 ), _Count );
   }
  else
   {
   _Traits :: move ( _Myptr ( ) + _Off,
    _Myptr ( ) + _Roff, _N0 );
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( _Myptr ( ) + _Off + _N0, _Myptr ( ) + _Roff + _Count,
    _Count - _N0 );
   }

  _Eos ( _Newsize );
  return ( * this );
  }

_Myt & replace ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count )

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1213 );


  if ( _Inside ( _Ptr ) )
   return ( replace ( _Off, _N0, * this,
    _Ptr - _Myptr ( ), _Count ) );
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;
  if ( npos - _Count <= this -> _Mysize - _N0 )
   _Xlen ( );
  size_type _Nm = this -> _Mysize - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
  size_type _Num;
  if ( ( 0 < _Count || 0 < _N0 )
   && _Grow ( _Num = this -> _Mysize + _Count - _N0 ) )
   {
   if ( _N0 < _Count )
    _Traits :: move ( _Myptr ( ) + _Off + _Count,
     _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: copy ( _Myptr ( ) + _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

_Myt & replace ( size_type _Off, size_type _N0, const _Elem * _Ptr )
  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1245 );
  return ( replace ( _Off, _N0, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

_Myt & replace ( size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch )

  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;
  if ( npos - _Count <= this -> _Mysize - _N0 )
   _Xlen ( );
  size_type _Nm = this -> _Mysize - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
  size_type _Num;
  if ( ( 0 < _Count || 0 < _N0 )
   && _Grow ( _Num = this -> _Mysize + _Count - _N0 ) )
   {
   if ( _N0 < _Count )
    _Traits :: move ( _Myptr ( ) + _Off + _Count,
     _Myptr ( ) + _Off + _N0, _Nm );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

_Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Myt & _Right )

  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Right ) );
  }

_Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Elem * _Ptr, size_type _Count )

  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Ptr, _Count ) );
  }

_Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Elem * _Ptr )

  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Ptr ) );
  }

_Myt & replace ( const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch )

  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Count, _Ch ) );
  }

template < class _It >
  _Myt & replace ( const_iterator _First, const_iterator _Last,
   _It _First2, _It _Last2 )
  {
  return ( _Replace ( _First, _Last,
   _First2, _Last2, _Iter_cat ( _First2 ) ) );
  }

template < class _It >
  _Myt & _Replace ( const_iterator _First, const_iterator _Last,
   _It _Count, _It _Ch, _Int_iterator_tag )
  {
  return ( replace ( _First, _Last, ( size_type ) _Count, ( _Elem ) _Ch ) );
  }

template < class _It >
  _Myt & _Replace ( const_iterator _First, const_iterator _Last,
   _It _First2, _It _Last2, input_iterator_tag )
  {
  _Myt _Right ( _First2, _Last2 );
  replace ( _First, _Last, _Right );
  return ( * this );
  }

_Myt & replace ( const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2 )

  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

_Myt & replace ( const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2 )

  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

iterator begin ( )
  {
  return ( iterator ( _Myptr ( ), this ) );
  }

const_iterator begin ( ) const
  {
  return ( const_iterator ( _Myptr ( ), this ) );
  }

iterator end ( )
  {
  return ( iterator ( _Myptr ( ) + this -> _Mysize, this ) );
  }

const_iterator end ( ) const
  {
  return ( const_iterator ( _Myptr ( ) + this -> _Mysize, this ) );
  }

reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }


const_iterator cbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> begin ( ) );
  }

const_iterator cend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> end ( ) );
  }

const_reverse_iterator crbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rbegin ( ) );
  }

const_reverse_iterator crend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rend ( ) );
  }

void shrink_to_fit ( )
  {
  if ( size ( ) < capacity ( ) )
   {
   _Myt _Tmp ( * this );
   swap ( _Tmp );
   }
  }


reference at ( size_type _Off )
  {
  if ( this -> _Mysize <= _Off )
   _Xran ( );
  return ( _Myptr ( ) [ _Off ] );
  }

const_reference at ( size_type _Off ) const
  {
  if ( this -> _Mysize <= _Off )
   _Xran ( );
  return ( _Myptr ( ) [ _Off ] );
  }

reference operator [ ] ( size_type _Off )
  {


  if ( this -> _Mysize <= _Off )

   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1441 );





  return ( _Myptr ( ) [ _Off ] );
  }

const_reference operator [ ] ( size_type _Off ) const
  {

  if ( this -> _Mysize < _Off )
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1454 );





  return ( _Myptr ( ) [ _Off ] );
  }

void push_back ( _Elem _Ch )
  {
  insert ( end ( ), _Ch );
  }


void pop_back ( )
  {
  erase ( this -> _Mysize - 1 );
  }

reference front ( )
  {
  return ( * begin ( ) );
  }

const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }


const _Elem * c_str ( ) const
  {
  return ( _Myptr ( ) );
  }

const _Elem * data ( ) const
  {
  return ( c_str ( ) );
  }

size_type length ( ) const
  {
  return ( this -> _Mysize );
  }

size_type size ( ) const
  {
  return ( this -> _Mysize );
  }

size_type max_size ( ) const
  {
  size_type _Num = this -> _Alval . max_size ( );
  return ( _Num <= 1 ? 1 : _Num - 1 );
  }

void resize ( size_type _Newsize )
  {
  resize ( _Newsize, _Elem ( ) );
  }

void resize ( size_type _Newsize, _Elem _Ch )
  {
  if ( _Newsize <= this -> _Mysize )
   erase ( _Newsize );
  else
   append ( _Newsize - this -> _Mysize, _Ch );
  }

size_type capacity ( ) const
  {
  return ( this -> _Myres );
  }

void reserve ( size_type _Newcap = 0 )
  {
  if ( this -> _Mysize <= _Newcap && this -> _Myres != _Newcap )
   {
   size_type _Size = this -> _Mysize;
   if ( _Grow ( _Newcap, true ) )
    _Eos ( _Size );
   }
  }

bool empty ( ) const
  {
  return ( this -> _Mysize == 0 );
  }



__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) ) size_type copy ( _Elem * _Ptr,
  size_type _Count, size_type _Off = 0 ) const

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1561 );


  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _Count )
   _Count = this -> _Mysize - _Off;
  _Traits :: copy ( _Ptr, _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

size_type _Copy_s ( _Elem * _Dest, size_type _Dest_size,
  size_type _Count, size_type _Off = 0 ) const

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1577 );


  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _Count )
   _Count = this -> _Mysize - _Off;
  _Traits :: _Copy_s ( _Dest, _Dest_size, _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

void swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( this -> _Alval == _Right . _Alval )
   {

   this -> _Swap_all ( _Right );


   :: std :: swap ( this -> _Bx, _Right . _Bx );
   :: std :: swap ( this -> _Mysize, _Right . _Mysize );
   :: std :: swap ( this -> _Myres, _Right . _Myres );
   }
  else
   {
   _Myt _Tmp = * this;

   * this = _Right;
   _Right = _Tmp;
   }
  }

size_type find ( const _Myt & _Right, size_type _Off = 0 ) const
  {
  return ( find ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

size_type find ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1621 );


  if ( _Count == 0 && _Off <= this -> _Mysize )
   return ( _Off );

  size_type _Nm;
  if ( _Off < this -> _Mysize && _Count <= ( _Nm = this -> _Mysize - _Off ) )
   {
   const _Elem * _Uptr, * _Vptr;
   for ( _Nm -= _Count - 1, _Vptr = _Myptr ( ) + _Off;
    ( _Uptr = _Traits :: find ( _Vptr, _Nm, * _Ptr ) ) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1 )
    if ( _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - _Myptr ( ) );
   }

  return ( npos );
  }

size_type find ( const _Elem * _Ptr, size_type _Off = 0 ) const
  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1643 );
  return ( find ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

size_type find ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

size_type rfind ( const _Myt & _Right, size_type _Off = npos ) const
  {
  return ( rfind ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

size_type rfind ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1662 );


  if ( _Count == 0 )
   return ( _Off < this -> _Mysize ? _Off
    : this -> _Mysize );
  if ( _Count <= this -> _Mysize )
   {
   const _Elem * _Uptr = _Myptr ( ) +
    ( _Off < this -> _Mysize - _Count ? _Off
     : this -> _Mysize - _Count );
   for (;; -- _Uptr )
    if ( _Traits :: eq ( * _Uptr, * _Ptr )
     && _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - _Myptr ( ) );
    else if ( _Uptr == _Myptr ( ) )
     break;
   }

  return ( npos );
  }

size_type rfind ( const _Elem * _Ptr, size_type _Off = npos ) const
  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1686 );
  return ( rfind ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

size_type rfind ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

size_type find_first_of ( const _Myt & _Right,
  size_type _Off = 0 ) const

  {
  return ( find_first_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

size_type find_first_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1706 );


  if ( 0 < _Count && _Off < this -> _Mysize )
   {
   const _Elem * const _Vptr = _Myptr ( ) + this -> _Mysize;
   for ( const _Elem * _Uptr = _Myptr ( ) + _Off; _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - _Myptr ( ) );
   }

  return ( npos );
  }

size_type find_first_of ( const _Elem * _Ptr, size_type _Off = 0 ) const
  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1722 );
  return ( find_first_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

size_type find_first_of ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

size_type find_last_of ( const _Myt & _Right,
  size_type _Off = npos ) const

  {
  return ( find_last_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1742 );


  if ( 0 < _Count && 0 < this -> _Mysize )
   {
   const _Elem * _Uptr = _Myptr ( )
    + ( _Off < this -> _Mysize ? _Off : this -> _Mysize - 1 );
   for (;; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - _Myptr ( ) );
    else if ( _Uptr == _Myptr ( ) )
     break;
   }

  return ( npos );
  }

size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const

  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1762 );
  return ( find_last_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

size_type find_last_of ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

size_type find_first_not_of ( const _Myt & _Right,
  size_type _Off = 0 ) const

  {
  return ( find_first_not_of ( _Right . _Myptr ( ), _Off,
   _Right . size ( ) ) );
  }

size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1783 );


  if ( _Off < this -> _Mysize )
   {
   const _Elem * const _Vptr = _Myptr ( ) + this -> _Mysize;
   for ( const _Elem * _Uptr = _Myptr ( ) + _Off; _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - _Myptr ( ) );
   }
  return ( npos );
  }

size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off = 0 ) const

  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1799 );
  return ( find_first_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

size_type find_first_not_of ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find_first_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

size_type find_last_not_of ( const _Myt & _Right,
  size_type _Off = npos ) const

  {
  return ( find_last_not_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1819 );


  if ( 0 < this -> _Mysize )
   {
   const _Elem * _Uptr = _Myptr ( )
    + ( _Off < this -> _Mysize ? _Off : this -> _Mysize - 1 );
   for (;; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - _Myptr ( ) );
    else if ( _Uptr == _Myptr ( ) )
     break;
   }
  return ( npos );
  }

size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const

  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1838 );
  return ( find_last_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

size_type find_last_not_of ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( find_last_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

_Myt substr ( size_type _Off = 0, size_type _Count = npos ) const
  {
  return ( _Myt ( * this, _Off, _Count, get_allocator ( ) ) );
  }

int compare ( const _Myt & _Right ) const
  {
  return ( compare ( 0, this -> _Mysize, _Right . _Myptr ( ), _Right . size ( ) ) );
  }

int compare ( size_type _Off, size_type _N0,
  const _Myt & _Right ) const

  {
  return ( compare ( _Off, _N0, _Right, 0, npos ) );
  }

int compare ( size_type _Off,
  size_type _N0, const _Myt & _Right,
  size_type _Roff, size_type _Count ) const


  {
  if ( _Right . size ( ) < _Roff )
   _Xran ( );
  if ( _Right . _Mysize - _Roff < _Count )
   _Count = _Right . _Mysize - _Roff;
  return ( compare ( _Off, _N0, _Right . _Myptr ( ) + _Roff, _Count ) );
  }

int compare ( const _Elem * _Ptr ) const
  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1876 );
  return ( compare ( 0, this -> _Mysize, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

int compare ( size_type _Off, size_type _N0, const _Elem * _Ptr ) const
  {
  _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1882 );
  return ( compare ( _Off, _N0, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

int compare ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count ) const

  {

  if ( _Count != 0 )
   _Debug_pointer ( _Ptr, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x73\x74\x72\x69\x6e\x67" L"", 1891 );


  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;

  size_type _Ans = _Traits :: compare ( _Myptr ( ) + _Off, _Ptr,
   _N0 < _Count ? _N0 : _Count );
  return ( _Ans != 0 ? ( int ) _Ans : _N0 < _Count ? - 1
   : _N0 == _Count ? 0 : + 1 );
  }

allocator_type get_allocator ( ) const
  {
  return ( this -> _Alval );
  }

void _Chassign ( size_type _Off, size_type _Count, _Elem _Ch )
  {
  if ( _Count == 1 )
   _Traits :: assign ( * ( _Myptr ( ) + _Off ), _Ch );
  else
   _Traits :: assign ( _Myptr ( ) + _Off, _Count, _Ch );
  }

void _Copy ( size_type _Newsize, size_type _Oldlen )
  {
  size_type _Newres = _Newsize | this -> _ALLOC_MASK;
  if ( max_size ( ) < _Newres )
   _Newres = _Newsize;
  else if ( this -> _Myres / 2 <= _Newres / 3 )
   ;
  else if ( this -> _Myres <= max_size ( ) - this -> _Myres / 2 )
   _Newres = this -> _Myres
    + this -> _Myres / 2;
  else
   _Newres = max_size ( );

  _Elem * _Ptr;
  try {
   _Ptr = this -> _Alval . allocate ( _Newres + 1 );
  } catch ( ... ) {
   _Newres = _Newsize;
   try {
    _Ptr = this -> _Alval . allocate ( _Newres + 1 );
   } catch ( ... ) {
   _Tidy ( true );
   throw;
   }
  }

  if ( 0 < _Oldlen )
   _Traits :: copy ( _Ptr, _Myptr ( ), _Oldlen );
  _Tidy ( true );
  this -> _Bx . _Ptr = _Ptr;
  this -> _Myres = _Newres;
  _Eos ( _Oldlen );
  }

void _Eos ( size_type _Newsize )
  {
  _Traits :: assign ( _Myptr ( ) [ this -> _Mysize = _Newsize ], _Elem ( ) );
  }

bool _Grow ( size_type _Newsize,
  bool _Trim = false )

  {
  if ( max_size ( ) < _Newsize )
   _Xlen ( );
  if ( this -> _Myres < _Newsize )
   _Copy ( _Newsize, this -> _Mysize );
  else if ( _Trim && _Newsize < this -> _BUF_SIZE )
   _Tidy ( true,
    _Newsize < this -> _Mysize ? _Newsize : this -> _Mysize );
  else if ( _Newsize == 0 )
   _Eos ( 0 );
  return ( 0 < _Newsize );
  }

bool _Inside ( const _Elem * _Ptr )
  {
  if ( _Ptr == 0 || _Ptr < _Myptr ( ) || _Myptr ( ) + this -> _Mysize <= _Ptr )
   return ( false );
  else
   return ( true );
  }

static size_type _Pdif ( const_iterator _P2,
  const_iterator _P1 )

  {
  return ( ( _P2 ) . _Ptr == 0 ? 0 : _P2 - _P1 );
  }

void _Tidy ( bool _Built = false,
  size_type _Newsize = 0 )

  {
  if ( ! _Built )
   ;
  else if ( this -> _BUF_SIZE <= this -> _Myres )
   {
   _Elem * _Ptr = this -> _Bx . _Ptr;
   if ( 0 < _Newsize )
    _Traits :: copy ( this -> _Bx . _Buf, _Ptr, _Newsize );
   this -> _Alval . deallocate ( _Ptr, this -> _Myres + 1 );
   }
  this -> _Myres = this -> _BUF_SIZE - 1;
  _Eos ( _Newsize );
  }

_Elem * _Myptr ( )
  {
  return ( this -> _BUF_SIZE <= this -> _Myres ? this -> _Bx . _Ptr
   : this -> _Bx . _Buf );
  }

const _Elem * _Myptr ( ) const
  {
  return ( this -> _BUF_SIZE <= this -> _Myres ? this -> _Bx . _Ptr
   : this -> _Bx . _Buf );
  }

__declspec ( noreturn ) void _Xlen ( ) const
  {
  _Xlength_error ( "string too long" );
  }

__declspec ( noreturn ) void _Xran ( ) const
  {
  _Xout_of_range ( "invalid string position" );
  }
};


template < class _Elem,
 class _Traits,
 class _Alloc >
          const typename basic_string < _Elem, _Traits, _Alloc > :: size_type
  basic_string < _Elem, _Traits, _Alloc > :: npos =
   ( typename basic_string < _Elem, _Traits, _Alloc > :: size_type ) ( - 1 );



template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }

template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 _Left . swap ( _Right );
 }

template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_string < _Elem, _Traits, _Alloc > && _Left,
  basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 _Right . swap ( _Left );
 }


typedef basic_string< char, char_traits< char> , allocator< char> >  string; 

typedef basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstring; 



typedef basic_string< unsigned short, char_traits< unsigned short> , allocator< unsigned short> >  u16string; 

typedef basic_string< unsigned, char_traits< unsigned> , allocator< unsigned> >  u32string; 

}

/* Removed pragma: #pragma warning(pop)*/
#line 10 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
/* Removed pragma: #pragma warning(push,3)*/
#line 2076 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
#pragma pack ( pop )
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
#pragma pack ( push, 8 )

namespace std { 
#line 17
class logic_error : public exception { 



public: typedef exception _Mybase; 

explicit logic_error(const string &_Message) : _Mybase(_Message.c_str()) 

{ 
} 

explicit logic_error(const char *_Message) : _Mybase(_Message) 

{ 
} 
#line 42
}; 


class domain_error : public logic_error { 



public: typedef logic_error _Mybase; 

explicit domain_error(const string &_Message) : _Mybase(_Message.c_str()) 

{ 
} 

explicit domain_error(const char *_Message) : _Mybase(_Message) 

{ 
} 
#line 70
}; 


class invalid_argument : public logic_error { 



public: typedef logic_error _Mybase; 

explicit invalid_argument(const string &_Message) : _Mybase(_Message.c_str()) 

{ 
} 

explicit invalid_argument(const char *_Message) : _Mybase(_Message) 

{ 
} 
#line 98
}; 


class length_error : public logic_error { 



public: typedef logic_error _Mybase; 

explicit length_error(const string &_Message) : _Mybase(_Message.c_str()) 

{ 
} 

explicit length_error(const char *_Message) : _Mybase(_Message) 

{ 
} 
#line 126
}; 


class out_of_range : public logic_error { 



public: typedef logic_error _Mybase; 

explicit out_of_range(const string &_Message) : _Mybase(_Message.c_str()) 

{ 
} 

explicit out_of_range(const char *_Message) : _Mybase(_Message) 

{ 
} 
#line 154
}; 


class runtime_error : public exception { 



public: typedef exception _Mybase; 

explicit runtime_error(const string &_Message) : _Mybase(_Message.c_str()) 

{ 
} 

explicit runtime_error(const char *_Message) : _Mybase(_Message) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 
#line 182
}; 


class overflow_error : public runtime_error { 



public: typedef runtime_error _Mybase; 

explicit overflow_error(const string &_Message) : _Mybase(_Message.c_str()) 

{ 
} 

explicit overflow_error(const char *_Message) : _Mybase(_Message) 

{ 
} 
#line 210
}; 


class underflow_error : public runtime_error { 



public: typedef runtime_error _Mybase; 

explicit underflow_error(const string &_Message) : _Mybase(_Message.c_str()) 

{ 
} 

explicit underflow_error(const char *_Message) : _Mybase(_Message) 

{ 
} 
#line 238
}; 


class range_error : public runtime_error { 



public: typedef runtime_error _Mybase; 

explicit range_error(const string &_Message) : _Mybase(_Message.c_str()) 

{ 
} 

explicit range_error(const char *_Message) : _Mybase(_Message) 

{ 
} 
#line 266
}; 
}
/* Removed pragma: #pragma warning(pop)*/
#pragma pack ( pop )
#line 26 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\typeinfo"
#pragma pack ( push, 8 )
#line 36
struct __type_info_node { 
void *_MemPtr; 
__type_info_node *_Next; 
}; 

extern __type_info_node __type_info_root_node; 

class type_info { 


public: size_t hash_code() const throw() 
{ 
const char *_Keyval = this->name(); 
size_t _Val = 2166136261U; 
size_t _First = (0); 
size_t _Last = ::strlen(_Keyval); 
size_t _Stride = 1 + _Last / 10; 

for (; _First < _Last; _First += _Stride) 
_Val = 16777619U * _Val ^ (size_t)(_Keyval[_First]);   
return (_Val); 
} 
#line 63
virtual ~type_info(); 
__declspec(dllimport) bool operator==(const type_info & _Rhs) const; 
__declspec(dllimport) bool operator!=(const type_info & _Rhs) const; 
__declspec(dllimport) int before(const type_info & _Rhs) const; 
__declspec(dllimport) const char *name(__type_info_node * __ptype_info_node = &__type_info_root_node) const; 
__declspec(dllimport) const char *raw_name() const; 

private: void *_M_data; 
char _M_d_name[1]; 
type_info(const type_info & _Rhs); 
type_info &operator=(const type_info & _Rhs); 
__declspec(dllimport) static const char *__cdecl _Name_base(const type_info *, __type_info_node * __ptype_info_node); 
__declspec(dllimport) static void __cdecl _Type_info_dtor(type_info *); 
}; 



namespace std { 

using ::type_info;

}
#line 90
namespace std { 

class bad_cast : public exception { 
#line 104
public: CPPTEST_IMP__ZNSt8bad_castC9EPKc bad_cast(const char * _Message = "bad cast"); 
CPPTEST_IMP__ZNSt8bad_castC9ERKS_ bad_cast(const bad_cast &); 
CPPTEST_IMP__ZNSt8bad_castD9Ev virtual ~bad_cast(); 
public:
    __declspec(dllimport) bad_cast& operator=(const bad_cast&);

#line 108
}; 

class bad_typeid : public exception { 
#line 122
public: bad_typeid(const char * _Message = "bad typeid"); 
bad_typeid(const bad_typeid &); 
virtual ~bad_typeid(); 
public:
    __declspec(dllimport) bad_typeid& operator=(const bad_typeid&);

#line 127
}; 

class __non_rtti_object : public bad_typeid { 
#line 141
public: __non_rtti_object(const char * _Message); 
__non_rtti_object(const __non_rtti_object &); 
virtual ~__non_rtti_object(); 
public:
    __declspec(dllimport) __non_rtti_object& operator=(const __non_rtti_object&);

#line 145
}; 

}
#line 210
#pragma pack ( pop )
#line 92 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\ctype.h"
extern "C" { __declspec(dllimport) int __cdecl _isctype(int _C, int _Type); } 
extern "C" { __declspec(dllimport) int __cdecl _isctype_l(int _C, int _Type, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl isalpha(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _isalpha_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl isupper(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _isupper_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl islower(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _islower_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl isdigit(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _isdigit_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl isxdigit(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _isxdigit_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl isspace(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _isspace_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl ispunct(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _ispunct_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl isalnum(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _isalnum_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl isprint(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _isprint_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl isgraph(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _isgraph_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl iscntrl(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _iscntrl_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl toupper(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl tolower(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _tolower(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _tolower_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl _toupper(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl _toupper_l(int _C, _locale_t _Locale); } 
extern "C" { __declspec(dllimport) int __cdecl __isascii(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl __toascii(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl __iscsymf(int _C); } 
extern "C" { __declspec(dllimport) int __cdecl __iscsym(int _C); } 
#line 207
extern "C" { __declspec(dllimport) int __cdecl _chvalidator(int _Ch, int _Mask); } 
#line 259
extern "C" { __declspec(dllimport) int __cdecl _chvalidator_l(_locale_t, int _Ch, int _Mask); } 
#line 25 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\locale.h"
#pragma pack ( push, 8 )
#line 55
extern "C" { struct lconv { 
char *decimal_point; 
char *thousands_sep; 
char *grouping; 
char *int_curr_symbol; 
char *currency_symbol; 
char *mon_decimal_point; 
char *mon_thousands_sep; 
char *mon_grouping; 
char *positive_sign; 
char *negative_sign; 
char int_frac_digits; 
char frac_digits; 
char p_cs_precedes; 
char p_sep_by_space; 
char n_cs_precedes; 
char n_sep_by_space; 
char p_sign_posn; 
char n_sign_posn; 
__wchar_t *_W_decimal_point; 
__wchar_t *_W_thousands_sep; 
__wchar_t *_W_int_curr_symbol; 
__wchar_t *_W_currency_symbol; 
__wchar_t *_W_mon_decimal_point; 
__wchar_t *_W_mon_thousands_sep; 
__wchar_t *_W_positive_sign; 
__wchar_t *_W_negative_sign; 
}; }
#line 107
extern "C" { __declspec(dllimport) int __cdecl _configthreadlocale(int _Flag); } 
extern "C" { __declspec(dllimport) char *__cdecl setlocale(int _Category, const char * _Locale); } 
extern "C" { CPPTEST_IMP_localeconv lconv *__cdecl localeconv(); } 
extern "C" { __declspec(dllimport) _locale_t __cdecl _get_current_locale(); } 
extern "C" { __declspec(dllimport) _locale_t __cdecl _create_locale(int _Category, const char * _Locale); } 
extern "C" { __declspec(dllimport) void __cdecl _free_locale(_locale_t _Locale); } 


extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _get_current_lo" "cale instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __get_current_locale(); } 
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _create_locale " "instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __create_locale(int _Category, const char * _Locale); } 
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _free_locale in" "stead. See online help for details.")) __declspec(dllimport) void __cdecl __free_locale(_locale_t _Locale); } 
#line 132
#pragma pack ( pop )
#line 12 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo.h"
#pragma pack ( push, 8 )
#line 55
extern "C" { typedef 
#line 51
struct _Collvec { 

unsigned long _Hand; 
unsigned _Page; 
} _Collvec; }
#line 63
extern "C" { typedef 
#line 57
struct _Ctypevec { 

unsigned long _Hand; 
unsigned _Page; 
const short *_Table; 
int _Delfl; 
} _Ctypevec; }
#line 69
extern "C" { typedef 
#line 65
struct _Cvtvec { 

unsigned long _Hand; 
unsigned _Page; 
} _Cvtvec; }


extern "C" { __declspec(dllimport) _Collvec __cdecl _Getcoll(); } 
extern "C" { __declspec(dllimport) _Ctypevec __cdecl _Getctype(); } 

extern "C" { CPPTEST_IMP__Getcvt _Cvtvec __cdecl _Getcvt(); } 

extern "C" { __declspec(dllimport) int __cdecl _Getdateorder(); } 
#line 83
extern "C" { __declspec(dllimport) int __cdecl _Mbrtowc(__wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *); } 


extern "C" { __declspec(dllimport) float __cdecl _Stof(const char *, char **, long); } 
extern "C" { __declspec(dllimport) double __cdecl _Stod(const char *, char **, long); } 
extern "C" { __declspec(dllimport) long double __cdecl _Stold(const char *, char **, long); } 

extern "C" { __declspec(dllimport) int __cdecl _Strcoll(const char *, const char *, const char *, const char *, const _Collvec *); } 

extern "C" { __declspec(dllimport) size_t __cdecl _Strxfrm(char * _String1, char * _End1, const char *, const char *, const _Collvec *); } 


extern "C" { __declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *); } 
extern "C" { __declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *); } 

extern "C" { __declspec(dllimport) int __cdecl _Wcrtomb(char *, __wchar_t, mbstate_t *, const _Cvtvec *); } 

extern "C" { __declspec(dllimport) int __cdecl _Wcscoll(const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *); } 

extern "C" { __declspec(dllimport) size_t __cdecl _Wcsxfrm(__wchar_t * _String1, __wchar_t * _End1, const __wchar_t *, const __wchar_t *, const _Collvec *); } 



extern "C" { __declspec(dllimport) short __cdecl _Getwctype(__wchar_t, const _Ctypevec *); } 
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl _Getwctypes(const __wchar_t *, const __wchar_t *, short *, const _Ctypevec *); } 

extern "C" { __declspec(dllimport) __wchar_t __cdecl _Towlower(__wchar_t, const _Ctypevec *); } 
extern "C" { __declspec(dllimport) __wchar_t __cdecl _Towupper(__wchar_t, const _Ctypevec *); } 
#line 117
extern "C" { __declspec(dllimport) void *__cdecl _Gettnames(); } 
extern "C" { __declspec(dllimport) char *__cdecl _Getdays(); } 
extern "C" { __declspec(dllimport) char *__cdecl _Getmonths(); } 
extern "C" { __declspec(dllimport) size_t __cdecl _Strftime(char *, size_t _Maxsize, const char *, const tm *, void *); } 
#line 129
__declspec(dllimport) _locale_t __cdecl _GetLocaleForCP(unsigned); 
#line 11 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
/* Removed pragma: #pragma warning(push,3)*/
#pragma warning(disable: 4412) /* Removed pragma: #pragma warning(disable:4412)*/
#line 132 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo.h"
#pragma pack ( pop )
#line 10 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
#pragma pack ( push, 8 )



namespace std { 


class _Timevec { 


public: CPPTEST_IMP__ZNSt8_TimevecC9EPv inline _Timevec(void *_Ptr = 0) : _Timeptr(_Ptr) 

{ 
} 

CPPTEST_IMP__ZNSt8_TimevecC9ERKS_ inline _Timevec(const _Timevec &_Right) 
{ 
(*this = _Right); 
} 

CPPTEST_IMP__ZNSt8_TimevecD9Ev inline ~_Timevec() 
{ 
free(_Timeptr); 
} 

CPPTEST_IMP__ZNSt8_TimevecaSERKS_ inline _Timevec &operator=(const _Timevec &_Right) 
{ 
_Timeptr = _Right._Timeptr; 
((_Timevec *)(&_Right))->_Timeptr = 0; 
return (*this); 
} 

CPPTEST_IMP__ZNKSt8_Timevec7_GetptrEv inline void *_Getptr() const 
{ 
return (_Timeptr); 
} 


private: void *_Timeptr; 
}; 



/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4412) /* Removed pragma: #pragma warning(disable: 4412)*/

class _Locinfo { 


public: typedef ::_Collvec _Collvec; 
typedef ::_Ctypevec _Ctypevec; 
typedef ::_Cvtvec _Cvtvec; 
typedef std::_Timevec _Timevec; 

CPPTEST_IMP__ZNSt8_Locinfo13_Locinfo_ctorEPS_PKc static void __cdecl _Locinfo_ctor(_Locinfo *, const char *); 

static void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *); 

CPPTEST_IMP__ZNSt8_Locinfo13_Locinfo_dtorEPS_ static void __cdecl _Locinfo_dtor(_Locinfo *); 
static _Locinfo &__cdecl _Locinfo_Addcats(_Locinfo *, int, const char *); 


CPPTEST_IMP__ZNSt8_LocinfoC9EPKc inline _Locinfo(const char *_Pch = "C") : _Lock(0) 



{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(17) , _Pch == 0)) {CPPTEST_STACK_TRACE_STMT_INFO(18) 
throw ((runtime_error)("bad locale name")); }  CPPTEST_STACK_TRACE_STMT_INFO(19) 
_Locinfo_ctor(this, _Pch); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt8_LocinfoC9EiPKc inline _Locinfo(int _Cat, const char *_Pch) : _Lock(0) 



{ 
if (_Pch == 0) 
throw ((runtime_error)("bad locale name"));   
_Locinfo_ctor(this, _Cat, _Pch); 
} 

CPPTEST_IMP__ZNSt8_LocinfoD9Ev inline ~_Locinfo() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(20) 
_Locinfo_dtor(this); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 


CPPTEST_IMP__ZNSt8_Locinfo8_AddcatsEiPKc inline _Locinfo &_Addcats(int _Cat, const char *_Pch) 
{ 
if (_Pch == 0) 
throw ((runtime_error)("bad locale name"));   
return _Locinfo_Addcats(this, _Cat, _Pch); 
} 


CPPTEST_IMP__ZNKSt8_Locinfo8_GetnameEv inline const char *_Getname() const 
{ 
return ((_Newlocname)._C_str()); 
} 

CPPTEST_IMP__ZNKSt8_Locinfo8_GetcollEv inline _Collvec _Getcoll() const 
{ 
return (::_Getcoll()); 
} 

CPPTEST_IMP__ZNKSt8_Locinfo9_GetctypeEv inline _Ctypevec _Getctype() const 
{ 
return (::_Getctype()); 
} 

CPPTEST_IMP__ZNKSt8_Locinfo7_GetcvtEv inline _Cvtvec _Getcvt() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(21) 
return (::_Getcvt()); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNKSt8_Locinfo9_GetlconvEv inline const lconv *_Getlconv() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(22) 
return (localeconv()); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNKSt8_Locinfo10_GettnamesEv inline _Timevec _Gettnames() const 
{ 
return ((_Timevec)(::_Gettnames())); 
} 

CPPTEST_IMP__ZNKSt8_Locinfo8_GetdaysEv inline const char *_Getdays() const 
{ 
const char *_Ptr = ::_Getdays(); 
if (_Ptr != 0) 
{ 
(((_Locinfo *)this)->_Days = _Ptr); 
free((void *)_Ptr); 
}  
return ((!(_Days)._Empty()) ? (_Days)._C_str() : (":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday")); 


} 

CPPTEST_IMP__ZNKSt8_Locinfo10_GetmonthsEv inline const char *_Getmonths() const 
{ 
const char *_Ptr = ::_Getmonths(); 
if (_Ptr != 0) 
{ 
(((_Locinfo *)this)->_Months = _Ptr); 
free((void *)_Ptr); 
}  
return ((!(_Months)._Empty()) ? (_Months)._C_str() : (":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:De" "cember")); 




} 

CPPTEST_IMP__ZNKSt8_Locinfo9_GetfalseEv inline const char *_Getfalse() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(23) 
return ("false"); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNKSt8_Locinfo8_GettrueEv inline const char *_Gettrue() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(24) 
return ("true"); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNKSt8_Locinfo13_GetdateorderEv inline int _Getdateorder() const 
{ 
return ::_Getdateorder(); 
} 
#line 189
private: _Lockit _Lock; 


_Yarn< char>  _Days; 
_Yarn< char>  _Months; 
_Yarn< char>  _Oldlocname; 
_Yarn< char>  _Newlocname; 
public:
    __declspec(dllimport) _Locinfo(const _Locinfo&);
    __declspec(dllimport) _Locinfo& operator=(const _Locinfo&);

#line 196
}; 
/* Removed pragma: #pragma warning(pop)*/


template < class _Elem > inline
 int __cdecl _LStrcoll ( const _Elem * _First1, const _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( * _First1 < * _First2 )
   return ( - 1 );
  else if ( * _First2 < * _First1 )
   return ( + 1 );
 return ( _First2 != _Last2 ? - 1 : _First1 != _Last1 ? + 1 : 0 );
 }


template<> inline int __cdecl _LStrcoll(const char *_First1, const char *_Last1, const char *
_First2, const char *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector)); 
} 


template<> inline int __cdecl _LStrcoll(const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector)); 
} 


template < class _Elem > inline
 size_t __cdecl _LStrxfrm ( _Elem * _First1, _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 size_t _Count = _Last2 - _First2;
 if ( _Count <= ( size_t ) ( _Last1 - _First1 ) )
  :: memcpy_s ( ( _First1 ), ( ( _Last1 - _First1 ) * sizeof ( _Elem ) ), ( _First2 ), ( _Count * sizeof ( _Elem ) ) )
                                    ;
 return ( _Count );
 }


template<> inline size_t __cdecl _LStrxfrm(char *
_First1, char *
_Last1, const char *
_First2, const char *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector)); 
} 


template<> inline size_t __cdecl _LStrxfrm(__wchar_t *
_First1, __wchar_t *
_Last1, const __wchar_t *
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector)); 
} 
}

/* Removed pragma: #pragma warning(pop)*/
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xdebug"
/* Removed pragma: #pragma warning(push,3)*/
#line 264 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
#pragma pack ( pop )
#line 8 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xdebug"
#pragma pack ( push, 8 )
#line 16
namespace std { 
struct _DebugHeapTag_t { 

int _Type; 
}; 
}
#line 33
CPPTEST_IMP__ZnwjRKSt15_DebugHeapTag_tPci void *__cdecl operator new(size_t _Size, const std::_DebugHeapTag_t &, char *, int); 



CPPTEST_IMP__ZnajRKSt15_DebugHeapTag_tPci void *__cdecl operator new[](size_t _Size, const std::_DebugHeapTag_t &, char *, int); 



__declspec(dllimport) void __cdecl operator delete(void *, const std::_DebugHeapTag_t &, char *, int) throw(); 



__declspec(dllimport) void __cdecl operator delete[](void *, const std::_DebugHeapTag_t &, char *, int) throw(); 



namespace std { 

CPPTEST_IMP__ZSt18_DebugHeapTag_funcv const _DebugHeapTag_t &__cdecl _DebugHeapTag_func(); 


template < class _Ty >
 void __cdecl _DebugHeapDelete ( _Ty * _Ptr )
 {
 if ( _Ptr != 0 )
  {
  _Ptr -> ~ _Ty ( );


  free ( _Ptr );
  }
 }

}
#line 77
/* Removed pragma: #pragma warning(pop)*/
#line 14 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
/* Removed pragma: #pragma warning(push,3)*/




#pragma warning(disable: 4412) /* Removed pragma: #pragma warning(disable: 4412)*/
#line 78 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xdebug"
#pragma pack ( pop )
#line 13 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
#pragma pack ( push, 8 )
#line 21
namespace std { 

template < class _Dummy >
 class _Locbase{ 


public: static const int collate = ( ( 1 << ( 1 ) ) >> 1 ); 
static const int ctype = ( ( 1 << ( 2 ) ) >> 1 ); 
static const int monetary = ( ( 1 << ( 3 ) ) >> 1 ); 
static const int numeric = ( ( 1 << ( 4 ) ) >> 1 ); 
static const int time = ( ( 1 << ( 5 ) ) >> 1 ); 
static const int messages = ( ( 1 << ( 6 ) ) >> 1 ); 
static const int all = ( ( ( 1 << ( 7 ) ) >> 1 ) - 1 ); 
static const int none = 0; 
};

template < class _Dummy >
 const int _Locbase < _Dummy > :: collate;
template < class _Dummy >
 const int _Locbase < _Dummy > :: ctype;
template < class _Dummy >
 const int _Locbase < _Dummy > :: monetary;
template < class _Dummy >
 const int _Locbase < _Dummy > :: numeric;
template < class _Dummy >
 const int _Locbase < _Dummy > :: time;
template < class _Dummy >
 const int _Locbase < _Dummy > :: messages;
template < class _Dummy >
 const int _Locbase < _Dummy > :: all;
template < class _Dummy >
 const int _Locbase < _Dummy > :: none;


class locale; 
template < class _Facet >
 const _Facet & __cdecl use_facet ( const locale & );

class locale : public _Locbase< int>  { 



public: typedef int category; 


class id { 


public: CPPTEST_IMP__ZNSt6locale2idC9Ej inline id(size_t _Val = 0) : _Id(_Val) 

{ 
} 

CPPTEST_IMP__ZNSt6locale2idcvjEv inline operator size_t() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(25) , _Id == 0)) 
{ 
{ CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_1, 26) _Lockit _Lock(0); 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(27) , _Id == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(28) 
_Id = ++_Id_cnt; }  CPPTEST_STACK_TRACE_BLOCK_END_INFO(29) 
} CPPTEST_STACK_TRACE_BLOCK_END_INFO(30) 
}  CPPTEST_STACK_TRACE_STMT_INFO(31) 
return (_Id); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 


private: size_t _Id; 

__declspec(dllimport) static int _Id_cnt; 

id(const id &); 
id &operator=(const id &); 
}; 

class _Locimp; 


class facet { 

friend class locale; 
friend class _Locimp; 


public: CPPTEST_IMP__ZNSt6locale5facet7_GetcatEPPKS0_PKS_ static inline size_t __cdecl _Getcat(const facet ** = 0, const locale * = 0) 

{ 
return ((size_t)(-1)); 
} 

CPPTEST_IMP__ZNSt6locale5facet7_IncrefEv inline void _Incref() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 
{ CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_2, 32) _Lockit _Lock(0); 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(33) , _Refs < (size_t)(-1))) { CPPTEST_STACK_TRACE_STMT_INFO(34) 
++_Refs; }  CPPTEST_STACK_TRACE_BLOCK_END_INFO(35) 
} CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt6locale5facet7_DecrefEv inline facet *_Decref() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 
{ CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_3, 36) _Lockit _Lock(0); 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(37) , 0 < _Refs && _Refs < (size_t)(-1))) { CPPTEST_STACK_TRACE_STMT_INFO(38) 
--_Refs; }  CPPTEST_STACK_TRACE_STMT_INFO(39) 
return ((_Refs == 0) ? this : (0)); 
} CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

void _Register() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(40) 




_Facet_Register(this); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 

} 


CPPTEST_IMP__ZNSt6locale5facetnwEj inline void *__cdecl operator new(size_t _Size) 
{ 
return (operator new(_Size, _DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 141)); 

} 

CPPTEST_IMP__ZNSt6locale5facetnwEjRKSt15_DebugHeapTag_tPci inline void *__cdecl operator new(size_t _Size, const _DebugHeapTag_t &
_Tag, char *_File, int _Line) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(41) 
return (::operator new(_Size, _Tag, _File, _Line)); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt6locale5facetdlEPvRKSt15_DebugHeapTag_tPci inline void __cdecl operator delete(void *_Ptr, const _DebugHeapTag_t &, char *, int) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(42) 
operator delete(_Ptr); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt6locale5facetdlEPv inline void __cdecl operator delete(void *_Ptr) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(43) 
_DebugHeapDelete((facet *)_Ptr); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 



CPPTEST_IMP__ZNSt6locale5facetD9Ev inline virtual ~facet() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 


protected: CPPTEST_IMP__ZNSt6locale5facetC9Ej inline explicit facet(size_t _Initrefs = 0) : _Refs(_Initrefs) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 


private: size_t _Refs; 

facet(const facet &); 

facet &operator=(const facet &); 
#line 184
static void __cdecl _Facet_Register(facet *); 

}; 


/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4275) /* Removed pragma: #pragma warning(disable: 4275)*/

class _Locimp : public facet { 



protected: CPPTEST_IMP__ZNSt6locale7_LocimpD9Ev inline virtual ~_Locimp() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(44) 
_Locimp_dtor(this); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 


private: static void __cdecl _Locimp_dtor(_Locimp *); 
static void __cdecl _Locimp_Addfac(_Locimp *, facet *, size_t); 

static void __cdecl _Locimp_ctor(_Locimp *, const _Locimp &); 

friend class locale; 

CPPTEST_IMP__ZNSt6locale7_LocimpC9Eb inline _Locimp(bool _Transparent = false) : facet(1), _Facetvec((0)), _Facetcount((0)), _Catmask(none), _Xparent(_Transparent), _Name("*") 



{ 
} 

CPPTEST_IMP__ZNSt6locale7_LocimpC9ERKS0_ inline _Locimp(const _Locimp &_Right) : facet(1), _Facetvec((0)), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name((_Right._Name).c_str()) 



{ 
_Locimp_ctor(this, _Right); 
} 

CPPTEST_IMP__ZNSt6locale7_Locimp7_AddfacEPNS_5facetEj inline void _Addfac(facet *_Pfacet, size_t _Id) 
{ 
_Locimp_Addfac(this, _Pfacet, _Id); 
} 

static _Locimp *__cdecl _Makeloc(const _Locinfo &, category, _Locimp *, const locale *); 


static void __cdecl _Makewloc(const _Locinfo &, category, _Locimp *, const locale *); 



static void __cdecl _Makeushloc(const _Locinfo &, category, _Locimp *, const locale *); 



static void __cdecl _Makexloc(const _Locinfo &, category, _Locimp *, const locale *); 


facet **_Facetvec; 
size_t _Facetcount; 
category _Catmask; 
bool _Xparent; 
_Yarn< char>  _Name; 

__declspec(dllimport) static _Locimp *_Clocptr; 


_Locimp &operator=(const _Locimp &); 
}; 

/* Removed pragma: #pragma warning(pop)*/

template < class _Elem,
  class _Traits,
  class _Alloc >
  bool operator ( ) ( const basic_string < _Elem, _Traits, _Alloc > & _Left,
   const basic_string < _Elem, _Traits, _Alloc > & _Right ) const
  {
  const :: std :: collate < _Elem > & _Coll_fac =
   :: std :: use_facet < :: std :: collate < _Elem > > ( * this );

  return ( _Coll_fac . compare ( _Left . c_str ( ), _Left . c_str ( ) + _Left . size ( ),
   _Right . c_str ( ), _Right . c_str ( ) + _Right . size ( ) ) < 0 );
  }

template < class _Facet >
  locale combine ( const locale & _Loc ) const
  {
  _Facet * _Facptr;

  try {
   _Facptr = ( _Facet * ) & :: std :: use_facet < _Facet > ( _Loc );
  } catch ( ... ) {
   _Xruntime_error ( "locale::combine facet missing" );
  }

  _Locimp * _Newimp = new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 281 ) _Locimp ( * _Ptr );
  _Newimp -> _Addfac ( _Facptr, _Facet :: id );
  _Newimp -> _Catmask = 0;
  _Newimp -> _Name = "*";
  return ( locale ( _Newimp ) );
  }

template < class _Facet >
  locale ( const locale & _Loc, const _Facet * _Facptr )
   : _Ptr ( new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 290 ) _Locimp ( * _Loc . _Ptr ) )
  {
  if ( _Facptr != 0 )
   {
   _Ptr -> _Addfac ( ( _Facet * ) _Facptr, _Facet :: id );
   if ( _Facet :: _Getcat ( ) != ( size_t ) ( - 1 ) )
    {
    _Ptr -> _Catmask = 0;
    _Ptr -> _Name = "*";
    }
   }
  }

locale(_Uninitialized) 
{ 
} 

locale(const locale &_Right) throw() : _Ptr(_Right._Ptr) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(45) 
(_Ptr)->_Incref(); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

locale() throw() : _Ptr(_Init()) 

{ 
_Getgloballocale()->_Incref(); 
} 

locale(const locale &_Loc, const locale &_Other, category 
_Cat) : _Ptr(new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 321) _Locimp(*(_Loc._Ptr))) 

{ 
try { 
{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, (_Loc._Ptr->_Name).c_str()); 
_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask, (_Other._Ptr->_Name).c_str()), _Cat, _Ptr, &_Other); 

} 
} catch (...) { 
::std::_DebugHeapDelete((_Ptr)->_Decref()); 
throw; 
}  
} 

explicit locale(const char *_Locname, category 
_Cat = all) : _Ptr(new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 336) _Locimp) 

{ 
try { 
_Init(); 
{ _Locinfo _Lobj(_Cat, _Locname); 
if (this->_Badname(_Lobj)) 
_Xruntime_error("bad locale name");   
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); 
} 
} catch (...) { 
::std::_DebugHeapDelete((_Ptr)->_Decref()); 
throw; 
}  
} 

locale(const locale &_Loc, const char *_Locname, category 
_Cat) : _Ptr(new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 353) _Locimp(*(_Loc._Ptr))) 

{ 
try { 
{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, (_Loc._Ptr->_Name).c_str()); 
bool _Hadname = !this->_Badname(_Lobj); 
_Lobj._Addcats(_Cat, _Locname); 

if (_Hadname && this->_Badname(_Lobj)) 
_Xruntime_error("bad locale name");   
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); 
} 
} catch (...) { 
::std::_DebugHeapDelete((_Ptr)->_Decref()); 
throw; 
}  
} 


explicit locale(const string &_Str, category 
_Cat = all) : _Ptr(new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 373) _Locimp) 

{ 
try { 
_Init(); 
_Locinfo _Lobj(_Cat, _Str.c_str()); 

if (this->_Badname(_Lobj)) 
_Xruntime_error("bad locale name");   
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); 
} catch (...) { 
::std::_DebugHeapDelete((_Ptr)->_Decref()); 
throw; 
}  
} 

locale(const locale &_Loc, const string &_Str, category 
_Cat) : _Ptr(new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 390) _Locimp(*(_Loc._Ptr))) 

{ 
try { 
_Locinfo _Lobj(_Loc._Ptr->_Catmask, (_Loc._Ptr->_Name).c_str()); 
bool _Hadname = !this->_Badname(_Lobj); 
_Lobj._Addcats(_Cat, _Str.c_str()); 

if (_Hadname && this->_Badname(_Lobj)) 
_Xruntime_error("bad locale name");   
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); 
} catch (...) { 
::std::_DebugHeapDelete((_Ptr)->_Decref()); 
throw; 
}  
} 



~locale() throw() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(46) , _Ptr != 0)) { CPPTEST_STACK_TRACE_STMT_INFO(47) 
::std::_DebugHeapDelete((_Ptr)->_Decref()); }  CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

locale &operator=(const locale &_Right) throw() 
{ 
if (_Ptr != _Right._Ptr) 
{ 
::std::_DebugHeapDelete((_Ptr)->_Decref()); 
_Ptr = _Right._Ptr; 
(_Ptr)->_Incref(); 
}  
return (*this); 
} 

string name() const 
{ 
return ((_Ptr->_Name).c_str()); 
} 

const char *c_str() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(48) 
return ((_Ptr->_Name).c_str()); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

const facet *_Getfacet(size_t _Id) const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 
CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_4, 49) const facet *_Facptr = (_Id < _Ptr->_Facetcount) ? (_Ptr->_Facetvec)[_Id] : (0); 

if ((CPPTEST_STACK_TRACE_IF_COND_INFO(50) , _Facptr != 0 || !_Ptr->_Xparent)) {CPPTEST_STACK_TRACE_STMT_INFO(51) 
return (_Facptr); } else 

{ 
CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_5, 52) _Locimp *_Ptr = _Getgloballocale(); CPPTEST_STACK_TRACE_STMT_INFO(53) 
return ((_Id < _Ptr->_Facetcount) ? (_Ptr->_Facetvec)[_Id] : (0)); 


}  CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

bool operator==(const locale &_Loc) const 
{ 
return (_Ptr == _Loc._Ptr || (this->name()).compare("*") != 0 && (this->name()).compare(_Loc.name()) == 0); 

} 

bool operator!=(const locale &_Right) const 
{ 
return (!((*this == _Right))); 
} 

__declspec(dllimport) static const locale &__cdecl classic(); 

__declspec(dllimport) static locale __cdecl global(const locale &); 

__declspec(dllimport) static locale __cdecl empty(); 


private: locale(_Locimp *_Ptrimp) : _Ptr(_Ptrimp) 

{ 
} 

__declspec(dllimport) static _Locimp *__cdecl _Init(); 
CPPTEST_IMP__ZNSt6locale16_GetgloballocaleEv static _Locimp *__cdecl _Getgloballocale(); 
__declspec(dllimport) static void __cdecl _Setgloballocale(void *); 

bool _Badname(const _Locinfo &_Lobj) 
{ 
return (::strcmp(_Lobj._Getname(), "*") == 0); 
} 

_Locimp *_Ptr; 
}; 


template < class _Facet >
 struct _Facetptr{ 

static const locale::facet * _Psave; 
};

template < class _Facet >
                         const locale :: facet * _Facetptr < _Facet > ::
  _Psave = 0;
#line 501
template < class _Facet > inline
 const _Facet & __cdecl use_facet ( const locale & _Loc )

 {
 { :: std :: _Lockit _Lock ( 0 );
  const locale :: facet * _Psave =
   _Facetptr < _Facet > :: _Psave;

  size_t _Id = _Facet :: id;
  const locale :: facet * _Pf = _Loc . _Getfacet ( _Id );

  if ( _Pf != 0 )
   ;
  else if ( _Psave != 0 )
   _Pf = _Psave;
  else if ( _Facet :: _Getcat ( & _Psave, & _Loc ) == ( size_t ) ( - 1 ) )



   throw bad_cast ( );





  else
   {
   _Pf = _Psave;
   _Facetptr < _Facet > :: _Psave = _Psave;

   locale :: facet * _Pfmod = ( _Facet * ) _Psave;
   _Pfmod -> _Incref ( );
   _Pfmod -> _Register ( );
   }

  return ( ( const _Facet & ) ( * _Pf ) );
 }
 }


template < class _Elem,
 class _InIt > inline
 int __cdecl _Getloctxt ( _InIt & _First, _InIt & _Last, size_t _Numfields,
  const _Elem * _Ptr )
 {
 for ( size_t _Off = 0; _Ptr [ _Off ] != ( _Elem ) 0; ++ _Off )
  if ( _Ptr [ _Off ] == _Ptr [ 0 ] )
   ++ _Numfields;
 string _Str ( _Numfields, '\000' );

 int _Ans = - 2;
 for ( size_t _Column = 1;; ++ _Column, ++ _First, _Ans = - 1 )
  {
  bool _Prefix = false;
  size_t _Off = 0;
  size_t _Field = 0;

  for (; _Field < _Numfields; ++ _Field )
   {
   for (; _Ptr [ _Off ] != ( _Elem ) 0 && _Ptr [ _Off ] != _Ptr [ 0 ]; ++ _Off )
    ;

   if ( _Str [ _Field ] != '\000' )
    _Off += _Str [ _Field ];
   else if ( _Ptr [ _Off += _Column ] == _Ptr [ 0 ]
    || _Ptr [ _Off ] == ( _Elem ) 0 )
    {
    _Str [ _Field ] = ( char ) ( _Column < 127
     ? _Column : 127 );
    _Ans = ( int ) _Field;
    }
   else if ( _First == _Last || _Ptr [ _Off ] != * _First )
    _Str [ _Field ] = ( char ) ( _Column < 127
     ? _Column : 127 );
   else
    _Prefix = true;
   }

  if ( ! _Prefix || _First == _Last )
   break;
  }
 return ( _Ans );
 }
#line 589
template < class _Elem > inline
 char __cdecl _Maklocbyte ( _Elem _Char,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( char ) ( unsigned char ) _Char );
 }


template<> inline char __cdecl _Maklocbyte(__wchar_t _Char, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
char _Byte = '\000'; 
mbstate_t _Mbst1 = 0; 
_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt); 
return (_Byte); 
} 



template<> inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
char _Byte = '\000'; 
mbstate_t _Mbst1 = 0; 
_Wcrtomb(&_Byte, (__wchar_t)_Char, &_Mbst1, &_Cvt); 
return (_Byte); 
} 
#line 622
template < class _Elem > inline
 _Elem __cdecl _Maklocchr ( char _Byte, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( _Elem ) ( unsigned char ) _Byte );
 }


template<> inline __wchar_t __cdecl _Maklocchr(char _Byte, __wchar_t *, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
__wchar_t _Wc = L'\x0'; 
mbstate_t _Mbst1 = 0; 
_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt); 
return (_Wc); 
} 



template<> inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
unsigned short _Wc = ((unsigned short)0); 
mbstate_t _Mbst1 = 0; 
_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt); 
return (_Wc); 
} 
#line 655
template < class _Elem > inline
 _Elem * __cdecl _Maklocstr ( const char * _Ptr, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 size_t _Count = :: strlen ( _Ptr ) + 1;
 _Elem * _Ptrdest = new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 660 ) _Elem [ _Count ];

 #pragma warning(push)
 #pragma warning(disable: 6011)
 for ( _Elem * _Ptrnext = _Ptrdest; 0 < _Count; -- _Count, ++ _Ptrnext, ++ _Ptr )
  * _Ptrnext = ( _Elem ) ( unsigned char ) * _Ptr;
 #pragma warning(pop)

 return ( _Ptrdest );
 }


template<> inline __wchar_t *__cdecl _Maklocstr(const char *_Ptr, __wchar_t *, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
size_t _Count, _Count1; 
size_t _Wchars; 
const char *_Ptr1; 
int _Bytes; 
__wchar_t _Wc; 
mbstate_t _Mbst1 = 0; 

_Count1 = ::strlen(_Ptr) + 1; 
for (((_Count = _Count1), (_Wchars = 0)), (_Ptr1 = _Ptr); 0 < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) 

if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) 
break;     
++_Wchars; 

__wchar_t *_Ptrdest = new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 689) __wchar_t [_Wchars]; 
__wchar_t *_Ptrnext = _Ptrdest; 
mbstate_t _Mbst2 = 0; 

/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 6011) /* Removed pragma: #pragma warning(disable: 6011)*/
for (; 0 < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) 

if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) 
break;     
*_Ptrnext = L'\x0'; 
/* Removed pragma: #pragma warning(pop)*/

return (_Ptrdest); 
} 



template<> inline unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
size_t _Count, _Count1; 
size_t _Wchars; 
const char *_Ptr1; 
int _Bytes; 
unsigned short _Wc; 
mbstate_t _Mbst1 = 0; 

_Count1 = ::strlen(_Ptr) + 1; 
for (((_Count = _Count1), (_Wchars = 0)), (_Ptr1 = _Ptr); 0 < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) 

if ((_Bytes = _Mbrtowc((__wchar_t *)(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) 

break;     
++_Wchars; 

__wchar_t *_Ptrdest = new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 725) __wchar_t [_Wchars]; 
__wchar_t *_Ptrnext = _Ptrdest; 
mbstate_t _Mbst2 = 0; 
for (; 0 < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) 

if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) 
break;     
*_Ptrnext = L'\x0'; 
return ((unsigned short *)_Ptrdest); 
} 



/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4275) /* Removed pragma: #pragma warning(disable: 4275)*/

class codecvt_base : public locale::facet { 




public: enum { 
ok, partial, error, noconv}; 
typedef int result; 

CPPTEST_IMP__ZNSt12codecvt_baseC9Ej inline codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) 

{ 
} 

CPPTEST_IMP__ZNKSt12codecvt_base13always_noconvEv inline bool always_noconv() const throw() 
{ 
return (this->do_always_noconv()); 
} 

CPPTEST_IMP__ZNKSt12codecvt_base10max_lengthEv inline int max_length() const throw() 
{ 
return (this->do_max_length()); 
} 

CPPTEST_IMP__ZNKSt12codecvt_base8encodingEv inline int encoding() const throw() 
{ 
return (this->do_encoding()); 
} 

CPPTEST_IMP__ZNSt12codecvt_baseD9Ev inline virtual ~codecvt_base() 
{ 
} 


protected: CPPTEST_IMP__ZNKSt12codecvt_base16do_always_noconvEv inline virtual bool do_always_noconv() const throw() 
{ 
return (true); 
} 

CPPTEST_IMP__ZNKSt12codecvt_base13do_max_lengthEv inline virtual int do_max_length() const throw() 
{ 
return (1); 
} 

CPPTEST_IMP__ZNKSt12codecvt_base11do_encodingEv inline virtual int do_encoding() const throw() 
{ 
return (1); 
} 
public:
    __declspec(dllimport) codecvt_base(const codecvt_base&);
    __declspec(dllimport) codecvt_base& operator=(const codecvt_base&);

#line 789
}; 

/* Removed pragma: #pragma warning(pop)*/


template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt
  : public codecvt_base{ 


public: typedef _Elem intern_type; 
typedef _Byte extern_type; 
typedef _Statype state_type; 

result in ( _Statype & _State,
  const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
  _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const


  {
  return ( do_in ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

result out ( _Statype & _State,
  const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const


  {
  return ( do_out ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

result unshift ( _Statype & _State,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const

  {
  return ( do_unshift ( _State, _First2, _Last2, _Mid2 ) );
  }

int length ( const _Statype & _State, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const

  {
  return ( do_length ( _State, _First1, _Last1, _Count ) );
  }

static locale::id id; 

explicit codecvt ( size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  _Init ( _Locinfo ( ) );
  }

 codecvt ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  _Init ( _Lobj );
  }

static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )

  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 851 ) codecvt < _Elem, _Byte, _Statype > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 2 );
  }


protected: virtual ~ codecvt ( )
  {
  }

void _Init ( const _Locinfo & )
  {
  }

virtual result do_in ( _Statype &,
  const _Byte * _First1, const _Byte *, const _Byte * & _Mid1,
  _Elem * _First2, _Elem *, _Elem * & _Mid2 ) const


  {
  _Mid1 = _First1, _Mid2 = _First2;
  return ( noconv );
  }

virtual result do_out ( _Statype &,
  const _Elem * _First1, const _Elem *, const _Elem * & _Mid1,
  _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const


  {
  _Mid1 = _First1, _Mid2 = _First2;
  return ( noconv );
  }

virtual result do_unshift ( _Statype &,
  _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const

  {
  _Mid2 = _First2;
  return ( noconv );
  }

virtual int do_length ( const _Statype &, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const

  {
  return ( ( int ) ( _Count < ( size_t ) ( _Last1 - _First1 )
   ? _Count : _Last1 - _First1 ) );
  }
};


template < class _Elem,
 class _Byte,
 class _Statype >
                         locale :: id codecvt < _Elem, _Byte, _Statype > :: id;
#line 1503
#pragma pack(8)
template<> 
#line 1503
class codecvt< __wchar_t, char, int>  : public codecvt_base { 



public: typedef __wchar_t _Elem; 
typedef char _Byte; 
typedef _Mbstatet _Statype; 
typedef _Elem intern_type; 
typedef _Byte extern_type; 
typedef _Statype state_type; 

CPPTEST_IMP__ZNKSt7codecvtIwciE2inERiPKcS3_RS3_PwS5_RS5_ inline result in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
return (this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2)); 

} 

CPPTEST_IMP__ZNKSt7codecvtIwciE3outERiPKwS3_RS3_PcS5_RS5_ inline result out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return (this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2)); 

} 

CPPTEST_IMP__ZNKSt7codecvtIwciE7unshiftERiPcS2_RS2_ inline result unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return (this->do_unshift(_State, _First2, _Last2, _Mid2)); 

} 

CPPTEST_IMP__ZNKSt7codecvtIwciE6lengthERKiPKcS4_j inline int length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
return (this->do_length(_State, _First1, _Last1, _Count)); 
} 

__declspec(dllimport) static locale::id id; 

CPPTEST_IMP__ZNSt7codecvtIwciEC9Ej inline explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) 

{ 
{ _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

CPPTEST_IMP__ZNSt7codecvtIwciEC9ERKSt8_Locinfoj inline codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

CPPTEST_IMP__ZNSt7codecvtIwciE7_GetcatEPPKNSt6locale5facetEPKS1_ static inline size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if (_Ppf != 0 && *_Ppf == 0) 
*_Ppf = (new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 1563) std::codecvt< __wchar_t, char, int> (((_Locinfo)(_Ploc->c_str()))));   

return (2); 
} 


protected: CPPTEST_IMP__ZNSt7codecvtIwciED9Ev inline virtual ~codecvt() 
{ 
} 

CPPTEST_IMP__ZNSt7codecvtIwciE5_InitERKSt8_Locinfo inline void _Init(const _Locinfo &_Lobj) 
{ 
_Cvt = _Lobj._Getcvt(); 
} 

CPPTEST_IMP__ZNKSt7codecvtIwciE5do_inERiPKcS3_RS3_PwS5_RS5_ inline virtual result do_in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
_Debug_range(_First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1582); 
_Debug_range(_First2, _Last2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1583); 
(_Mid1 = _First1), (_Mid2 = _First2); 
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
int _Bytes; 

while (_Mid1 != _Last1 && _Mid2 != _Last2) 
switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1, &_State, &(_Cvt))) 

{ 
case -2:  
_Mid1 = _Last1; 
return (_Ans); 

case -1:  
return error; 

case 0:  
if (*_Mid2 == (_Elem)0) 
_Bytes = (int)::strlen(_Mid1) + 1;   


default:  
if (_Bytes == -3) 
_Bytes = 0;   
_Mid1 += _Bytes; 
++_Mid2; 
_Ans = ok; 
}    
return (_Ans); 
} 

CPPTEST_IMP__ZNKSt7codecvtIwciE6do_outERiPKwS3_RS3_PcS5_RS5_ inline virtual result do_out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
_Debug_range(_First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1618); 
_Debug_range(_First2, _Last2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1619); 
(_Mid1 = _First1), (_Mid2 = _First2); 
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
int _Bytes; 

while (_Mid1 != _Last1 && _Mid2 != _Last2) 
if ((int)___mb_cur_max_func() <= _Last2 - _Mid2) 
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) 

return error;  else 

((++_Mid1), (_Mid2 += _Bytes)), (_Ans = ok);    else 

{ 
_Byte _Buf[5]; 
_Statype _Stsave = _State; 

if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) 

return error;  else 
if (_Last2 - _Mid2 < _Bytes) 
{ 
_State = _Stsave; 
return (_Ans); 
} else 

{ 
::memcpy(_Mid2, _Buf, _Bytes); 
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = ok); 
}    
}    
return (_Ans); 
} 

CPPTEST_IMP__ZNKSt7codecvtIwciE10do_unshiftERiPcS2_RS2_ inline virtual result do_unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
_Debug_range(_First2, _Last2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1656); 
_Mid2 = _First2; 
result _Ans = (ok); 
int _Bytes; 
_Byte _Buf[5]; 
_Statype _Stsave = _State; 

if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) 
_Ans = error;  else 
if (_Last2 - _Mid2 < --_Bytes) 
{ 
_State = _Stsave; 
_Ans = partial; 
} else 
if (0 < _Bytes) 
{ 
::memcpy(_Mid2, _Buf, _Bytes); 
_Mid2 += _Bytes; 
}      
return (_Ans); 
} 

CPPTEST_IMP__ZNKSt7codecvtIwciE9do_lengthERKiPKcS4_j inline virtual int do_length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
#line 1686
_Debug_range(_First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1686); 
int _Wchars; 
const _Byte *_Mid1; 
_Statype _Mystate = _State; 

for ((_Wchars = 0), (_Mid1 = _First1); (size_t)_Wchars < _Count && _Mid1 != _Last1;) 

{ 
int _Bytes; 
_Elem _Ch; 

switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1, &_Mystate, &(_Cvt))) 

{ 
case -2:  
return (_Wchars); 

case -1:  
return (_Wchars); 

case 0:  
if (_Ch == (_Elem)0) 
_Bytes = (int)::strlen(_Mid1) + 1;   


default:  
if (_Bytes == -3) 
_Bytes = 0;   
_Mid1 += _Bytes; 
++_Wchars; 
}  
}  
return (_Wchars); 

} 

CPPTEST_IMP__ZNKSt7codecvtIwciE16do_always_noconvEv inline virtual bool do_always_noconv() const throw() 
{ 
return (false); 
} 

CPPTEST_IMP__ZNKSt7codecvtIwciE13do_max_lengthEv inline virtual int do_max_length() const throw() 
{ 
return (5); 
} 


private: _Locinfo::_Cvtvec _Cvt; 
public:
    __declspec(dllimport) codecvt(const codecvt&);
    __declspec(dllimport) codecvt& operator=(const codecvt&);

#line 1734
}; 
#pragma pack()



#pragma pack(8)
template<> 
#line 1739
class codecvt< unsigned short, char, int>  : public codecvt_base { 



public: typedef unsigned short _Elem; 
typedef char _Byte; 
typedef _Mbstatet _Statype; 
typedef _Elem intern_type; 
typedef _Byte extern_type; 
typedef _Statype state_type; 

CPPTEST_IMP__ZNKSt7codecvtItciE2inERiPKcS3_RS3_PtS5_RS5_ inline result in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
return (this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2)); 

} 

CPPTEST_IMP__ZNKSt7codecvtItciE3outERiPKtS3_RS3_PcS5_RS5_ inline result out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return (this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2)); 

} 

CPPTEST_IMP__ZNKSt7codecvtItciE7unshiftERiPcS2_RS2_ inline result unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return (this->do_unshift(_State, _First2, _Last2, _Mid2)); 

} 

CPPTEST_IMP__ZNKSt7codecvtItciE6lengthERKiPKcS4_j inline int length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
return (this->do_length(_State, _First1, _Last1, _Count)); 
} 

__declspec(dllimport) static locale::id id; 

CPPTEST_IMP__ZNSt7codecvtItciEC9Ej inline explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) 

{ 
{ _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

CPPTEST_IMP__ZNSt7codecvtItciEC9ERKSt8_Locinfoj inline codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

CPPTEST_IMP__ZNSt7codecvtItciE7_GetcatEPPKNSt6locale5facetEPKS1_ static inline size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if (_Ppf != 0 && *_Ppf == 0) 
*_Ppf = (new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 1799) std::codecvt< unsigned short, char, int> (((_Locinfo)(_Ploc->c_str()))));   

return (2); 
} 


protected: CPPTEST_IMP__ZNSt7codecvtItciED9Ev inline virtual ~codecvt() 
{ 
} 

CPPTEST_IMP__ZNSt7codecvtItciE5_InitERKSt8_Locinfo inline void _Init(const _Locinfo &_Lobj) 
{ 
_Cvt = _Lobj._Getcvt(); 
} 

CPPTEST_IMP__ZNKSt7codecvtItciE5do_inERiPKcS3_RS3_PtS5_RS5_ inline virtual result do_in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
_Debug_range(_First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1818); 
_Debug_range(_First2, _Last2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1819); 
(_Mid1 = _First1), (_Mid2 = _First2); 
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
int _Bytes; 

while (_Mid1 != _Last1 && _Mid2 != _Last2) 
switch (_Bytes = _Mbrtowc((__wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1, &_State, &(_Cvt))) 

{ 
case -2:  
_Mid1 = _Last1; 
return (_Ans); 

case -1:  
return error; 

case 0:  
if (*_Mid2 == (_Elem)0) 
_Bytes = (int)::strlen(_Mid1) + 1;   


default:  
if (_Bytes == -3) 
_Bytes = 0;   
_Mid1 += _Bytes; 
++_Mid2; 
_Ans = ok; 
}    
return (_Ans); 
} 

CPPTEST_IMP__ZNKSt7codecvtItciE6do_outERiPKtS3_RS3_PcS5_RS5_ inline virtual result do_out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
_Debug_range(_First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1854); 
_Debug_range(_First2, _Last2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1855); 
(_Mid1 = _First1), (_Mid2 = _First2); 
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
int _Bytes; 

while (_Mid1 != _Last1 && _Mid2 != _Last2) 
if ((int)___mb_cur_max_func() <= _Last2 - _Mid2) 
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) 

return error;  else 

((++_Mid1), (_Mid2 += _Bytes)), (_Ans = ok);    else 

{ 
_Byte _Buf[5]; 
_Statype _Stsave = _State; 

if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) 

return error;  else 
if (_Last2 - _Mid2 < _Bytes) 
{ 
_State = _Stsave; 
return (_Ans); 
} else 

{ 
::memcpy(_Mid2, _Buf, _Bytes); 
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = ok); 
}    
}    
return (_Ans); 
} 

CPPTEST_IMP__ZNKSt7codecvtItciE10do_unshiftERiPcS2_RS2_ inline virtual result do_unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
_Debug_range(_First2, _Last2, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1892); 
_Mid2 = _First2; 
result _Ans = (ok); 
int _Bytes; 
_Byte _Buf[5]; 
_Statype _Stsave = _State; 

if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) 
_Ans = error;  else 
if (_Last2 - _Mid2 < --_Bytes) 
{ 
_State = _Stsave; 
_Ans = partial; 
} else 
if (0 < _Bytes) 
{ 
::memcpy(_Mid2, _Buf, _Bytes); 
_Mid2 += _Bytes; 
}      
return (_Ans); 
} 

CPPTEST_IMP__ZNKSt7codecvtItciE9do_lengthERKiPKcS4_j inline virtual int do_length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
_Debug_range(_First1, _Last1, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 1917); 
int _Wchars; 
const _Byte *_Mid1; 
_Statype _Mystate = _State; 

for ((_Wchars = 0), (_Mid1 = _First1); (size_t)_Wchars < _Count && _Mid1 != _Last1;) 

{ 
int _Bytes; 
_Elem _Ch; 

switch (_Bytes = _Mbrtowc((__wchar_t *)(&_Ch), _Mid1, _Last1 - _Mid1, &_Mystate, &(_Cvt))) 

{ 
case -2:  
return (_Wchars); 

case -1:  
return (_Wchars); 

case 0:  
if (_Ch == (_Elem)0) 
_Bytes = (int)::strlen(_Mid1) + 1;   


default:  
if (_Bytes == -3) 
_Bytes = 0;   
_Mid1 += _Bytes; 
++_Wchars; 
}  
}  
return (_Wchars); 
} 

CPPTEST_IMP__ZNKSt7codecvtItciE16do_always_noconvEv inline virtual bool do_always_noconv() const throw() 
{ 
return (false); 
} 

CPPTEST_IMP__ZNKSt7codecvtItciE13do_max_lengthEv inline virtual int do_max_length() const throw() 
{ 
return (5); 
} 


private: _Locinfo::_Cvtvec _Cvt; 
public:
    __declspec(dllimport) codecvt(const codecvt&);
    __declspec(dllimport) codecvt& operator=(const codecvt&);

#line 1964
}; 
#pragma pack()


template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt_byname
  : public codecvt < _Elem, _Byte, _Statype >{ 


public: explicit codecvt_byname ( const char * _Locname, size_t _Refs = 0 )
  : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Locname ), _Refs )
  {
  }


explicit codecvt_byname ( const string & _Str, size_t _Refs = 0 )
  : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Str . c_str ( ) ), _Refs )
  {
  }



protected: virtual ~ codecvt_byname ( )
  {
  }
};


/* Removed pragma: #pragma warning(push)*/
#pragma warning(disable: 4275) /* Removed pragma: #pragma warning(disable: 4275)*/

#pragma pack(8)
#line 1997
struct ctype_base : public locale::facet { 



enum { 
alnum = 0x107, alpha = 0x103, 
cntrl = 0x20, digit = 0x4, graph = 0x117, 
lower = 0x2, print = 0x1d7, 
punct = 0x10, space = 0x48, upper = 0x1, 
xdigit = 0x80}; 
typedef short mask; 

CPPTEST_IMP__ZNSt10ctype_baseC9Ej inline ctype_base(size_t _Refs = 0) : locale::facet(_Refs) 

{ 
} 

CPPTEST_IMP__ZNSt10ctype_baseD9Ev inline virtual ~ctype_base() 
{ 
} 
public:
    __declspec(dllimport) ctype_base(const ctype_base&);
    __declspec(dllimport) ctype_base& operator=(const ctype_base&);

#line 2017
}; 
#pragma pack()
/* Removed pragma: #pragma warning(pop)*/


template < class _Elem >
 class ctype
  : public ctype_base{ 


public: typedef _Elem char_type; 

bool is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( do_is ( _Maskval, _Ch ) );
  }

const _Elem * is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const

  {
  return ( do_is ( _First, _Last, _Dest ) );
  }

const _Elem * scan_is ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const

  {
  return ( do_scan_is ( _Maskval, _First, _Last ) );
  }

const _Elem * scan_not ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const

  {
  return ( do_scan_not ( _Maskval, _First, _Last ) );
  }

_Elem tolower ( _Elem _Ch ) const
  {
  return ( do_tolower ( _Ch ) );
  }

const _Elem * tolower ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_tolower ( _First, _Last ) );
  }

_Elem toupper ( _Elem _Ch ) const
  {
  return ( do_toupper ( _Ch ) );
  }

const _Elem * toupper ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_toupper ( _First, _Last ) );
  }

_Elem widen ( char _Byte ) const
  {
  return ( do_widen ( _Byte ) );
  }

const char * widen ( const char * _First, const char * _Last,
  _Elem * _Dest ) const

  {
  return ( do_widen ( _First, _Last, _Dest ) );
  }

char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  return ( do_narrow ( _Ch, _Dflt ) );
  }

const _Elem * narrow ( const _Elem * _First, const _Elem * _Last,
  char _Dflt, char * _Dest ) const

  {
  return ( do_narrow ( _First, _Last, _Dflt, _Dest ) );
  }

static locale::id id; 

explicit ctype ( size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

 ctype ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  _Init ( _Lobj );
  }

static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )

  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 2114 ) ctype < _Elem > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 2 );
  }


protected: virtual ~ ctype ( )
  {
  if ( _Ctype . _Delfl )
   free ( ( void * ) _Ctype . _Table );
  }

void _Init ( const _Locinfo & _Lobj )
  {
  _Ctype = _Lobj . _Getctype ( );
  }

virtual bool do_is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( ( _Ctype . _Table [ ( unsigned char ) narrow ( _Ch ) ]
   & _Maskval ) != 0 );
  }

virtual const _Elem * do_is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const

  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2140 );
  _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2141 );
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Ctype . _Table [ ( unsigned char ) narrow ( * _First ) ];
  return ( _First );
  }

virtual const _Elem * do_scan_is ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const

  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2150 );
  for (; _First != _Last && ! is ( _Maskval, * _First ); ++ _First )
   ;
  return ( _First );
  }

virtual const _Elem * do_scan_not ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const

  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2159 );
  for (; _First != _Last && is ( _Maskval, * _First ); ++ _First )
   ;
  return ( _First );
  }

virtual _Elem do_tolower ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   return ( _Ch );
  else
   return ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
  }

virtual const _Elem * do_tolower ( _Elem * _First,
  const _Elem * _Last ) const

  {
  _Debug_range ( ( const _Elem * ) _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2177 );
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    * _First = ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
   }
  return ( ( const _Elem * ) _First );
  }

virtual _Elem do_toupper ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   return ( _Ch );
  else
   return ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
  }

virtual const _Elem * do_toupper ( _Elem * _First,
  const _Elem * _Last ) const

  {
  _Debug_range ( ( const _Elem * ) _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2199 );
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    * _First = ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
   }
  return ( ( const _Elem * ) _First );
  }

virtual _Elem do_widen ( char _Byte ) const
  {
  return ( _Maklocchr ( _Byte, ( _Elem * ) 0, _Cvt ) );
  }

virtual const char * do_widen ( const char * _First,
  const char * _Last, _Elem * _Dest ) const

  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2217 );
  _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2218 );
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Maklocchr ( * _First, ( _Elem * ) 0, _Cvt );
  return ( _First );
  }

char _Donarrow ( _Elem _Ch, char _Dflt ) const
  {
  char _Byte;
  if ( _Ch == ( _Elem ) 0 )
   return ( '\000' );
  else if ( ( _Byte = _Maklocbyte ( ( _Elem ) _Ch, _Cvt ) ) == '\000' )
   return ( _Dflt );
  else
   return ( _Byte );
  }

virtual char do_narrow ( _Elem _Ch, char _Dflt ) const
  {
  return ( _Donarrow ( _Ch, _Dflt ) );
  }

virtual const _Elem * do_narrow ( const _Elem * _First,
  const _Elem * _Last, char _Dflt, char * _Dest ) const

  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2243 );
  _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2244 );
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Donarrow ( * _First, _Dflt );
  return ( _First );
  }


private: _Locinfo :: _Ctypevec _Ctype; 
_Locinfo :: _Cvtvec _Cvt; 
};


template < class _Elem >
 locale :: id ctype < _Elem > :: id;



#pragma pack(8)
template<> 
#line 2261
class ctype< char>  : public ctype_base { 


typedef std::ctype< char>  _Myt; 


public: typedef char _Elem; 
typedef _Elem char_type; 

CPPTEST_IMP__ZNKSt5ctypeIcE2isEsc inline bool is(mask _Maskval, _Elem _Ch) const 
{ 
return ((((_Ctype)._Table)[(unsigned char)_Ch] & _Maskval) != 0); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE2isEPKcS2_Ps inline const _Elem *is(const _Elem *_First, const _Elem *
_Last, mask *_Dest) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2278); 
_Debug_pointer(_Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2279); 
for (; _First != _Last; (++_First), (++_Dest)) 
*_Dest = ((_Ctype)._Table)[(unsigned char)(*_First)];   
return (_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE7scan_isEsPKcS2_ inline const _Elem *scan_is(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2288); 
for (; _First != _Last && !this->is(_Maskval, *_First); ++_First) 
;   
return (_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE8scan_notEsPKcS2_ inline const _Elem *scan_not(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2297); 
for (; _First != _Last && this->is(_Maskval, *_First); ++_First) 
;   
return (_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE7tolowerEc inline _Elem tolower(_Elem _Ch) const 
{ 
return (this->do_tolower(_Ch)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE7tolowerEPcPKc inline const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
{ 
return (this->do_tolower(_First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE7toupperEc inline _Elem toupper(_Elem _Ch) const 
{ 
return (this->do_toupper(_Ch)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE7toupperEPcPKc inline const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
{ 
return (this->do_toupper(_First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE5widenEc inline _Elem widen(char _Byte) const 
{ 
return (this->do_widen(_Byte)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE5widenEPKcS2_Pc inline const _Elem *widen(const char *_First, const char *_Last, _Elem *
_Dest) const 
{ 
return (this->do_widen(_First, _Last, _Dest)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE6narrowEcc inline _Elem narrow(_Elem _Ch, char _Dflt = '\000') const 
{ 
return (this->do_narrow(_Ch, _Dflt)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE6narrowEPKcS2_cPc inline const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest) const 
{ 
return (this->do_narrow(_First, _Last, _Dflt, _Dest)); 
} 

__declspec(dllimport) static locale::id id; 

CPPTEST_IMP__ZNSt5ctypeIcEC9EPKsbj inline explicit ctype(const mask *_Table = 0, bool 
_Deletetable = false, size_t 
_Refs = 0) : ctype_base(_Refs) 

{ 
{ _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
if (_Table != 0) 
{ 
this->_Tidy(); 
(_Ctype)._Table = _Table; 
(_Ctype)._Delfl = _Deletetable ? -1 : 0; 
}  
} 

CPPTEST_IMP__ZNSt5ctypeIcEC9ERKSt8_Locinfoj inline ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

CPPTEST_IMP__ZNSt5ctypeIcE7_GetcatEPPKNSt6locale5facetEPKS1_ static inline size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if (_Ppf != 0 && *_Ppf == 0) 
*_Ppf = (new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 2373) std::ctype< char> (((_Locinfo)(_Ploc->c_str()))));   

return (2); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE5tableEv inline const mask *table() const throw() 
{ 
return ((_Ctype)._Table); 
} 

CPPTEST_IMP__ZNSt5ctypeIcE13classic_tableEv static inline const mask *__cdecl classic_table() throw() 
{ 
const _Myt &_Ctype_fac = use_facet< std::ctype< char> > (locale::classic()); 
return (_Ctype_fac.table()); 
} 

__declspec(dllimport) static const size_t table_size = (1 << 8); 



protected: CPPTEST_IMP__ZNSt5ctypeIcED9Ev inline virtual ~ctype() 
{ 
this->_Tidy(); 
} 

CPPTEST_IMP__ZNSt5ctypeIcE5_InitERKSt8_Locinfo inline void _Init(const _Locinfo &_Lobj) 
{ 
_Ctype = _Lobj._Getctype(); 
} 

CPPTEST_IMP__ZNSt5ctypeIcE5_TidyEv inline void _Tidy() 
{ 
if (0 < (_Ctype)._Delfl) 
free((void *)((_Ctype)._Table));  else 
if ((_Ctype)._Delfl < 0) 
delete [] ((void *)((_Ctype)._Table));     
} 

CPPTEST_IMP__ZNKSt5ctypeIcE10do_tolowerEc inline virtual _Elem do_tolower(_Elem _Ch) const 
{ 
return ((_Elem)_Tolower((unsigned char)_Ch, &(_Ctype))); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE10do_tolowerEPcPKc inline virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
_Last) const 
{ 
_Debug_range((const _Elem *)_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2419); 
for (; _First != _Last; ++_First) 
*_First = (_Elem)_Tolower((unsigned char)(*_First), &(_Ctype));   
return ((const _Elem *)_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE10do_toupperEc inline virtual _Elem do_toupper(_Elem _Ch) const 
{ 
return ((_Elem)_Toupper((unsigned char)_Ch, &(_Ctype))); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE10do_toupperEPcPKc inline virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
_Last) const 
{ 
_Debug_range((const _Elem *)_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2433); 
for (; _First != _Last; ++_First) 
*_First = (_Elem)_Toupper((unsigned char)(*_First), &(_Ctype));   
return ((const _Elem *)_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE8do_widenEc inline virtual _Elem do_widen(char _Byte) const 
{ 
return (_Byte); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE8do_widenEPKcS2_Pc inline virtual const _Elem *do_widen(const char *_First, const char *
_Last, _Elem *_Dest) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2447); 
_Debug_pointer(_Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2448); 
::memcpy(_Dest, _First, _Last - _First); 
return (_Last); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE9do_narrowEcc inline virtual _Elem do_narrow(_Elem _Ch, char) const 
{ 
return (_Ch); 
} 

CPPTEST_IMP__ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc inline virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
_Last, char, char *_Dest) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2461); 
_Debug_pointer(_Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2462); 
::memcpy(_Dest, _First, _Last - _First); 
return (_Last); 
} 


private: _Locinfo::_Ctypevec _Ctype; 
public:
    __declspec(dllimport) ctype(const ctype&);
    __declspec(dllimport) ctype& operator=(const ctype&);

#line 2469
}; 
#pragma pack()


#pragma pack(8)
template<> 
#line 2473
class ctype< __wchar_t>  : public ctype_base { 


typedef std::ctype< __wchar_t>  _Myt; 


public: typedef __wchar_t _Elem; 
typedef _Elem char_type; 

CPPTEST_IMP__ZNKSt5ctypeIwE2isEsw inline bool is(mask _Maskval, _Elem _Ch) const 
{ 
return (this->do_is(_Maskval, _Ch)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE2isEPKwS2_Ps inline const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
_Dest) const 
{ 
return (this->do_is(_First, _Last, _Dest)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE7scan_isEsPKwS2_ inline const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return (this->do_scan_is(_Maskval, _First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE8scan_notEsPKwS2_ inline const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return (this->do_scan_not(_Maskval, _First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE7tolowerEw inline _Elem tolower(_Elem _Ch) const 
{ 
return (this->do_tolower(_Ch)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE7tolowerEPwPKw inline const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
{ 
return (this->do_tolower(_First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE7toupperEw inline _Elem toupper(_Elem _Ch) const 
{ 
return (this->do_toupper(_Ch)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE7toupperEPwPKw inline const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
{ 
return (this->do_toupper(_First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE5widenEc inline _Elem widen(char _Byte) const 
{ 
return (this->do_widen(_Byte)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE5widenEPKcS2_Pw inline const char *widen(const char *_First, const char *_Last, _Elem *
_Dest) const 
{ 
return (this->do_widen(_First, _Last, _Dest)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE6narrowEwc inline char narrow(_Elem _Ch, char _Dflt = '\000') const 
{ 
return (this->do_narrow(_Ch, _Dflt)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE6narrowEPKwS2_cPc inline const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest) const 
{ 
return (this->do_narrow(_First, _Last, _Dflt, _Dest)); 
} 

__declspec(dllimport) static locale::id id; 

CPPTEST_IMP__ZNSt5ctypeIwEC9Ej inline explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) 

{ 
{ _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

CPPTEST_IMP__ZNSt5ctypeIwEC9ERKSt8_Locinfoj inline ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

CPPTEST_IMP__ZNSt5ctypeIwE7_GetcatEPPKNSt6locale5facetEPKS1_ static inline size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if (_Ppf != 0 && *_Ppf == 0) 
*_Ppf = (new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 2567) std::ctype< __wchar_t> (((_Locinfo)(_Ploc->c_str()))));   

return (2); 
} 


protected: CPPTEST_IMP__ZNSt5ctypeIwED9Ev inline virtual ~ctype() 
{ 
if ((_Ctype)._Delfl) 
free((void *)((_Ctype)._Table));   
} 

CPPTEST_IMP__ZNSt5ctypeIwE5_InitERKSt8_Locinfo inline void _Init(const _Locinfo &_Lobj) 
{ 
_Ctype = _Lobj._Getctype(); 
_Cvt = _Lobj._Getcvt(); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE5do_isEsw inline virtual bool do_is(mask _Maskval, _Elem _Ch) const 
{ 
return ((::_Getwctype(_Ch, &(_Ctype)) & _Maskval) != 0); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE5do_isEPKwS2_Ps inline virtual const _Elem *do_is(const _Elem *_First, const _Elem *
_Last, mask *_Dest) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2593); 
_Debug_pointer(_Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2594); 
return (::_Getwctypes(_First, _Last, _Dest, &(_Ctype))); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE10do_scan_isEsPKwS2_ inline virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2601); 
for (; _First != _Last && !this->is(_Maskval, *_First); ++_First) 
;   
return (_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE11do_scan_notEsPKwS2_ inline virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2610); 
for (; _First != _Last && this->is(_Maskval, *_First); ++_First) 
;   
return (_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE10do_tolowerEw inline virtual _Elem do_tolower(_Elem _Ch) const 
{ 
return (_Towlower(_Ch, &(_Ctype))); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE10do_tolowerEPwPKw inline virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
_Last) const 
{ 
_Debug_range((const _Elem *)_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2624); 
for (; _First != _Last; ++_First) 
*_First = _Towlower(*_First, &(_Ctype));   
return ((const _Elem *)_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE10do_toupperEw inline virtual _Elem do_toupper(_Elem _Ch) const 
{ 
return (_Towupper(_Ch, &(_Ctype))); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE10do_toupperEPwPKw inline virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
_Last) const 
{ 
_Debug_range((const _Elem *)_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2638); 
for (; _First != _Last; ++_First) 
*_First = _Towupper(*_First, &(_Ctype));   
return ((const _Elem *)_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE8_DowidenEc inline _Elem _Dowiden(char _Byte) const 
{ 
mbstate_t _Mbst = 0; 
__wchar_t _Wc; 
return ((_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? (__wchar_t)((wint_t)(0xffff)) : _Wc); 

} 

CPPTEST_IMP__ZNKSt5ctypeIwE8do_widenEc inline virtual _Elem do_widen(char _Byte) const 
{ 
return (this->_Dowiden(_Byte)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE8do_widenEPKcS2_Pw inline virtual const char *do_widen(const char *_First, const char *
_Last, _Elem *_Dest) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2660); 
_Debug_pointer(_Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2661); 
for (; _First != _Last; (++_First), (++_Dest)) 
*_Dest = this->_Dowiden(*_First);   
return (_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE9_DonarrowEwc inline char _Donarrow(_Elem _Ch, char _Dflt) const 
{ 
char _Buf[5]; 
mbstate_t _Mbst = 0; 
return ((_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : ((_Buf)[0])); 

} 

CPPTEST_IMP__ZNKSt5ctypeIwE9do_narrowEwc inline virtual char do_narrow(_Elem _Ch, char _Dflt) const 
{ 
return (this->_Donarrow(_Ch, _Dflt)); 
} 

CPPTEST_IMP__ZNKSt5ctypeIwE9do_narrowEPKwS2_cPc inline virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *_Dest) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2683); 
_Debug_pointer(_Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2684); 
for (; _First != _Last; (++_First), (++_Dest)) 
*_Dest = this->_Donarrow(*_First, _Dflt);   
return (_First); 
} 


private: _Locinfo::_Ctypevec _Ctype; 
_Locinfo::_Cvtvec _Cvt; 
public:
    __declspec(dllimport) ctype(const ctype&);
    __declspec(dllimport) ctype& operator=(const ctype&);

#line 2693
}; 
#pragma pack()



#pragma pack(8)
template<> 
#line 2698
class ctype< unsigned short>  : public ctype_base { 


typedef std::ctype< unsigned short>  _Myt; 


public: typedef unsigned short _Elem; 
typedef _Elem char_type; 

CPPTEST_IMP__ZNKSt5ctypeItE2isEst inline bool is(mask _Maskval, _Elem _Ch) const 
{ 
return (this->do_is(_Maskval, _Ch)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE2isEPKtS2_Ps inline const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
_Dest) const 
{ 
return (this->do_is(_First, _Last, _Dest)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE7scan_isEsPKtS2_ inline const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return (this->do_scan_is(_Maskval, _First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE8scan_notEsPKtS2_ inline const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return (this->do_scan_not(_Maskval, _First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE7tolowerEt inline _Elem tolower(_Elem _Ch) const 
{ 
return (this->do_tolower(_Ch)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE7tolowerEPtPKt inline const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
{ 
return (this->do_tolower(_First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE7toupperEt inline _Elem toupper(_Elem _Ch) const 
{ 
return (this->do_toupper(_Ch)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE7toupperEPtPKt inline const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
{ 
return (this->do_toupper(_First, _Last)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE5widenEc inline _Elem widen(char _Byte) const 
{ 
return (this->do_widen(_Byte)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE5widenEPKcS2_Pt inline const char *widen(const char *_First, const char *_Last, _Elem *
_Dest) const 
{ 
return (this->do_widen(_First, _Last, _Dest)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE6narrowEtc inline char narrow(_Elem _Ch, char _Dflt = '\000') const 
{ 
return (this->do_narrow(_Ch, _Dflt)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE6narrowEPKtS2_cPc inline const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest) const 
{ 
return (this->do_narrow(_First, _Last, _Dflt, _Dest)); 
} 

__declspec(dllimport) static locale::id id; 

CPPTEST_IMP__ZNSt5ctypeItEC9Ej inline explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) 

{ 
{ _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

CPPTEST_IMP__ZNSt5ctypeItEC9ERKSt8_Locinfoj inline ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

CPPTEST_IMP__ZNSt5ctypeItE7_GetcatEPPKNSt6locale5facetEPKS1_ static inline size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if (_Ppf != 0 && *_Ppf == 0) 
*_Ppf = (new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale", 2792) std::ctype< unsigned short> (((_Locinfo)(_Ploc->c_str()))));   

return (2); 
} 


protected: CPPTEST_IMP__ZNSt5ctypeItED9Ev inline virtual ~ctype() 
{ 
if ((_Ctype)._Delfl) 
free((void *)((_Ctype)._Table));   
} 

CPPTEST_IMP__ZNSt5ctypeItE5_InitERKSt8_Locinfo inline void _Init(const _Locinfo &_Lobj) 
{ 
_Ctype = _Lobj._Getctype(); 
_Cvt = _Lobj._Getcvt(); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE5do_isEst inline virtual bool do_is(mask _Maskval, _Elem _Ch) const 
{ 
return ((::_Getwctype(_Ch, &(_Ctype)) & _Maskval) != 0); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE5do_isEPKtS2_Ps inline virtual const _Elem *do_is(const _Elem *_First, const _Elem *
_Last, mask *_Dest) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2818); 
_Debug_pointer(_Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2819); 
return ((const _Elem *)::_Getwctypes((const __wchar_t *)_First, (const __wchar_t *)_Last, _Dest, &(_Ctype))); 

} 

CPPTEST_IMP__ZNKSt5ctypeItE10do_scan_isEsPKtS2_ inline virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2827); 
for (; _First != _Last && !this->is(_Maskval, *_First); ++_First) 
;   
return (_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE11do_scan_notEsPKtS2_ inline virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2836); 
for (; _First != _Last && this->is(_Maskval, *_First); ++_First) 
;   
return (_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE10do_tolowerEt inline virtual _Elem do_tolower(_Elem _Ch) const 
{ 
return (_Towlower(_Ch, &(_Ctype))); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE10do_tolowerEPtPKt inline virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
_Last) const 
{ 
_Debug_range((const _Elem *)_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2850); 
for (; _First != _Last; ++_First) 
*_First = _Towlower(*_First, &(_Ctype));   
return ((const _Elem *)_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE10do_toupperEt inline virtual _Elem do_toupper(_Elem _Ch) const 
{ 
return (_Towupper(_Ch, &(_Ctype))); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE10do_toupperEPtPKt inline virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
_Last) const 
{ 
_Debug_range((const _Elem *)_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2864); 
for (; _First != _Last; ++_First) 
*_First = _Towupper(*_First, &(_Ctype));   
return ((const _Elem *)_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE8_DowidenEc inline _Elem _Dowiden(char _Byte) const 
{ 
mbstate_t _Mbst = 0; 
unsigned short _Wc; 
return ((_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? (unsigned short)((wint_t)(0xffff)) : _Wc); 

} 

CPPTEST_IMP__ZNKSt5ctypeItE8do_widenEc inline virtual _Elem do_widen(char _Byte) const 
{ 
return (this->_Dowiden(_Byte)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE8do_widenEPKcS2_Pt inline virtual const char *do_widen(const char *_First, const char *
_Last, _Elem *_Dest) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2886); 
_Debug_pointer(_Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2887); 
for (; _First != _Last; (++_First), (++_Dest)) 
*_Dest = this->_Dowiden(*_First);   
return (_First); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE9_DonarrowEtc inline char _Donarrow(_Elem _Ch, char _Dflt) const 
{ 
char _Buf[5]; 
mbstate_t _Mbst = 0; 
return ((_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : ((_Buf)[0])); 

} 

CPPTEST_IMP__ZNKSt5ctypeItE9do_narrowEtc inline virtual char do_narrow(_Elem _Ch, char _Dflt) const 
{ 
return (this->_Donarrow(_Ch, _Dflt)); 
} 

CPPTEST_IMP__ZNKSt5ctypeItE9do_narrowEPKtS2_cPc inline virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *_Dest) const 
{ 
_Debug_range(_First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2909); 
_Debug_pointer(_Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x61\x6c\x65" L"", 2910); 
for (; _First != _Last; (++_First), (++_Dest)) 
*_Dest = this->_Donarrow(*_First, _Dflt);   
return (_First); 
} 


private: _Locinfo::_Ctypevec _Ctype; 
_Locinfo::_Cvtvec _Cvt; 
public:
    __declspec(dllimport) ctype(const ctype&);
    __declspec(dllimport) ctype& operator=(const ctype&);

#line 2919
}; 
#pragma pack()


template < class _Elem >
 class ctype_byname
 : public ctype < _Elem >{ 


public: explicit ctype_byname ( const char * _Locname, size_t _Refs = 0 )
  : ctype < _Elem > ( _Locinfo ( _Locname ), _Refs )
  {
  }


explicit ctype_byname ( const string & _Str, size_t _Refs = 0 )
  : ctype < _Elem > ( _Locinfo ( _Str . c_str ( ) ), _Refs )
  {
  }



protected: virtual ~ ctype_byname ( )
  {
  }
};



#pragma pack(8)
template<> 
#line 2948
class ctype_byname< char>  : public ctype< char>  { 



public: explicit ctype_byname(const char *_Locname, size_t _Refs = 0) : std::ctype< char> (((_Locinfo)(_Locname)), _Refs) 

{ 
} 


explicit ctype_byname(const string &_Str, size_t _Refs = 0) : std::ctype< char> (((_Locinfo)(_Str.c_str())), _Refs) 

{ 
} 



protected: virtual ~ctype_byname() 
{ 
} 
}; 
#pragma pack()


template class __declspec(dllimport) codecvt< char, char, int> ;


}



/* Removed pragma: #pragma warning(pop)*/
#line 11 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\system_error"
/* Removed pragma: #pragma warning(push,3)*/
#line 2980 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
#pragma pack ( pop )
#line 10 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\system_error"
#pragma pack ( push, 8 )
#line 19
namespace std { 

namespace errc { 
enum errc { 
address_family_not_supported = 102, 
address_in_use = 100, 
address_not_available, 
already_connected = 113, 
argument_list_too_long = 7, 
argument_out_of_domain = 33, 
bad_address = 14, 
bad_file_descriptor = 9, 
bad_message = 104, 
broken_pipe = 32, 
connection_aborted = 106, 
connection_already_in_progress = 103, 
connection_refused = 107, 
connection_reset, 
cross_device_link = 18, 
destination_address_required = 109, 
device_or_resource_busy = 16, 
directory_not_empty = 41, 
executable_format_error = 8, 
file_exists = 17, 
file_too_large = 27, 
filename_too_long = 38, 
function_not_supported = 40, 
host_unreachable = 110, 
identifier_removed, 
illegal_byte_sequence = 42, 
inappropriate_io_control_operation = 25, 
interrupted = 4, 
invalid_argument = 22, 
invalid_seek = 29, 
io_error = 5, 
is_a_directory = 21, 
message_size = 115, 
network_down, 
network_reset, 
network_unreachable, 
no_buffer_space, 
no_child_process = 10, 
no_link = 121, 
no_lock_available = 39, 
no_message_available = 120, 
no_message = 122, 
no_protocol_option, 
no_space_on_device = 28, 
no_stream_resources = 124, 
no_such_device_or_address = 6, 
no_such_device = 19, 
no_such_file_or_directory = 2, 
no_such_process, 
not_a_directory = 20, 
not_a_socket = 128, 
not_a_stream = 125, 
not_connected, 
not_enough_memory = 12, 
not_supported = 129, 
operation_canceled = 105, 
operation_in_progress = 112, 
operation_not_permitted = 1, 
operation_not_supported = 130, 
operation_would_block = 140, 
owner_dead = 133, 
permission_denied = 13, 
protocol_error = 134, 
protocol_not_supported, 
read_only_file_system = 30, 
resource_deadlock_would_occur = 36, 
resource_unavailable_try_again = 11, 
result_out_of_range = 34, 
state_not_recoverable = 127, 
stream_timeout = 137, 
text_file_busy = 139, 
timed_out = 138, 
too_many_files_open_in_system = 23, 
too_many_files_open, 
too_many_links = 31, 
too_many_synbolic_link_levels = 114, 
value_too_large = 132, 
wrong_protocol_type = 136
}; 
}

typedef errc::errc generic_errno; 


template < class _Enum >
 struct is_error_code_enum
  : public tr1 :: false_type{ 

};


template < class _Enum >
 struct is_error_condition_enum
  : public tr1 :: false_type{ 

};


template<> struct is_error_condition_enum< errc::errc>  : public tr1::true_type { 


}; 


namespace io_errc { 
enum io_errc { 
stream = 1
}; 
}

typedef io_errc::io_errc _Io_errc; 


class error_code; 
class error_condition; 
class error_category; 

__declspec(dllimport) const error_category &__cdecl generic_category(); 
CPPTEST_IMP__ZSt17iostream_categoryv const error_category &__cdecl iostream_category(); 
__declspec(dllimport) const error_category &__cdecl system_category(); 

class error_category { 


public: typedef int value_type; 

error_category() 
{ 
} 

virtual ~error_category() 
{ 
} 

virtual const char *name() const = 0; 

virtual string message(value_type _Errval) const = 0; 

inline virtual error_condition default_error_condition(value_type _Errval) const; 

inline virtual bool equivalent(value_type _Errval, const error_condition & _Cond) const; 


inline virtual bool equivalent(const error_code & _Code, value_type _Errval) const; 


bool operator==(const error_category &_Right) const 
{ 
return (this == &_Right); 
} 

bool operator!=(const error_category &_Right) const 
{ 
return (!((*this == _Right))); 
} 

bool operator<(const error_category &_Right) const 
{ 
return (this < &_Right); 
} 


private: error_category(const error_category &); 

error_category &operator=(const error_category &); 
}; 


class error_code { 


public: typedef int value_type; 

error_code() : _Myval(0), _Mycat(&system_category()) 


{ 
} 

error_code(value_type _Val, const error_category &_Cat) : _Myval(_Val), _Mycat(&_Cat) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

template < class _Enum >
  error_code ( _Enum _Errcode,
   typename tr1 :: enable_if < is_error_code_enum < _Enum > :: value,
    error_code > :: type * = 0 )
  : _Myval ( 0 ), _Mycat ( 0 )
  {
  * this = make_error_code ( _Errcode );
  }

void assign(value_type _Val, const error_category &_Cat) 
{ 
_Myval = _Val; 
_Mycat = &_Cat; 
} 

template < class _Enum >
  typename tr1 :: enable_if < is_error_code_enum < _Enum > :: value,
   error_code > :: type & operator = ( _Enum _Errcode )
  {
  * this = make_error_code ( _Errcode );
  return ( * this );
  }

void clear() 
{ 
_Myval = 0; 
_Mycat = &system_category(); 
} 

value_type value() const 
{ 
return (_Myval); 
} 

const error_category &category() const 
{ 
return (*(_Mycat)); 
} 

inline error_condition default_error_condition() const; 

string message() const 
{ 
return this->category().message(this->value()); 
} 

operator _Bool_type() const 
{ 
return ((this->value() != 0) ? (&::std::_Bool_struct::_Member) : (0)); 
} 

bool operator!() const 
{ 
return (this->value() == 0); 
} 

bool operator==(const error_code &_Right) const 
{ 
return ((this->category() == _Right.category()) && this->value() == _Right.value()); 

} 

bool operator!=(const error_code &_Right) const 
{ 
return (!((*this == _Right))); 
} 

bool operator<(const error_code &_Right) const 
{ 
return ((this->category() < _Right.category()) || (this->category() == _Right.category()) && this->value() < _Right.value()); 


} 


private: value_type _Myval; 
const error_category *_Mycat; 
}; 


class error_condition { 


public: typedef int value_type; 

error_condition() : _Myval(0), _Mycat(&generic_category()) 


{ 
} 

error_condition(value_type _Val, const error_category &_Cat) : _Myval(_Val), _Mycat(&_Cat) 

{ 
} 

template < class _Enum >
  error_condition ( _Enum _Errcode,
   typename tr1 :: enable_if < is_error_condition_enum < _Enum > :: value,
    error_condition > :: type * = 0 )
  : _Myval ( 0 ), _Mycat ( 0 )
  {
  * this = make_error_condition ( _Errcode );
  }

void assign(value_type _Val, const error_category &_Cat) 
{ 
_Myval = _Val; 
_Mycat = &_Cat; 
} 

template < class _Enum >
  typename tr1 :: enable_if < is_error_condition_enum < _Enum > :: value,
   error_condition > :: type & operator = ( _Enum _Errcode )
  {
  * this = make_error_condition ( _Errcode );
  return ( * this );
  }

void clear() 
{ 
_Myval = 0; 
_Mycat = &generic_category(); 
} 

value_type value() const 
{ 
return (_Myval); 
} 

const error_category &category() const 
{ 
return (*(_Mycat)); 
} 

string message() const 
{ 
return this->category().message(this->value()); 
} 

operator _Bool_type() const 
{ 
return ((this->value() != 0) ? (&::std::_Bool_struct::_Member) : (0)); 
} 

bool operator!() const 
{ 
return (this->value() == 0); 
} 

bool operator==(const error_condition &_Right) const 
{ 
return ((this->category() == _Right.category()) && this->value() == _Right.value()); 

} 

bool operator!=(const error_condition &_Right) const 
{ 
return (!((*this == _Right))); 
} 

bool operator<(const error_condition &_Right) const 
{ 
return ((this->category() < _Right.category()) || (this->category() == _Right.category()) && this->value() < _Right.value()); 


} 


private: value_type _Myval; 
const error_category *_Mycat; 
}; 



inline error_condition error_category::default_error_condition(value_type _Errval) const 
{ 
return (error_condition(_Errval, *this)); 
} 


inline bool error_category::equivalent(value_type _Errval, const error_condition &
_Cond) const 
{ 
return ((this->default_error_condition(_Errval) == _Cond)); 
} 


inline bool error_category::equivalent(const error_code &_Code, value_type 
_Errval) const 
{ 
return ((*this == _Code.category()) && _Code.value() == _Errval); 
} 


inline error_condition error_code::default_error_condition() const 
{ 
return (this->category().default_error_condition(this->value())); 
} 


inline bool operator==(const error_code &
_Left, const error_condition &
_Right) 
{ 
return (_Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value())); 

} 

inline bool operator==(const error_condition &
_Left, const error_code &
_Right) 
{ 
return (_Right.category().equivalent(_Right.value(), _Left) || _Left.category().equivalent(_Right, _Left.value())); 

} 


inline bool operator!=(const error_code &
_Left, const error_condition &
_Right) 
{ 
return (!((_Left == _Right))); 
} 

inline bool operator!=(const error_condition &
_Left, const error_code &
_Right) 
{ 
return (!((_Left == _Right))); 
} 


inline error_code make_error_code(generic_errno _Errno) 
{ 
return (error_code(_Errno, generic_category())); 
} 
#if !defined(CppTest_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE) && defined(CPPTEST_USER_STUB__ZSt15make_error_codeNSt7io_errc7io_errcE)
error_code CppTest_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE(_Io_errc _Errno); 
#endif

#if !defined(CppTest_Safe_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE) && defined(CPPTEST_SAFE_STUB__ZSt15make_error_codeNSt7io_errc7io_errcE)
error_code CppTest_Safe_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE(_Io_errc _Errno); 
#endif

#if !defined(CppTest_Auto_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE) && defined(CPPTEST_AUTO_STUB__ZSt15make_error_codeNSt7io_errc7io_errcE)
error_code CppTest_Auto_Stub_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE(_Io_errc _Errno); 
#endif
#line 445
inline error_code make_error_code(_Io_errc _Errno) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(54) 
return (error_code(_Errno, iostream_category())); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 


inline error_condition make_error_condition(generic_errno _Errno) 
{ 
return (error_condition(_Errno, generic_category())); 
} 

inline error_condition make_error_condition(_Io_errc _Errno) 
{ 
return (error_condition(_Errno, iostream_category())); 
} 


template < class _Kty >
 class hash;


template<> class hash< error_code>  : public unary_function< error_code, unsigned __w64>  { 



public: typedef error_code _Kty; 

size_t operator()(const _Kty &_Keyval) const 
{ 
ldiv_t _Qrem = ::ldiv((long)((size_t)_Keyval.value()), 127773); 

_Qrem.rem = 16807 * _Qrem.rem - 2836 * _Qrem.quot; 
if (_Qrem.rem < 0) 
_Qrem.rem += 2147483647;   
return ((size_t)(_Qrem.rem)); 
} 
}; 


template<> class hash< error_condition>  : public unary_function< error_condition, unsigned __w64>  { 



public: typedef error_condition _Kty; 

size_t operator()(const _Kty &_Keyval) const 
{ 
ldiv_t _Qrem = ::ldiv((long)((size_t)_Keyval.value()), 127773); 

_Qrem.rem = 16807 * _Qrem.rem - 2836 * _Qrem.quot; 
if (_Qrem.rem < 0) 
_Qrem.rem += 2147483647;   
return ((size_t)(_Qrem.rem)); 
} 
}; 


class system_error : public runtime_error { 



public: explicit system_error(error_code _Errcode, const string &
_Message = "") : runtime_error(_Message), _Mycode(_Errcode) 

{ 
this->_Makestr(); 
} 

system_error(error_code _Errcode, const char *
_Message) : runtime_error(_Message), _Mycode(_Errcode) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(55) 
this->_Makestr(); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

system_error(error_code::value_type _Errval, const error_category &
_Errcat, const string &
_Message = "") : runtime_error(_Message), _Mycode(_Errval, _Errcat) 

{ 
this->_Makestr(); 
} 

system_error(error_code::value_type _Errval, const error_category &
_Errcat, const char *
_Message) : runtime_error(_Message), _Mycode(_Errval, _Errcat) 

{ 
this->_Makestr(); 
} 
#line 545
const error_code &code() const throw() 
{ 
return (_Mycode); 
} 
#line 561
private: void _Makestr() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 




} 

error_code _Mycode; 

}; 
}
/* Removed pragma: #pragma warning(pop)*/
#line 15 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase"
/* Removed pragma: #pragma warning(push,3)*/

#pragma warning(disable: 4412) /* Removed pragma: #pragma warning(disable: 4412)*/
#line 574 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\system_error"
#pragma pack ( pop )
#line 14 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase"
#pragma pack ( push, 8 )
#line 24
namespace std { 
#line 50
template < class _Dummy >
 class _Iosb{ 


public: enum _Dummy_enum { _Dummy_enum_val = 1}; 
enum _Fmtflags { 

_Fmtmask = 0xffff, _Fmtzero = 0}; 

static const _Fmtflags skipws = ( _Fmtflags ) 0x1; 
static const _Fmtflags unitbuf = ( _Fmtflags ) 0x2; 
static const _Fmtflags uppercase = ( _Fmtflags ) 0x4; 
static const _Fmtflags showbase = ( _Fmtflags ) 0x8; 
static const _Fmtflags showpoint = ( _Fmtflags ) 0x10; 
static const _Fmtflags showpos = ( _Fmtflags ) 0x20; 
static const _Fmtflags left = ( _Fmtflags ) 0x40; 
static const _Fmtflags right = ( _Fmtflags ) 0x80; 
static const _Fmtflags internal = ( _Fmtflags ) 0x100; 
static const _Fmtflags dec = ( _Fmtflags ) 0x200; 
static const _Fmtflags oct = ( _Fmtflags ) 0x400; 
static const _Fmtflags hex = ( _Fmtflags ) 0x800; 
static const _Fmtflags scientific = ( _Fmtflags ) 0x1000; 
static const _Fmtflags fixed = ( _Fmtflags ) 0x2000; 

static const _Fmtflags hexfloat =
  ( _Fmtflags ) 0x3000; 

static const _Fmtflags boolalpha = ( _Fmtflags ) 0x4000; 
static const _Fmtflags _Stdio = ( _Fmtflags ) 0x8000; 
static const _Fmtflags adjustfield = ( _Fmtflags ) ( 0x40
  | 0x80 | 0x100 ); 
static const _Fmtflags basefield = ( _Fmtflags ) ( 0x200
  | 0x400 | 0x800 ); 
static const _Fmtflags floatfield = ( _Fmtflags ) ( 0x1000
  | 0x2000 ); 

enum _Iostate { 

_Statmask = 0x17}; 

static const _Iostate goodbit = ( _Iostate ) 0; 
static const _Iostate eofbit = ( _Iostate ) 0x1; 
static const _Iostate failbit = ( _Iostate ) 0x2; 
static const _Iostate badbit = ( _Iostate ) 0x4; 
static const _Iostate _Hardfail = ( _Iostate ) 0x10; 

enum _Openmode { 

_Openmask = 0xff}; 

static const _Openmode in = ( _Openmode ) 0x1; 
static const _Openmode out = ( _Openmode ) 0x2; 
static const _Openmode ate = ( _Openmode ) 0x4; 
static const _Openmode app = ( _Openmode ) 0x8; 
static const _Openmode trunc = ( _Openmode ) 0x10; 
static const _Openmode _Nocreate = ( _Openmode ) 0x40; 
static const _Openmode _Noreplace = ( _Openmode ) 0x80; 
static const _Openmode binary = ( _Openmode ) 0x20; 

enum _Seekdir { 

_Seekmask = 0x3}; 

static const _Seekdir beg = ( _Seekdir ) 0; 
static const _Seekdir cur = ( _Seekdir ) 1; 
static const _Seekdir end = ( _Seekdir ) 2; 


enum { 
_Openprot = 0x40}; 
};

template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: skipws;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: unitbuf;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: uppercase;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: showbase;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: showpoint;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: showpos;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: left;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: right;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: internal;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: dec;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: oct;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: hex;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: scientific;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: fixed;

template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags
  _Iosb < _Dummy > :: hexfloat;

template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: boolalpha;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: _Stdio;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: adjustfield;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: basefield;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Fmtflags _Iosb < _Dummy > :: floatfield;

template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Iostate _Iosb < _Dummy > :: goodbit;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Iostate _Iosb < _Dummy > :: eofbit;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Iostate _Iosb < _Dummy > :: failbit;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Iostate _Iosb < _Dummy > :: badbit;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Iostate _Iosb < _Dummy > :: _Hardfail;

template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Openmode _Iosb < _Dummy > :: in;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Openmode _Iosb < _Dummy > :: out;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Openmode _Iosb < _Dummy > :: ate;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Openmode _Iosb < _Dummy > :: app;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Openmode _Iosb < _Dummy > :: trunc;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Openmode _Iosb < _Dummy > :: _Nocreate;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Openmode _Iosb < _Dummy > :: _Noreplace;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Openmode _Iosb < _Dummy > :: binary;

template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Seekdir _Iosb < _Dummy > :: beg;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Seekdir _Iosb < _Dummy > :: cur;
template < class _Dummy >
 const typename _Iosb < _Dummy > :: _Seekdir _Iosb < _Dummy > :: end;


#pragma pack(8)
#line 202
class ios_base : public _Iosb< int>  { 



public: typedef int fmtflags; 
typedef int iostate; 
typedef int openmode; 
typedef int seekdir; 

typedef std::streamoff streamoff; 
typedef std::streampos streampos; 

enum event { 

erase_event, imbue_event, copyfmt_event}; 

typedef void (__cdecl *event_callback)(event, ios_base &, int); 
typedef unsigned io_state, open_mode, seek_dir; 


class failure : public system_error { 
#line 228
public: explicit failure(const string &_Message, const error_code &
_Errcode = CppTest_Stub__Call_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE(io_errc::stream)) : system_error(_Errcode, _Message) 

{ 
} 

explicit failure(const char *_Message, const error_code &
_Errcode = CppTest_Stub__Call_make_error_code__ZSt15make_error_codeNSt7io_errc7io_errcE(io_errc::stream)) : system_error(_Errcode, _Message) 

{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 
#line 264
}; 


class Init { 


public: CPPTEST_IMP__ZNSt8ios_base4InitC9Ev inline Init() 
{ 
_Init_ctor(this); 
} 

CPPTEST_IMP__ZNSt8ios_base4InitD9Ev inline ~Init() 
{ 
_Init_dtor(this); 
} 


private: static void __cdecl _Init_ctor(Init *); 
static void __cdecl _Init_dtor(Init *); 

__declspec(dllimport) static int _Init_cnt; 

static int &__cdecl _Init_cnt_func(); 
}; 

CPPTEST_IMP__ZNSt8ios_baseaSERKS_ inline ios_base &operator=(const ios_base &_Right) 
{ 
if (this != &_Right) 
{ 
_Mystate = _Right._Mystate; 
this->copyfmt(_Right); 
}  
return (*this); 
} 

CPPTEST_IMP__ZNKSt8ios_basecvPvEv inline operator void *() const 
{ 
return (this->fail() ? 0 : ((void *)this)); 
} 

CPPTEST_IMP__ZNKSt8ios_basentEv inline bool operator!() const 
{ 
return (this->fail()); 
} 

CPPTEST_IMP__ZNSt8ios_base5clearEib inline void clear(iostate _State, bool _Reraise) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(56) 
_Mystate = (iostate)(_State & _Statmask); 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(57) , (_Mystate & _Except) == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(58) 
; } else 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(59) , _Reraise)) {CPPTEST_STACK_TRACE_STMT_INFO(60) 
throw; } else 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(61) , (_Mystate & _Except) & badbit)) {CPPTEST_STACK_TRACE_STMT_INFO(62) 
throw ((failure)("ios_base::badbit set")); } else 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(63) , (_Mystate & _Except) & failbit)) {CPPTEST_STACK_TRACE_STMT_INFO(64) 
throw ((failure)("ios_base::failbit set")); } else {CPPTEST_STACK_TRACE_STMT_INFO(65) 

throw ((failure)("ios_base::eofbit set")); }        CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt8ios_base5clearEi inline void clear(iostate _State = goodbit) 
{ 
this->clear(_State, false); 
} 

CPPTEST_IMP__ZNSt8ios_base5clearEj inline void clear(io_state _State) 
{ 
this->clear((iostate)_State); 
} 

CPPTEST_IMP__ZNKSt8ios_base7rdstateEv inline iostate rdstate() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(66) 
return (_Mystate); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt8ios_base8setstateEib inline void setstate(iostate _State, bool _Exreraise) 
{ 
if (_State != goodbit) 
this->clear((iostate)((int)this->rdstate() | _State), _Exreraise);   
} 

CPPTEST_IMP__ZNSt8ios_base8setstateEi inline void setstate(iostate _State) 
{ 
if (_State != goodbit) 
this->clear((iostate)((int)this->rdstate() | _State), false);   
} 

CPPTEST_IMP__ZNSt8ios_base8setstateEj inline void setstate(io_state _State) 
{ 
this->setstate((iostate)_State); 
} 

CPPTEST_IMP__ZNKSt8ios_base4goodEv inline bool good() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(67) 
return (this->rdstate() == goodbit); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNKSt8ios_base3eofEv inline bool eof() const 
{ 
return ((int)this->rdstate() & (int)eofbit); 
} 

CPPTEST_IMP__ZNKSt8ios_base4failEv inline bool fail() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(68) 
return (((int)this->rdstate() & ((int)badbit | (int)failbit)) != 0); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 

} 

CPPTEST_IMP__ZNKSt8ios_base3badEv inline bool bad() const 
{ 
return (((int)this->rdstate() & (int)badbit) != 0); 
} 

CPPTEST_IMP__ZNKSt8ios_base10exceptionsEv inline iostate exceptions() const 
{ 
return (_Except); 
} 

CPPTEST_IMP__ZNSt8ios_base10exceptionsEi inline void exceptions(iostate _Newexcept) 
{ 
_Except = (iostate)(_Newexcept & (int)_Statmask); 
this->clear(_Mystate); 
} 

CPPTEST_IMP__ZNSt8ios_base10exceptionsEj inline void exceptions(io_state _State) 
{ 
this->exceptions((iostate)_State); 
} 

CPPTEST_IMP__ZNKSt8ios_base5flagsEv inline fmtflags flags() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(69) 
return (_Fmtfl); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt8ios_base5flagsEi inline fmtflags flags(fmtflags _Newfmtflags) 
{ 
fmtflags _Oldfmtflags = _Fmtfl; 
_Fmtfl = (fmtflags)(_Newfmtflags & (int)_Fmtmask); 
return (_Oldfmtflags); 
} 

CPPTEST_IMP__ZNSt8ios_base4setfEi inline fmtflags setf(fmtflags _Newfmtflags) 
{ 
fmtflags _Oldfmtflags = _Fmtfl; 
_Fmtfl = (fmtflags)(_Fmtfl | _Newfmtflags & (int)_Fmtmask); 

return (_Oldfmtflags); 
} 

CPPTEST_IMP__ZNSt8ios_base4setfEii inline fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask) 
{ 
fmtflags _Oldfmtflags = _Fmtfl; 
_Fmtfl = (fmtflags)((_Fmtfl & (int)(~_Mask)) | ((_Newfmtflags & _Mask) & (int)_Fmtmask)); 

return (_Oldfmtflags); 
} 

CPPTEST_IMP__ZNSt8ios_base6unsetfEi inline void unsetf(fmtflags _Mask) 
{ 
_Fmtfl = (fmtflags)(_Fmtfl & (int)(~_Mask)); 
} 

CPPTEST_IMP__ZNKSt8ios_base9precisionEv inline streamsize precision() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(70) 
return (_Prec); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt8ios_base9precisionEx inline streamsize precision(streamsize _Newprecision) 
{ 
streamsize _Oldprecision = _Prec; 
_Prec = _Newprecision; 
return (_Oldprecision); 
} 

CPPTEST_IMP__ZNKSt8ios_base5widthEv inline streamsize width() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(71) 
return (_Wide); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt8ios_base5widthEx inline streamsize width(streamsize _Newwidth) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 
CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_6, 72) streamsize _Oldwidth = _Wide; CPPTEST_STACK_TRACE_STMT_INFO(73) 
_Wide = _Newwidth; CPPTEST_STACK_TRACE_STMT_INFO(74) 
return (_Oldwidth); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNKSt8ios_base6getlocEv inline locale getloc() const 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(75) 
return (*(_Ploc)); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

CPPTEST_IMP__ZNSt8ios_base5imbueERKSt6locale inline locale imbue(const locale &_Loc) 
{ 
locale _Oldlocale = *(_Ploc); 
(*(_Ploc) = _Loc); 
this->_Callfns(imbue_event); 
return (_Oldlocale); 
} 

CPPTEST_IMP__ZNSt8ios_base6xallocEv static inline int __cdecl xalloc() 
{ 
{ _Lockit _Lock(2); 
return (_Index++); 
} 
} 

CPPTEST_IMP__ZNSt8ios_base5iwordEi inline long &iword(int _Idx) 
{ 
return (this->_Findarr(_Idx)._Lo); 
} 

CPPTEST_IMP__ZNSt8ios_base5pwordEi inline void *&pword(int _Idx) 
{ 
return (this->_Findarr(_Idx)._Vp); 
} 

CPPTEST_IMP__ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi inline void register_callback(event_callback _Pfn, int 
_Idx) 
{ 
_Calls = (new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase", 483) _Fnarray(_Idx, _Pfn, _Calls)); 
} 

CPPTEST_IMP__ZNSt8ios_base7copyfmtERKS_ inline ios_base &copyfmt(const ios_base &_Other) 
{ 
if (this != &_Other) 
{ 
this->_Tidy(); 
(*(_Ploc) = *(_Other._Ploc)); 
_Fmtfl = _Other._Fmtfl; 
_Prec = _Other._Prec; 
_Wide = _Other._Wide; 
_Iosarray *_Ptr = _Other._Arr; 

for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next) 
if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0) 
{ 
this->iword(_Ptr->_Index) = _Ptr->_Lo; 
this->pword(_Ptr->_Index) = _Ptr->_Vp; 
}    

for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0; _Pfa = _Pfa->_Next) 

this->register_callback(_Pfa->_Pfn, _Pfa->_Index);   

this->_Callfns(copyfmt_event); 
this->exceptions(_Other._Except); 
}  
return (*this); 
} 

CPPTEST_IMP__ZNSt8ios_base15sync_with_stdioEb static inline bool __cdecl sync_with_stdio(bool _Newsync = true) 
{ 
{ _Lockit _Lock(2); 
const bool _Oldsync = _Sync; 
_Sync = _Newsync; 
return (_Oldsync); 
} 
} 

CPPTEST_IMP__ZNSt8ios_base4swapERS_ inline void swap(ios_base &_Right) 
{ 
if (this != &_Right) 
{ 
::std::swap(_Mystate, _Right._Mystate); 
::std::swap(_Except, _Right._Except); 
::std::swap(_Fmtfl, _Right._Fmtfl); 
::std::swap(_Prec, _Right._Prec); 
::std::swap(_Wide, _Right._Wide); 

::std::swap(_Arr, _Right._Arr); 
::std::swap(_Calls, _Right._Calls); 
::std::swap(_Ploc, _Right._Ploc); 
}  
} 

CPPTEST_IMP__ZNSt8ios_baseD9Ev inline virtual ~ios_base() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(76) 
_Ios_base_dtor(this); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

static void __cdecl _Addstd(ios_base *); 

size_t _Stdstr; 


protected: CPPTEST_IMP__ZNSt8ios_baseC9Ev inline ios_base() 
{ 
} 

CPPTEST_IMP__ZNSt8ios_base5_InitEv inline void _Init() 
{ 
_Ploc = 0; 
_Stdstr = 0; 
_Except = goodbit; 
_Fmtfl = (fmtflags)(skipws | dec); 
_Prec = 6; 
_Wide = 0; 
_Arr = 0; 
_Calls = 0; 
this->clear(goodbit); 
_Ploc = (new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase", 564) locale); 
} 



private: struct _Iosarray { 


_Iosarray(int _Idx, _Iosarray *_Link) : _Next(_Link), _Index(_Idx), _Lo((0)), _Vp((0)) 

{ 
} 

_Iosarray *_Next; 
int _Index; 
long _Lo; 
void *_Vp; 
}; 


struct _Fnarray { 

_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link) : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) 

{ 
} 

_Fnarray *_Next; 
int _Index; 
event_callback _Pfn; 
}; 

CPPTEST_IMP__ZNSt8ios_base8_CallfnsENS_5eventE inline void _Callfns(event _Ev) 
{ 
for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next) 
(*(_Pfa->_Pfn))(_Ev, *this, _Pfa->_Index);   
} 

CPPTEST_IMP__ZNSt8ios_base8_FindarrEi inline _Iosarray &_Findarr(int _Idx) 
{ 
_Iosarray *_Ptr1, *_Ptr2; 

for ((_Ptr1 = _Arr), (_Ptr2 = 0); _Ptr1 != 0; _Ptr1 = _Ptr1->_Next) 
if (_Ptr1->_Index == _Idx) 
return (*_Ptr1);  else 
if ((_Ptr2 == 0 && _Ptr1->_Lo == 0) && _Ptr1->_Vp == 0) 
_Ptr2 = _Ptr1;       

if (_Ptr2 != 0) 
{ 
_Ptr2->_Index = _Idx; 
return (*_Ptr2); 
}  

_Arr = (new (::std::_DebugHeapTag_func(), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase", 618) _Iosarray(_Idx, _Arr)); 
return (*(_Arr)); 
} 

CPPTEST_IMP__ZNSt8ios_base5_TidyEv inline void _Tidy() 
{ 
this->_Callfns(erase_event); 
_Iosarray *_Ptr1, *_Ptr2; 

for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2) 
{ 
_Ptr2 = _Ptr1->_Next; 
::std::_DebugHeapDelete(_Ptr1); 
}  
_Arr = 0; 

_Fnarray *_Pfa1, *_Pfa2; 
for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2) 
{ 
_Pfa2 = _Pfa1->_Next; 
::std::_DebugHeapDelete(_Pfa1); 
}  
_Calls = 0; 
} 

iostate _Mystate; 
iostate _Except; 
fmtflags _Fmtfl; 
streamsize _Prec; 
streamsize _Wide; 
_Iosarray *_Arr; 
_Fnarray *_Calls; 
locale *_Ploc; 

__declspec(dllimport) static int _Index; 
__declspec(dllimport) static bool _Sync; 

static void __cdecl _Ios_base_dtor(ios_base *); 
public:
    __declspec(dllimport) ios_base(const ios_base&);

#line 656
}; 
#pragma pack()
extern template class _Iosb< int> ;



}



/* Removed pragma: #pragma warning(pop)*/
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf"
/* Removed pragma: #pragma warning(push,3)*/
#line 667 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase"
#pragma pack ( pop )
#line 8 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf"
#pragma pack ( push, 8 )





namespace std { 

template < class _Elem,
 class _Traits >
 class basic_streambuf{ 

typedef basic_streambuf < _Elem, _Traits > _Myt; 


protected:  basic_streambuf ( )
  : _Plocale ( new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf", 24 ) locale )
  {
  _Init ( );
  }

 basic_streambuf ( _Uninitialized )
  : _Mylock ( _Noinit )
  {
  }

 basic_streambuf ( const _Myt & _Right )
  : _Plocale ( new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf", 35 ) locale ( _Right . getloc ( ) ) )
  {
  _Init ( );
  setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
  setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
  }

_Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
   setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
   pubimbue ( _Right . getloc ( ) );
   }
  return ( * this );
  }

void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Elem * _Tfirst = pbase ( );
   _Elem * _Tnext = pptr ( );
   _Elem * _Tend = epptr ( );
   setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
   _Right . setp ( _Tfirst, _Tnext, _Tend );

   _Tfirst = eback ( );
   _Tnext = gptr ( );
   _Tend = egptr ( );
   setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
   _Right . setg ( _Tfirst, _Tnext, _Tend );

   locale _Oldlocale = pubimbue ( _Right . getloc ( ) );
   _Right . pubimbue ( _Oldlocale );
   }
  }


public: typedef _Elem char_type; 
typedef _Traits traits_type; 

virtual ~ basic_streambuf ( )
  {
  :: std :: _DebugHeapDelete ( _Plocale );
  }

typedef typename _Traits :: int_type int_type; 
typedef typename _Traits :: pos_type pos_type; 
typedef typename _Traits :: off_type off_type; 

pos_type pubseekoff ( off_type _Off,
  ios_base :: seekdir _Way,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )


  {
  return ( seekoff ( _Off, _Way, _Mode ) );
  }

pos_type pubseekoff ( off_type _Off,
  ios_base :: seek_dir _Way,
  ios_base :: open_mode _Mode )


  {
  return ( pubseekoff ( _Off, ( ios_base :: seekdir ) _Way,
   ( ios_base :: openmode ) _Mode ) );
  }

pos_type pubseekpos ( pos_type _Pos,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )

  {
  return ( seekpos ( _Pos, _Mode ) );
  }

pos_type pubseekpos ( pos_type _Pos,
  ios_base :: open_mode _Mode )

  {
  return ( seekpos ( _Pos, ( ios_base :: openmode ) _Mode ) );
  }

_Myt * pubsetbuf ( _Elem * _Buffer,
  streamsize _Count )

  {
  return ( setbuf ( _Buffer, _Count ) );
  }

locale pubimbue ( const locale & _Newlocale )
  {
  locale _Oldlocale = * _Plocale;
  imbue ( _Newlocale );
  * _Plocale = _Newlocale;
  return ( _Oldlocale );
  }

locale getloc ( ) const
  {
  return ( * _Plocale );
  }

streamsize in_avail ( )
  {
  streamsize _Res = _Gnavail ( );
  return ( 0 < _Res ? _Res : showmanyc ( ) );
  }

int pubsync ( )
  {
  return ( sync ( ) );
  }

int_type sbumpc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gninc ( ) ) : uflow ( ) );
  }

int_type sgetc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * gptr ( ) ) : underflow ( ) );
  }

streamsize sgetn ( _Elem * _Ptr,
  streamsize _Count )

  {
  return ( xsgetn ( _Ptr, _Count ) );
  }

int_type snextc ( )
  {
  return ( 1 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gnpreinc ( ) )
   : _Traits :: eq_int_type ( _Traits :: eof ( ), sbumpc ( ) )
    ? _Traits :: eof ( ) : sgetc ( ) );
  }

int_type sputbackc ( _Elem _Ch )
  {
  return ( gptr ( ) != 0 && eback ( ) < gptr ( )
   && _Traits :: eq ( _Ch, gptr ( ) [ - 1 ] )
   ? _Traits :: to_int_type ( * _Gndec ( ) )
   : pbackfail ( _Traits :: to_int_type ( _Ch ) ) );
  }

void stossc ( )
  {
  if ( 0 < _Gnavail ( ) )
   _Gninc ( );
  else
   uflow ( );
  }

int_type sungetc ( )
  {
  return ( gptr ( ) != 0 && eback ( ) < gptr ( )
   ? _Traits :: to_int_type ( * _Gndec ( ) ) : pbackfail ( ) );
  }

int_type sputc ( _Elem _Ch )
  {
  return ( 0 < _Pnavail ( )
   ? _Traits :: to_int_type ( * _Pninc ( ) = _Ch )
   : overflow ( _Traits :: to_int_type ( _Ch ) ) );
  }

streamsize sputn ( const _Elem * _Ptr,
  streamsize _Count )

  {
  return ( xsputn ( _Ptr, _Count ) );
  }

virtual void _Lock ( )
  {
  _Mylock . _Lock ( );
  }

virtual void _Unlock ( )
  {
  _Mylock . _Unlock ( );
  }


protected: _Elem * eback ( ) const
  {
  return ( * _IGfirst );
  }

_Elem * gptr ( ) const
  {
  return ( * _IGnext );
  }

_Elem * pbase ( ) const
  {
  return ( * _IPfirst );
  }

_Elem * pptr ( ) const
  {
  return ( * _IPnext );
  }

_Elem * egptr ( ) const
  {
  return ( * _IGnext + * _IGcount );
  }

void gbump ( int _Off )
  {
  * _IGcount -= _Off;
  * _IGnext += _Off;
  }

void setg ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IGfirst = _First;
  * _IGnext = _Next;
  * _IGcount = ( int ) ( _Last - _Next );
  }

_Elem * epptr ( ) const
  {
  return ( * _IPnext + * _IPcount );
  }

_Elem * _Gndec ( )
  {
  ++ * _IGcount;
  return ( -- * _IGnext );
  }

_Elem * _Gninc ( )
  {
  -- * _IGcount;
  return ( ( * _IGnext ) ++ );
  }

_Elem * _Gnpreinc ( )
  {
  -- * _IGcount;
  return ( ++ ( * _IGnext ) );
  }

streamsize _Gnavail ( ) const
  {
  return ( * _IGnext != 0 ? * _IGcount : 0 );
  }

void pbump ( int _Off )
  {
  * _IPcount -= _Off;
  * _IPnext += _Off;
  }

void setp ( _Elem * _First, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _First;
  * _IPcount = ( int ) ( _Last - _First );
  }

void setp ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _Next;
  * _IPcount = ( int ) ( _Last - _Next );
  }

_Elem * _Pninc ( )
  {
  -- * _IPcount;
  return ( ( * _IPnext ) ++ );
  }

streamsize _Pnavail ( ) const
  {
  return ( * _IPnext != 0 ? * _IPcount : 0 );
  }

void _Init ( )
  {
  _IGfirst = & _Gfirst;
  _IPfirst = & _Pfirst;
  _IGnext = & _Gnext;
  _IPnext = & _Pnext;
  _IGcount = & _Gcount;
  _IPcount = & _Pcount;
  setp ( 0, 0 );
  setg ( 0, 0, 0 );
  }

void _Init ( _Elem * * _Gf, _Elem * * _Gn, int * _Gc,
  _Elem * * _Pf, _Elem * * _Pn, int * _Pc )

  {
  _IGfirst = _Gf;
  _IPfirst = _Pf;
  _IGnext = _Gn;
  _IPnext = _Pn;
  _IGcount = _Gc;
  _IPcount = _Pc;
  }

virtual int_type overflow ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

virtual int_type pbackfail ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

virtual streamsize showmanyc ( )
  {
  return ( 0 );
  }

virtual int_type underflow ( )
  {
  return ( _Traits :: eof ( ) );
  }

virtual int_type uflow ( )
  {
  return ( _Traits :: eq_int_type ( _Traits :: eof ( ), underflow ( ) )
   ? _Traits :: eof ( ) : _Traits :: to_int_type ( * _Gninc ( ) ) );
  }

virtual streamsize xsgetn ( _Elem * _Ptr,
  streamsize _Count )

  {
  int_type _Meta;
  streamsize _Size, _Copied;

  for ( _Copied = 0; 0 < _Count; )
   if ( 0 < ( _Size = _Gnavail ( ) ) )
    {
    if ( _Count < _Size )
     _Size = _Count;
    _Traits :: copy ( _Ptr, gptr ( ), ( size_t ) _Size );
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    gbump ( ( int ) _Size );
    }
   else if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta = uflow ( ) ) )
    break;
   else
    {
    * _Ptr ++ = _Traits :: to_char_type ( _Meta );
    ++ _Copied;
    -- _Count;
    }

  return ( _Copied );
  }

virtual streamsize xsputn ( const _Elem * _Ptr,
  streamsize _Count )

  {
  streamsize _Size, _Copied;

  for ( _Copied = 0; 0 < _Count; )
   if ( 0 < ( _Size = _Pnavail ( ) ) )
    {
    if ( _Count < _Size )
     _Size = _Count;
    _Traits :: copy ( pptr ( ), _Ptr, ( size_t ) _Size );
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    pbump ( ( int ) _Size );
    }
   else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    overflow ( _Traits :: to_int_type ( * _Ptr ) ) ) )
    break;
   else
    {
    ++ _Ptr;
    ++ _Copied;
    -- _Count;
    }

  return ( _Copied );
  }

virtual pos_type seekoff ( off_type,
  ios_base :: seekdir,
  ios_base :: openmode = ios_base :: in | ios_base :: out )


  {
  return ( streampos ( _BADOFF ) );
  }

virtual pos_type seekpos ( pos_type,
  ios_base :: openmode = ios_base :: in | ios_base :: out )

  {
  return ( streampos ( _BADOFF ) );
  }

virtual _Myt * setbuf ( _Elem *, streamsize )
  {
  return ( this );
  }

virtual int sync ( )
  {
  return ( 0 );
  }

virtual void imbue ( const locale & )
  {
  }


private: _Mutex _Mylock; 
_Elem * _Gfirst; 
_Elem * _Pfirst; 
_Elem * * _IGfirst; 
_Elem * * _IPfirst; 
_Elem * _Gnext; 
_Elem * _Pnext; 
_Elem * * _IGnext; 
_Elem * * _IPnext; 

int _Gcount; 
int _Pcount; 
int * _IGcount; 
int * _IPcount; 

locale * _Plocale; 
};



template class __declspec(dllimport) basic_streambuf< char, char_traits< char> > ;
template class __declspec(dllimport) basic_streambuf< __wchar_t, char_traits< __wchar_t> > ;
#line 475
template < class _Elem,
 class _Traits >
 class istreambuf_iterator
  : public iterator < input_iterator_tag,
   _Elem, typename _Traits :: off_type, _Elem *, _Elem & >{ 

typedef istreambuf_iterator < _Elem, _Traits > _Myt; 

public: typedef _Elem char_type; 
typedef _Traits traits_type; 
typedef basic_streambuf < _Elem, _Traits > streambuf_type; 
typedef basic_istream < _Elem, _Traits > istream_type; 

typedef typename traits_type :: int_type int_type; 

 istreambuf_iterator ( streambuf_type * _Sb = 0 ) throw ( )
  : _Strbuf ( _Sb ), _Got ( _Sb == 0 )
  {
  }

 istreambuf_iterator ( istream_type & _Istr ) throw ( )
  : _Strbuf ( _Istr . rdbuf ( ) ), _Got ( _Istr . rdbuf ( ) == 0 )
  {
  }

_Elem operator * ( ) const
  {
  if ( ! _Got )
   _Peek ( );


  if ( _Strbuf == 0 )
   _Debug_message ( L"\x69\x73\x74\x72\x65\x61\x6d\x62\x75\x66\x5f\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x69\x73\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66" L"\x65\x72\x65\x6e\x63\x61\x62\x6c\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x73\x74\x72\x65\x61\x6d\x62" L"\x75\x66", 507 );


  return ( _Val );
  }

_Myt & operator ++ ( )
  {

  if ( _Strbuf == 0 )
   _Debug_message ( L"\x69\x73\x74\x72\x65\x61\x6d\x62\x75\x66\x5f\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x69\x73\x20\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65" L"\x6d\x65\x6e\x74\x61\x62\x6c\x65", L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x73\x74\x72\x65\x61\x6d\x62" L"\x75\x66", 517 );


  _Inc ( );
  return ( * this );
  }

_Myt operator ++ ( int )
  {
  if ( ! _Got )
   _Peek ( );
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

bool equal ( const _Myt & _Right ) const
  {
  if ( ! _Got )
   _Peek ( );
  if ( ! _Right . _Got )
   _Right . _Peek ( );
  return ( _Strbuf == 0 && _Right . _Strbuf == 0
   || _Strbuf != 0 && _Right . _Strbuf != 0 );
  }


private: void _Inc ( )
  {
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Strbuf -> sbumpc ( ) ) )
   _Strbuf = 0, _Got = true;
  else
   _Got = false;
  }

_Elem _Peek ( ) const
  {
  int_type _Meta;
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Meta = _Strbuf -> sgetc ( ) ) )
   _Strbuf = 0;
  else
   _Val = traits_type :: to_char_type ( _Meta );
  _Got = true;
  return ( _Val );
  }

mutable streambuf_type * _Strbuf; 
mutable bool _Got; 
mutable _Elem _Val; 
};

template < class _Elem,
 class _Traits >
 struct _Is_checked_helper < istreambuf_iterator < _Elem, _Traits > >
 : public :: std :: tr1 :: true_type{ 

};


template < class _Elem,
 class _Traits > inline
 bool operator == (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( _Left . equal ( _Right ) );
 }

template < class _Elem,
 class _Traits > inline
 bool operator != (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }


template < class _Elem,
 class _Traits >
 class ostreambuf_iterator
  : public _Outit{ 

typedef ostreambuf_iterator < _Elem, _Traits > _Myt; 

public: typedef _Elem char_type; 
typedef _Traits traits_type; 
typedef basic_streambuf < _Elem, _Traits > streambuf_type; 
typedef basic_ostream < _Elem, _Traits > ostream_type; 

 ostreambuf_iterator ( streambuf_type * _Sb ) throw ( )
  : _Failed ( false ), _Strbuf ( _Sb )
  {
  }

 ostreambuf_iterator ( ostream_type & _Ostr ) throw ( )
  : _Failed ( false ), _Strbuf ( _Ostr . rdbuf ( ) )
  {
  }

_Myt & operator = ( _Elem _Right )
  {
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( _Traits :: eof ( ),
    _Strbuf -> sputc ( _Right ) ) )
   _Failed = true;
  return ( * this );
  }

_Myt & operator * ( )
  {
  return ( * this );
  }

_Myt & operator ++ ( )
  {
  return ( * this );
  }

_Myt & operator ++ ( int )
  {
  return ( * this );
  }

bool failed ( ) const throw ( )
  {
  return ( _Failed );
  }


private: bool _Failed; 
streambuf_type * _Strbuf; 
};

template < class _Elem,
 class _Traits >
 struct _Is_checked_helper < ostreambuf_iterator < _Elem, _Traits > >
 : public :: std :: tr1 :: true_type{ 

};
}



/* Removed pragma: #pragma warning(pop)*/
#line 13 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
/* Removed pragma: #pragma warning(push,3)*/




#pragma warning(disable: 4189 4275) /* Removed pragma: #pragma warning(disable: 4189 4275)*/
#line 666 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf"
#pragma pack ( pop )
#line 12 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
#pragma pack ( push, 8 )
#line 27
extern "C" { __declspec(dllimport) extern float __cdecl _Stofx(const char *, char **, long, int *); } 


extern "C" { __declspec(dllimport) extern double __cdecl _Stodx(const char *, char **, long, int *); } 


extern "C" { __declspec(dllimport) extern long double __cdecl _Stoldx(const char *, char **, long, int *); } 


extern "C" { __declspec(dllimport) extern long __cdecl _Stolx(const char *, char **, int, int *); } 


extern "C" { __declspec(dllimport) extern unsigned long __cdecl _Stoulx(const char *, char **, int, int *); } 


extern "C" { __declspec(dllimport) extern __int64 __cdecl _Stollx(const char *, char **, int, int *); } 


extern "C" { __declspec(dllimport) extern unsigned __int64 __cdecl _Stoullx(const char *, char **, int, int *); } 
#line 54
namespace std { 

template < class _Elem >
 class numpunct
  : public locale :: facet{ 



public: typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > > string_type; 
typedef _Elem char_type; 

__declspec(dllimport) static locale::id id; 

_Elem decimal_point ( ) const
  {
  return ( do_decimal_point ( ) );
  }

_Elem thousands_sep ( ) const
  {
  return ( do_thousands_sep ( ) );
  }

string grouping ( ) const
  {
  return ( do_grouping ( ) );
  }

string_type falsename ( ) const
  {
  return ( do_falsename ( ) );
  }

string_type truename ( ) const
  {
  return ( do_truename ( ) );
  }

explicit numpunct ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
   if ( _Kseparator == 0 )
    _Kseparator =
     _Maklocchr ( ',', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  }
  }

 numpunct ( const _Locinfo & _Lobj, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj, _Isdef );
  }

static size_t _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )

  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum", 113 ) numpunct < _Elem > (
    _Locinfo ( _Ploc -> c_str ( ) ), 0, true );
  return ( 4 );
  }


protected: virtual ~ numpunct ( )
  {
  _Tidy ( );
  }

 numpunct ( const char * _Locname, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj ( _Locname );
   _Init ( _Lobj, _Isdef );
  }
  }

void _Init ( const _Locinfo & _Lobj, bool _Isdef = false )
  {
  const lconv * _Ptr = _Lobj . _Getlconv ( );

  _Grouping = 0;
  _Falsename = 0;
  _Truename = 0;

  try {
  _Grouping = _Maklocstr ( _Isdef ? "" : _Ptr -> grouping, ( char * ) 0, _Lobj . _Getcvt ( ) )
                   ;
  _Falsename = _Maklocstr ( _Lobj . _Getfalse ( ), ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  _Truename = _Maklocstr ( _Lobj . _Gettrue ( ), ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }

  _Dp = _Maklocchr ( _Ptr -> decimal_point [ 0 ], ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  _Kseparator =
   _Maklocchr ( _Ptr -> thousands_sep [ 0 ], ( _Elem * ) 0, _Lobj . _Getcvt ( ) );

  if ( _Isdef )
   {

   _Dp = _Maklocchr ( '.', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
   _Kseparator = _Maklocchr ( ',', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
   }
  }

virtual _Elem do_decimal_point ( ) const
  {
  return ( _Dp );
  }

virtual _Elem do_thousands_sep ( ) const
  {
  return ( _Kseparator );
  }

virtual string do_grouping ( ) const
  {
  return ( string ( _Grouping ) );
  }

virtual string_type do_falsename ( ) const
  {
  return ( string_type ( _Falsename ) );
  }

virtual string_type do_truename ( ) const
  {
  return ( string_type ( _Truename ) );
  }


private: void _Tidy ( )
  {
  :: std :: _DebugHeapDelete ( ( void * ) ( void * ) _Grouping );
  :: std :: _DebugHeapDelete ( ( void * ) ( void * ) _Falsename );
  :: std :: _DebugHeapDelete ( ( void * ) ( void * ) _Truename );
  }

const char * _Grouping; 
_Elem _Dp; 
_Elem _Kseparator; 
const _Elem * _Falsename; 
const _Elem * _Truename; 
};


template < class _Elem >
 class numpunct_byname
  : public numpunct < _Elem >{ 


public: explicit numpunct_byname ( const char * _Locname, size_t _Refs = 0 )
  : numpunct < _Elem > ( _Locname, _Refs )
  {
  }


explicit numpunct_byname ( const string & _Str, size_t _Refs = 0 )
  : numpunct < _Elem > ( _Str . c_str ( ), _Refs )
  {
  }



protected: virtual ~ numpunct_byname ( )
  {
  }
};


template < class _Elem >
                         locale :: id numpunct < _Elem > :: id;


template < class _Elem,
 class _InIt = istreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_get
  : public locale :: facet{ 


public: typedef numpunct < _Elem > _Mypunct; 

typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > > _Mystr; 

static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )

  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum", 245 ) num_get < _Elem, _InIt > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 4 );
  }

static locale::id id; 


protected: virtual ~ num_get ( )
  {
  }

void _Init ( const _Locinfo & _Lobj )
  {
  _Cvt = _Lobj . _Getcvt ( );
  }

_Locinfo :: _Cvtvec _Cvt; 


public: explicit num_get ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

 num_get ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

typedef _Elem char_type; 
typedef _InIt iter_type; 

_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   _Bool & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }


_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   __int64 & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned __int64 & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }


_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

_InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const


  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }


protected: virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   _Bool & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 366 );
  int _Ans = - 1;

  if ( _Iosbase . flags ( ) & ios_base :: boolalpha )
   {
   typedef typename _Mystr :: size_type _Mystrsize;
   const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
   _Mystr _Str ( ( _Mystrsize ) 1, ( char_type ) 0 );
   _Str += _Punct_fac . falsename ( );
   _Str += ( char_type ) 0;
   _Str += _Punct_fac . truename ( );
   _Ans = _Getloctxt ( _First, _Last, ( size_t ) 2, _Str . c_str ( ) );
   }
  else
   {
   char _Ac [ 32 ], * _Ep;
   int _Errno = 0;
   const unsigned long _Ulo = :: _Stoulx ( _Ac, & _Ep,
    _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
     _Iosbase . getloc ( ) ), & _Errno );
   if ( _Ep != _Ac && _Errno == 0 && _Ulo <= 1 )
    _Ans = _Ulo;
   }

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ans < 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans != 0;
  return ( _First );
  }

virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 403 );
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
   _Iosbase . getloc ( ) );
  char * _Ptr = _Ac [ 0 ] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx ( _Ptr, & _Ep, _Base, & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ptr || _Errno != 0 || 0xffff < _Ans )
   _State |= ios_base :: failbit;
  else
   _Val = ( unsigned short ) ( _Ac [ 0 ] == '-'
    ? 0 - _Ans : _Ans );
  return ( _First );
  }

virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 426 );
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
   _Iosbase . getloc ( ) );
  char * _Ptr = _Ac [ 0 ] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx ( _Ptr, & _Ep, _Base, & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ptr || _Errno != 0 || 0xffffffffU < _Ans )
   _State |= ios_base :: failbit;
  else
   _Val = _Ac [ 0 ] == '-' ? 0 - _Ans : _Ans;
  return ( _First );
  }

virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 448 );
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const long _Ans = :: _Stolx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 468 );
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const unsigned long _Ans = :: _Stoulx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }


virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   __int64 & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 489 );
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const __int64 _Ans = :: _Stollx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned __int64 & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 509 );
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const unsigned __int64 _Ans = :: _Stoullx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }


virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 530 );
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  float _Ans = :: _Stofx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase, & _Hexexp ), & _Errno );

  if ( _Hexexp != 0 )
   _Ans = :: ldexpf ( _Ans, 4 * _Hexexp );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 554 );
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  double _Ans = :: _Stodx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase, & _Hexexp ), & _Errno );

  if ( _Hexexp != 0 )
   _Ans = :: ldexp ( _Ans, 4 * _Hexexp );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 578 );
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  long double _Ans = :: _Stoldx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase, & _Hexexp ), & _Errno );

  if ( _Hexexp != 0 )
   _Ans = :: ldexpl ( _Ans, 4 * _Hexexp );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const


  {
  _Debug_range ( _First, _Last, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 602 );
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;


  int _Base = _Getifld ( _Ac, _First, _Last, ios_base :: hex,
   _Iosbase . getloc ( ) );
  const unsigned __int64 _Ans =
   ( sizeof ( void * ) == sizeof ( unsigned long ) )
    ? ( unsigned __int64 ) :: _Stoulx ( _Ac, & _Ep, _Base, & _Errno )
    : :: _Stoullx ( _Ac, & _Ep, _Base, & _Errno );







  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = ( void * ) ( ( char * ) 0 + _Ans );
  return ( _First );
  }


private: int __cdecl _Getifld ( char * _Ac,
  _InIt & _First, _InIt & _Last, ios_base :: fmtflags _Basefield,
   const locale & _Loc ) const


  {
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Loc );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Grouping . size ( ) == 0
   ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  char * _Ptr = _Ac;

  if ( _First == _Last )
   ;
  else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '-', ++ _First;

  _Basefield &= ios_base :: basefield;
  int _Base = _Basefield == ios_base :: oct ? 8
   : _Basefield == ios_base :: hex ? 16
   : _Basefield == ios_base :: _Fmtzero ? 0 : 10;

  bool _Seendigit = false;
  bool _Nonzero = false;

  if ( _First != _Last && * _First == _E0 )
   {
   _Seendigit = true, ++ _First;
   if ( _First != _Last && ( * _First == _Maklocchr ( 'x', ( _Elem * ) 0, _Cvt )
     || * _First == _Maklocchr ( 'X', ( _Elem * ) 0, _Cvt ) )
    && ( _Base == 0 || _Base == 16 ) )
    _Base = 16, _Seendigit = false, ++ _First;
   else if ( _Base == 0 )
    _Base = 8;
   }

  int _Dlen = _Base == 0 || _Base == 10 ? 10
   : _Base == 8 ? 8 : 16 + 6;
  string _Groups ( ( size_t ) 1, ( char ) _Seendigit );
  size_t _Group = 0;

  for ( char * const _Pe = & _Ac [ 32 - 1 ];
   _First != _Last; ++ _First )
   if ( :: memchr ( ( const char * ) "0123456789abcdefABCDEF",
    * _Ptr = _Maklocbyte ( ( _Elem ) * _First, _Cvt ), _Dlen ) != 0 )
    {
    if ( ( _Nonzero || * _Ptr != '0' ) && _Ptr < _Pe )
     ++ _Ptr, _Nonzero = true;
    _Seendigit = true;
    if ( _Groups [ _Group ] != 127 )
     ++ _Groups [ _Group ];
    }
   else if ( _Groups [ _Group ] == '\000'
    || _Kseparator == ( _Elem ) 0
    || * _First != _Kseparator )
    break;
   else
    {
    _Groups . append ( ( string :: size_type ) 1, '\000' );
    ++ _Group;
    }

  if ( _Group == 0 )
   ;
  else if ( '\000' < _Groups [ _Group ] )
   ++ _Group;
  else
   _Seendigit = false;

  for ( const char * _Pg = _Grouping . c_str ( ); _Seendigit && 0 < _Group; )
   if ( * _Pg == 127 )
    break;
   else if ( 0 < -- _Group && * _Pg != _Groups [ _Group ]
    || 0 == _Group && * _Pg < _Groups [ _Group ] )
    _Seendigit = false;
   else if ( '\000' < _Pg [ 1 ] )
    ++ _Pg;

  if ( _Seendigit && ! _Nonzero )
   * _Ptr ++ = '0';
  else if ( ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Base );
  }

int __cdecl _Getffld ( char * _Ac,
  _InIt & _First, _InIt & _Last,
  ios_base & _Iosbase, int * _Phexexp ) const


  {
  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: hexfloat )
   return ( _Getffldx ( _Ac, _First, _Last,
    _Iosbase, _Phexexp ) );

  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  char * _Ptr = _Ac;
  bool _Bad = false;

  if ( _First == _Last )
   ;
  else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '-', ++ _First;

  bool _Seendigit = false;
  int _Significant = 0;
  int _Pten = 0;

  if ( * _Grouping . c_str ( ) == 127 || * _Grouping . c_str ( ) <= '\000' )
   for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
     _Seendigit = true, ++ _First )
    if ( 36 <= _Significant )
     ++ _Pten;
    else if ( * _First == _E0 && _Significant == 0 )
     ;
    else
     {
     * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
     ++ _Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping . size ( ) == 0
    ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    if ( _E0 <= * _First && * _First <= _E0 + 9 )
     {
     _Seendigit = true;
     if ( 36 <= _Significant )
      ++ _Pten;
     else if ( * _First == _E0 && _Significant == 0 )
      ;
     else
      {
      * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
      ++ _Significant;
      }
     if ( _Groups [ _Group ] != 127 )
      ++ _Groups [ _Group ];
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     break;
    else
     {
     _Groups . append ( ( size_t ) 1, '\000' );
     ++ _Group;
     }
   if ( _Group == 0 )
    ;
   else if ( '\000' < _Groups [ _Group ] )
    ++ _Group;
   else
    _Bad = true;

   for ( const char * _Pg = _Grouping . c_str ( );
    ! _Bad && 0 < _Group; )
    if ( * _Pg == 127 )
     break;
    else if ( 0 < -- _Group && * _Pg != _Groups [ _Group ]
     || 0 == _Group && * _Pg < _Groups [ _Group ] )
     _Bad = true;
    else if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
   }

  if ( _Seendigit && _Significant == 0 )
   * _Ptr ++ = '0';

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ], ++ _First;

  if ( _Significant == 0 )
   {
   for (; _First != _Last && * _First == _E0;
    _Seendigit = true, ++ _First )
    -- _Pten;
   if ( _Pten < 0 )
    * _Ptr ++ = '0', ++ _Pten;
   }

  for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
    _Seendigit = true, ++ _First )
   if ( _Significant < 36 )
    {
    * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
    ++ _Significant;
    }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Maklocchr ( 'e', ( _Elem * ) 0, _Cvt )
    || * _First == _Maklocchr ( 'E', ( _Elem * ) 0, _Cvt ) ) )
   {
   * _Ptr ++ = 'e', ++ _First;
   _Seendigit = false, _Significant = 0;

   if ( _First == _Last )
    ;
   else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '+', ++ _First;
   else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '-', ++ _First;
   for (; _First != _Last && * _First == _E0; )
    _Seendigit = true, ++ _First;
   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
    _Seendigit = true, ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Pten );
  }

int __cdecl _Hexdig ( const _Elem _Dig, const _Elem _E0,
  const _Elem _Al, const _Elem _Au ) const

  {
  if ( _E0 <= _Dig && _Dig <= _E0 + 9 )
   return ( _Dig - _E0 );
  else if ( _Al <= _Dig && _Dig <= _Al + 5 )
   return ( _Dig - _Al + 10 );
  else if ( _Au <= _Dig && _Dig <= _Au + 5 )
   return ( _Dig - _Au + 10 );
  else
   return ( - 1 );
  }

int __cdecl _Getffldx ( char * _Ac,
  _InIt & _First, _InIt & _Last,
  ios_base & _Iosbase, int * _Phexexp ) const


  {
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  const _Elem _Al = _Maklocchr ( 'a', ( _Elem * ) 0, _Cvt );
  const _Elem _Au = _Maklocchr ( 'A', ( _Elem * ) 0, _Cvt );
  char * _Ptr = _Ac;
  bool _Bad = false;
  int _Dig;

  if ( _First == _Last )
   ;
  else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '-', ++ _First;

  * _Ptr ++ = '0';
  * _Ptr ++ = 'x';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Phex = 0;

  if ( _First == _Last || * _First != _E0 )
   ;
  else if ( ++ _First != _Last
   && ( * _First == _Maklocchr ( 'x', ( _Elem * ) 0, _Cvt )
     || * _First == _Maklocchr ( 'X', ( _Elem * ) 0, _Cvt ) ) )
   ++ _First;
  else
   _Seendigit = true;

  if ( * _Grouping . c_str ( ) == 127 || * _Grouping . c_str ( ) <= '\000' )
   for (; _First != _Last
    && 0 <= ( _Dig = _Hexdig ( * _First, _E0, _Al, _Au ) );
     _Seendigit = true, ++ _First )
    if ( 36 <= _Significant )
     ++ _Phex;
    else if ( * _First == _E0 && _Significant == 0 )
     ;
    else
     {
     * _Ptr ++ = "0123456789abcdef" [ _Dig ];
     ++ _Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping . size ( ) == 0
    ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    if ( 0 <= ( _Dig = _Hexdig ( * _First, _E0, _Al, _Au ) ) )
     {
     _Seendigit = true;
     if ( 36 <= _Significant )
      ++ _Phex;
     else if ( * _First == _E0 && _Significant == 0 )
      ;
     else
      {
      * _Ptr ++ = "0123456789abcdef" [ _Dig ];
      ++ _Significant;
      }
     if ( _Groups [ _Group ] != 127 )
      ++ _Groups [ _Group ];
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     break;
    else
     {
     _Groups . append ( ( size_t ) 1, '\000' );
     ++ _Group;
     }
   if ( _Group == 0 )
    ;
   else if ( '\000' < _Groups [ _Group ] )
    ++ _Group;
   else
    _Bad = true;

   for ( const char * _Pg = _Grouping . c_str ( );
    ! _Bad && 0 < _Group; )
    if ( * _Pg == 127 )
     break;
    else if ( 0 < -- _Group && * _Pg != _Groups [ _Group ]
     || 0 == _Group && * _Pg < _Groups [ _Group ] )
     _Bad = true;
    else if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
   }

  if ( _Seendigit && _Significant == 0 )
   * _Ptr ++ = '0';

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ], ++ _First;

  if ( _Significant == 0 )
   {
   for (; _First != _Last && * _First == _E0;
    _Seendigit = true, ++ _First )
    -- _Phex;
   if ( _Phex < 0 )
    * _Ptr ++ = '0', ++ _Phex;
   }

  for (; _First != _Last
    && 0 <= ( _Dig = _Hexdig ( * _First, _E0, _Al, _Au ) );
    _Seendigit = true, ++ _First )
   if ( _Significant < 36 )
    {
    * _Ptr ++ = "0123456789abcdef" [ _Dig ];
    ++ _Significant;
    }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Maklocchr ( 'p', ( _Elem * ) 0, _Cvt )
    || * _First == _Maklocchr ( 'P', ( _Elem * ) 0, _Cvt ) ) )
   {
   * _Ptr ++ = 'p', ++ _First;
   _Seendigit = false, _Significant = 0;

   if ( _First == _Last )
    ;
   else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '+', ++ _First;
   else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '-', ++ _First;
   for (; _First != _Last && * _First == _E0; )
    _Seendigit = true, ++ _First;
   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
    _Seendigit = true, ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  * _Phexexp = _Phex;
  return ( 0 );
  }
};


template < class _Elem,
 class _InIt >
                         locale :: id num_get < _Elem, _InIt > :: id;


template < class _Elem,
 class _OutIt = ostreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_put
  : public locale :: facet{ 


public: typedef numpunct < _Elem > _Mypunct; 

typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > > _Mystr; 

static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )

  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new ( :: std :: _DebugHeapTag_func ( ), "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum", 1053 ) num_put < _Elem, _OutIt > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 4 );
  }

static locale::id id; 


protected: virtual ~ num_put ( )
  {
  }

void _Init ( const _Locinfo & _Lobj )
  {
  _Cvt = _Lobj . _Getcvt ( );
  }

_Locinfo :: _Cvtvec _Cvt; 


public: explicit num_put ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

 num_put ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

typedef _Elem char_type; 
typedef _OutIt iter_type; 

_OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, _Bool _Val ) const

  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

_OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const

  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

_OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const

  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }


_OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, __int64 _Val ) const

  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

_OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned __int64 _Val ) const

  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }


_OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const

  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

_OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const

  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

_OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const

  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }


protected: virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, _Bool _Val ) const

  {
  _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 1144 );
  if ( ! ( _Iosbase . flags ( ) & ios_base :: boolalpha ) )
   return ( do_put ( _Dest, _Iosbase, _Fill, ( long ) _Val ) );
  else
   {
   const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
   _Mystr _Str;
   if ( _Val )
    _Str . assign ( _Punct_fac . truename ( ) );
   else
    _Str . assign ( _Punct_fac . falsename ( ) );

   size_t _Fillcount = _Iosbase . width ( ) <= 0
    || ( size_t ) _Iosbase . width ( ) <= _Str . size ( )
     ? 0 : ( size_t ) _Iosbase . width ( ) - _Str . size ( );

   if ( ( _Iosbase . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
    {
    _Dest = _Rep ( _Dest, _Fill, _Fillcount );
    _Fillcount = 0;
    }
   _Dest = _Put ( _Dest, _Str . c_str ( ), _Str . size ( ) );
   _Iosbase . width ( 0 );
   return ( _Rep ( _Dest, _Fill, _Fillcount ) );
   }
  }

virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const

  {
  char _Buf [ 2 * 32 ], _Fmt [ 6 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "ld",
    _Iosbase . flags ( ) ), _Val ) ) );
  }

virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const

  {
  char _Buf [ 2 * 32 ], _Fmt [ 6 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "lu",
    _Iosbase . flags ( ) ), _Val ) ) );
  }


virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, __int64 _Val ) const

  {
  char _Buf [ 2 * 32 ], _Fmt [ 8 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Ld",
    _Iosbase . flags ( ) ), _Val ) ) );
  }

virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned __int64 _Val ) const

  {
  char _Buf [ 2 * 32 ], _Fmt [ 8 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Lu",
    _Iosbase . flags ( ) ), _Val ) ) );
  }


virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const

  {
  char _Buf [ 8 + 36 + 64 ], _Fmt [ 8 ];
  streamsize _Precision = _Iosbase . precision ( ) <= 0
   && ! ( _Iosbase . flags ( ) & ios_base :: fixed )
    ? 6 : _Iosbase . precision ( );
  int _Significance = 36 < _Precision
   ? 36 : ( int ) _Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: fixed
   && _Val * (0.5) != _Val )
   {
   bool _Signed = _Val < 0;
   if ( _Signed )
    _Val = - _Val;

   for (; (9.9999999999999997e+034) <= _Val && _Beforepoint < 5000; _Beforepoint += 10 )
    _Val /= (10000000000.0);

   if ( 0 < _Val )
    for (; 10 <= _Precision && _Val <= (1e-035)
     && _Afterpoint < 5000; _Afterpoint += 10 )
     {
     _Val *= (10000000000.0);
     _Precision -= 10;
     }

   if ( _Signed )
    _Val = - _Val;
   }

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, ( size_t ) _Precision,
    :: sprintf_s ( _Buf, sizeof ( _Buf ),
     _Ffmt ( _Fmt, 0, _Iosbase . flags ( ) ),
     _Significance, _Val ) ) );
  }

virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const

  {
  char _Buf [ 8 + 36 + 64 ], _Fmt [ 8 ];
  streamsize _Precision = _Iosbase . precision ( ) <= 0
   && ! ( _Iosbase . flags ( ) & ios_base :: fixed )
    ? 6 : _Iosbase . precision ( );
  int _Significance = 36 < _Precision
   ? 36 : ( int ) _Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: fixed )
   {
   bool _Signed = _Val < 0;
   if ( _Signed )
    _Val = - _Val;

   for (; (9.9999999999999997e+034) <= _Val && _Beforepoint < 5000; _Beforepoint += 10 )
    _Val /= (10000000000.0);

   if ( 0 < _Val )
    for (; 10 <= _Precision && _Val <= (1e-035)
     && _Afterpoint < 5000; _Afterpoint += 10 )
     {
     _Val *= (10000000000.0);
     _Precision -= 10;
     }

   if ( _Signed )
    _Val = - _Val;
   }

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, ( size_t ) _Precision,
    :: sprintf_s ( _Buf, sizeof ( _Buf ),
     _Ffmt ( _Fmt, 'L', _Iosbase . flags ( ) ),
     _Significance, _Val ) ) );
  }

virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const

  {
  char _Buf [ 2 * 32 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), "%p", _Val ) ) );
  }


private: char * __cdecl _Ffmt ( char * _Fmt,
  char _Spec, ios_base :: fmtflags _Flags ) const

  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showpoint )
   * _Ptr ++ = '#';
  * _Ptr ++ = '.';
  * _Ptr ++ = '*';
  if ( _Spec != '\000' )
   * _Ptr ++ = _Spec;

  ios_base :: fmtflags _Ffl = _Flags & ios_base :: floatfield;
  * _Ptr ++ = _Ffl == ios_base :: fixed ? 'f'
   : _Ffl == ios_base :: hexfloat ? 'a'
   : _Ffl == ios_base :: scientific ? 'e' : 'g';
  * _Ptr = '\000';
  return ( _Fmt );
  }

_OutIt __cdecl _Fput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const char * _Buf,
   size_t _Beforepoint, size_t _Afterpoint,
    size_t _Trailing, size_t _Count ) const



  {
  _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 1334 );
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Punct_fac . thousands_sep ( );
  string _Groupstring;
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  size_t _Prefix = _Buf [ 0 ] == '+' || _Buf [ 0 ] == '-' ? 1 : 0;

  char _Enders [ 3 ];
  _Enders [ 0 ] = :: localeconv ( ) -> decimal_point [ 0 ];
  _Enders [ 1 ] = 'e';
  _Enders [ 2 ] = '\000';

  const char * _Eptr = ( const char * ) :: memchr ( _Buf,
   'e', _Count );
  const char * _Pointptr = ( const char * ) :: memchr ( _Buf,
   _Enders [ 0 ], _Count );
  if ( _Pointptr == 0 )
   _Trailing = 0;

  if ( * _Grouping . c_str ( ) != 127 && '\000' < * _Grouping . c_str ( ) )
   {
   _Groupstring . append ( _Buf, _Count );
   if ( _Eptr == 0 )
    _Groupstring . append ( _Trailing, '0' );
   else
    {
    if ( _Pointptr == 0 )
     {
     _Groupstring . append ( _Beforepoint, '0' );
     _Beforepoint = 0;
     }
    _Groupstring . insert ( _Eptr - _Buf, _Trailing, '0' );
    }
   _Trailing = 0;

   if ( _Pointptr == 0 )
    _Groupstring . append ( _Beforepoint, '0' );
   else
    {
    _Groupstring . insert ( _Pointptr - _Buf + 1, _Afterpoint, '0' );
    _Groupstring . insert ( _Pointptr - _Buf, _Beforepoint, '0' );
    _Afterpoint = 0;
    }
   _Beforepoint = 0;

   const char * _Pg = _Grouping . c_str ( );
   size_t _Off = :: strcspn ( & _Groupstring [ 0 ], & _Enders [ 0 ] );
   while ( * _Pg != 127 && '\000' < * _Pg
    && ( size_t ) * _Pg < _Off - _Prefix )
    {
    _Groupstring . insert ( _Off -= * _Pg, ( size_t ) 1, '\000' );
    if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
    }

   _Buf = & _Groupstring [ 0 ];
   _Trailing = 0;
   _Count = _Groupstring . size ( );
   }

  size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;
  _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Fillcount
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Fillcount;
  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   if ( 0 < _Prefix )
    {
    _Dest = _Putc ( _Dest, _Buf, 1 );
    ++ _Buf, -- _Count;
    }
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }

  _Pointptr = ( const char * ) :: memchr ( _Buf,
   _Enders [ 0 ], _Count );
  if ( _Pointptr != 0 )
   {
   size_t _Fracoffset = _Pointptr - _Buf + 1;
   _Dest = _Putgrouped ( _Dest, _Buf, _Fracoffset - 1, _Kseparator );
   _Dest = _Rep ( _Dest, _E0, _Beforepoint );
   _Dest = _Rep ( _Dest, _Punct_fac . decimal_point ( ), 1 );
   _Dest = _Rep ( _Dest, _E0, _Afterpoint );
   _Buf += _Fracoffset, _Count -= _Fracoffset;
   }

  _Eptr = ( const char * ) :: memchr ( _Buf,
   'e', _Count );
  if ( _Eptr != 0 )
   {
   size_t _Expoffset = _Eptr - _Buf + 1;
   _Dest = _Putgrouped ( _Dest, _Buf, _Expoffset - 1, _Kseparator );
   _Dest = _Rep ( _Dest, _E0, _Trailing ), _Trailing = 0;
   _Dest = _Putc ( _Dest, _Iosbase . flags ( ) & ios_base :: uppercase
    ? "E" : "e", 1 );
   _Buf += _Expoffset, _Count -= _Expoffset;
   }

  _Dest = _Putgrouped ( _Dest, _Buf, _Count,
   _Kseparator );
  _Dest = _Rep ( _Dest, _E0, _Trailing );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

char * __cdecl _Ifmt ( char * _Fmt,
  const char * _Spec, ios_base :: fmtflags _Flags ) const

  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showbase )
   * _Ptr ++ = '#';
  if ( _Spec [ 0 ] != 'L' )
   * _Ptr ++ = _Spec [ 0 ];
  else

   {
   * _Ptr ++ = 'I';
   * _Ptr ++ = '6';
   * _Ptr ++ = '4';
   }

  ios_base :: fmtflags _Basefield = _Flags & ios_base :: basefield;
  * _Ptr ++ = _Basefield == ios_base :: oct ? 'o'
   : _Basefield != ios_base :: hex ? _Spec [ 1 ]
   : _Flags & ios_base :: uppercase ? 'X' : 'x';
  * _Ptr = '\000';
  return ( _Fmt );
  }

_OutIt __cdecl _Iput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, char * _Buf, size_t _Count ) const

  {
  _Debug_pointer ( _Dest, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78\x6c\x6f\x63\x6e\x75\x6d" L"", 1480 );
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const size_t _Prefix = * _Buf == '+' || * _Buf == '-' ? 1
   : * _Buf == '0' && ( _Buf [ 1 ] == 'x' || _Buf [ 1 ] == 'X' ) ? 2
   : 0;

  if ( * _Grouping . c_str ( ) != 127 && '\000' < * _Grouping . c_str ( ) )
   {
   const char * _Pg = _Grouping . c_str ( );
   size_t _Off = _Count;
   while ( * _Pg != 127 && '\000' < * _Pg
    && ( size_t ) * _Pg < _Off - _Prefix )
    {
    _Off -= * _Pg;

                                        ;
    :: memmove_s ( ( & _Buf [ _Off + 1 ] ), ( _Count + 1 - _Off ), ( & _Buf [ _Off ] ), ( _Count + 1 - _Off ) )
                                    ;

    _Buf [ _Off ] = '\000', ++ _Count;
    if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
    }
   }

  size_t _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Count
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Count;

  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   _Dest = _Putc ( _Dest, _Buf, _Prefix );
   _Buf += _Prefix, _Count -= _Prefix;
   _Dest = _Rep ( _Dest, _Fill, _Fillcount ), _Fillcount = 0;
   }

  _Dest = _Putgrouped ( _Dest, _Buf, _Count,
   _Punct_fac . thousands_sep ( ) );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

_OutIt __cdecl _Put ( _OutIt _Dest,
  const _Elem * _Ptr, size_t _Count ) const

  {
  for (; 0 < _Count; -- _Count, ++ _Dest, ++ _Ptr )
   * _Dest = * _Ptr;
  return ( _Dest );
  }

_OutIt __cdecl _Putc ( _OutIt _Dest,
  const char * _Ptr, size_t _Count ) const

  {
  for (; 0 < _Count; -- _Count, ++ _Dest, ++ _Ptr )
   * _Dest = _Maklocchr ( * _Ptr, ( _Elem * ) 0, _Cvt );
  return ( _Dest );
  }

_OutIt __cdecl _Putgrouped ( _OutIt _Dest,
  const char * _Ptr, size_t _Count, _Elem _Kseparator ) const

  {
  for (;; ++ _Ptr, -- _Count )
   {
   const char * _Pend =
    ( const char * ) :: memchr ( _Ptr, '\000', _Count );
   size_t _Groupsize = _Pend != 0 ? _Pend - _Ptr : _Count;

   _Dest = _Putc ( _Dest, _Ptr, _Groupsize );
   _Ptr += _Groupsize, _Count -= _Groupsize;
   if ( _Count == 0 )
    break;
   if ( _Kseparator != ( _Elem ) 0 )
    _Dest = _Rep ( _Dest, _Kseparator, 1 );
   }
  return ( _Dest );
  }

_OutIt __cdecl _Rep ( _OutIt _Dest,
  _Elem _Ch, size_t _Count ) const

  {
  for (; 0 < _Count; -- _Count, ++ _Dest )
   * _Dest = _Ch;
  return ( _Dest );
  }
};


template < class _Elem,
 class _OutIt >
                         locale :: id num_put < _Elem, _OutIt > :: id;




template locale::id numpunct< char> ::id;

template class __declspec(dllimport) num_get< char, istreambuf_iterator< char, char_traits< char> > > ;

template class __declspec(dllimport) num_put< char, ostreambuf_iterator< char, char_traits< char> > > ;


template locale::id numpunct< __wchar_t> ::id;

template class __declspec(dllimport) num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;

template class __declspec(dllimport) num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;




}



/* Removed pragma: #pragma warning(pop)*/
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
/* Removed pragma: #pragma warning(push,3)*/

#pragma warning(disable: 4189) /* Removed pragma: #pragma warning(disable: 4189)*/
#line 1604 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
#pragma pack ( pop )
#line 8 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
#pragma pack ( push, 8 )




namespace std { 

template < class _Elem,
 class _Traits >
 class basic_ios
  : public ios_base{ 


public: typedef basic_ios < _Elem, _Traits > _Myt; 
typedef basic_ostream < _Elem, _Traits > _Myos; 
typedef basic_streambuf < _Elem, _Traits > _Mysb; 
typedef ctype < _Elem > _Ctype; 
typedef _Elem char_type; 
typedef _Traits traits_type; 
typedef typename _Traits :: int_type int_type; 
typedef typename _Traits :: pos_type pos_type; 
typedef typename _Traits :: off_type off_type; 

explicit basic_ios ( _Mysb * _Strbuf )
  {
  init ( _Strbuf );
  }

virtual ~ basic_ios ( )
  {
  }

void clear ( iostate _State = goodbit,
  bool _Reraise = false )

  {
  ios_base :: clear ( ( iostate ) ( _Mystrbuf == 0
   ? ( int ) _State | ( int ) badbit : ( int ) _State ), _Reraise );
  }

void clear ( io_state _State )
  {
  clear ( ( iostate ) _State );
  }

void setstate ( iostate _State,
  bool _Reraise = false )

  {
  if ( _State != goodbit )
   clear ( ( iostate ) ( ( int ) rdstate ( ) | ( int ) _State ), _Reraise );
  }

void setstate ( io_state _State )
  {
  setstate ( ( iostate ) _State );
  }

_Myt & copyfmt ( const _Myt & _Right )
  {
  _Tiestr = _Right . tie ( );
  _Fillch = _Right . fill ( );
  ios_base :: copyfmt ( _Right );
  return ( * this );
  }

_Myos * tie ( ) const
  {
  return ( _Tiestr );
  }

_Myos * tie ( _Myos * _Newtie )
  {
  _Myos * _Oldtie = _Tiestr;
  _Tiestr = _Newtie;
  return ( _Oldtie );
  }

_Mysb * rdbuf ( ) const
  {
  return ( _Mystrbuf );
  }

_Mysb * rdbuf ( _Mysb * _Strbuf )
  {
  _Mysb * _Oldstrbuf = _Mystrbuf;
  _Mystrbuf = _Strbuf;
  clear ( );
  return ( _Oldstrbuf );
  }

locale imbue ( const locale & _Loc )
  {
  locale _Oldlocale = ios_base :: imbue ( _Loc );
  if ( rdbuf ( ) != 0 )
   rdbuf ( ) -> pubimbue ( _Loc );
  return ( _Oldlocale );
  }

_Elem fill ( ) const
  {
  return ( _Fillch );
  }

_Elem fill ( _Elem _Newfill )
  {
  _Elem _Oldfill = _Fillch;
  _Fillch = _Newfill;
  return ( _Oldfill );
  }

char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( getloc ( ) );
  return ( _Ctype_fac . narrow ( _Ch, _Dflt ) );
  }

_Elem widen ( char _Byte ) const
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( getloc ( ) );
  return ( _Ctype_fac . widen ( _Byte ) );
  }

void move ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this -> swap ( _Right );
   }
  }

void swap ( _Myt & _Right )
  {
  ios_base :: swap ( _Right );
  :: std :: swap ( _Fillch, _Right . _Fillch );
  :: std :: swap ( _Tiestr, _Right . _Tiestr );
  }

void set_rdbuf ( _Mysb * _Strbuf )
  {
  _Mystrbuf = _Strbuf;
  }


protected: void init ( _Mysb * _Strbuf = 0,
  bool _Isstd = false )

  {
  _Init ( );
  _Mystrbuf = _Strbuf;
  _Tiestr = 0;
  _Fillch = widen ( ' ' );

  if ( _Mystrbuf == 0 )
   setstate ( badbit );

  if ( _Isstd )
   _Addstd ( this );
  }

 basic_ios ( )
  {
  }


private: _Mysb * _Mystrbuf; 
_Myos * _Tiestr; 
_Elem _Fillch; 

 basic_ios ( const _Myt & );
_Myt & operator = ( const _Myt & );
};



template class __declspec(dllimport) basic_ios< char, char_traits< char> > ;

template class __declspec(dllimport) basic_ios< __wchar_t, char_traits< __wchar_t> > ;
#line 192
inline ios_base &__cdecl boolalpha(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::boolalpha); 
return (_Iosbase); 
} 

inline ios_base &__cdecl dec(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::dec, _Iosb< int> ::basefield); 
return (_Iosbase); 
} 


inline ios_base &__cdecl defaultfloat(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf(_Iosb< int> ::floatfield); 
return (_Iosbase); 
} 


inline ios_base &__cdecl fixed(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::fixed, _Iosb< int> ::floatfield); 
return (_Iosbase); 
} 

inline ios_base &__cdecl hex(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::hex, _Iosb< int> ::basefield); 
return (_Iosbase); 
} 


namespace tr1 { 
inline ios_base &__cdecl hexfloat(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::hexfloat, _Iosb< int> ::floatfield); 
return (_Iosbase); 
} 
}




using tr1::hexfloat;



inline ios_base &__cdecl internal(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::internal, _Iosb< int> ::adjustfield); 
return (_Iosbase); 
} 

inline ios_base &__cdecl left(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::left, _Iosb< int> ::adjustfield); 
return (_Iosbase); 
} 

inline ios_base &__cdecl noboolalpha(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf(_Iosb< int> ::boolalpha); 
return (_Iosbase); 
} 

inline ios_base &__cdecl noshowbase(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf(_Iosb< int> ::showbase); 
return (_Iosbase); 
} 

inline ios_base &__cdecl noshowpoint(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf(_Iosb< int> ::showpoint); 
return (_Iosbase); 
} 

inline ios_base &__cdecl noshowpos(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf(_Iosb< int> ::showpos); 
return (_Iosbase); 
} 

inline ios_base &__cdecl noskipws(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf(_Iosb< int> ::skipws); 
return (_Iosbase); 
} 

inline ios_base &__cdecl nounitbuf(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf(_Iosb< int> ::unitbuf); 
return (_Iosbase); 
} 

inline ios_base &__cdecl nouppercase(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf(_Iosb< int> ::uppercase); 
return (_Iosbase); 
} 

inline ios_base &__cdecl oct(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::oct, _Iosb< int> ::basefield); 
return (_Iosbase); 
} 

inline ios_base &__cdecl right(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::right, _Iosb< int> ::adjustfield); 
return (_Iosbase); 
} 

inline ios_base &__cdecl scientific(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::scientific, _Iosb< int> ::floatfield); 
return (_Iosbase); 
} 

inline ios_base &__cdecl showbase(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::showbase); 
return (_Iosbase); 
} 

inline ios_base &__cdecl showpoint(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::showpoint); 
return (_Iosbase); 
} 

inline ios_base &__cdecl showpos(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::showpos); 
return (_Iosbase); 
} 

inline ios_base &__cdecl skipws(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::skipws); 
return (_Iosbase); 
} 

inline ios_base &__cdecl unitbuf(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::unitbuf); 
return (_Iosbase); 
} 

inline ios_base &__cdecl uppercase(ios_base &_Iosbase) 
{ 
_Iosbase.setf(_Iosb< int> ::uppercase); 
return (_Iosbase); 
} 
}

/* Removed pragma: #pragma warning(pop)*/
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
/* Removed pragma: #pragma warning(push,3)*/

#pragma warning(disable: 4189 4390) /* Removed pragma: #pragma warning(disable: 4189 4390)*/
#line 350 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
#pragma pack ( pop )
#line 8 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
#pragma pack ( push, 8 )




namespace std { 
#line 34
template < class _Elem,
 class _Traits >
 class basic_ostream
  : virtual public basic_ios < _Elem, _Traits >{ 


public: typedef basic_ostream < _Elem, _Traits > _Myt; 
typedef basic_ios < _Elem, _Traits > _Myios; 
typedef basic_streambuf < _Elem, _Traits > _Mysb; 
typedef ostreambuf_iterator < _Elem, _Traits > _Iter; 
typedef num_put < _Elem, _Iter > _Nput; 

explicit basic_ostream (
  basic_streambuf < _Elem, _Traits > * _Strbuf,

  bool _Isstd = false )



  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

 basic_ostream ( _Uninitialized, bool _Addit = true )
  {
  if ( _Addit )
   ios_base :: _Addstd ( this );
  }

 basic_ostream ( _Myt && _Right )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: move ( _Right ) );
  }

_Myt & operator = ( _Myt && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   _Myios :: swap ( _Right );
  }

virtual ~ basic_ostream ( )
  {
  }

typedef typename _Traits :: int_type int_type; 
typedef typename _Traits :: pos_type pos_type; 
typedef typename _Traits :: off_type off_type; 

class _Sentry_base { 


public:  _Sentry_base ( _Myt & _Ostr )
   : _Myostr ( _Ostr )
   {
   if ( _Myostr . rdbuf ( ) != 0 )
    _Myostr . rdbuf ( ) -> _Lock ( );
   }

 ~ _Sentry_base ( )
   {
   if ( _Myostr . rdbuf ( ) != 0 )
    _Myostr . rdbuf ( ) -> _Unlock ( );
   }

_Myt & _Myostr; 


private: _Sentry_base & operator = ( const _Sentry_base & );
}; 

class sentry 
  : public _Sentry_base { 


public: explicit sentry ( _Myt & _Ostr )
   : _Sentry_base ( _Ostr )
   {
   if ( _Ostr . good ( ) && _Ostr . tie ( ) != 0 )
    _Ostr . tie ( ) -> flush ( );
   _Ok = _Ostr . good ( );
   }

 ~ sentry ( )
   {

   if ( ! uncaught_exception ( ) )
    this -> _Myostr . _Osfx ( );




   }

 operator :: std :: _Bool_type ( ) const
   {
   return ( _Ok ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
   }


private: bool _Ok; 

 sentry ( const sentry & );
sentry & operator = ( const sentry & );
}; 

bool opfx ( )
  {
  if ( ios_base :: good ( ) && _Myios :: tie ( ) != 0 )
   _Myios :: tie ( ) -> flush ( );
  return ( ios_base :: good ( ) );
  }

void osfx ( )
  {
  _Osfx ( );
  }

void _Osfx ( )
  {
  try {
  if ( ios_base :: flags ( ) & ios_base :: unitbuf )
   flush ( );
  } catch ( ... ) {
  }
  }
#line 186
_Myt & operator << ( _Myt & ( __cdecl * _Pfn ) ( _Myt & ) )
  {
  _Debug_pointer ( _Pfn, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x6f\x73\x74\x72\x65\x61\x6d" L"", 188 );
  return ( ( * _Pfn ) ( * this ) );
  }

_Myt & operator << ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  _Debug_pointer ( _Pfn, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x6f\x73\x74\x72\x65\x61\x6d" L"", 194 );
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

_Myt & operator << ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  _Debug_pointer ( _Pfn, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x6f\x73\x74\x72\x65\x61\x6d" L"", 201 );
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

_Myt & operator << ( _Bool _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );
   ios_base :: fmtflags _Bfl =
    ios_base :: flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned short ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }
#line 260
_Myt & operator << ( unsigned short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( int _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );
   ios_base :: fmtflags _Bfl =
    ios_base :: flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned int ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( unsigned int _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( unsigned long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


_Myt & operator << ( __int64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( unsigned __int64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


_Myt & operator << ( float _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( double ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( long double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( const void * _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator << ( _Mysb * _Strbuf )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  bool _Copied = false;
  const sentry _Ok ( * this );

  if ( _Ok && _Strbuf != 0 )
   for ( int_type _Meta = _Traits :: eof ( );; _Copied = true )
    {
    try {
    _Meta = _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta )
     ? _Strbuf -> sgetc ( ) : _Strbuf -> snextc ( );
    } catch ( ... ) {
     _Myios :: setstate ( ios_base :: failbit );
     throw;
    }

    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     break;

    try {
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
      _Myios :: rdbuf ( ) -> sputc (
       _Traits :: to_char_type ( _Meta ) ) ) )
      {
      _State |= ios_base :: badbit;
      break;
      }
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

  ios_base :: width ( 0 );
  _Myios :: setstate ( _Strbuf == 0 ? ios_base :: badbit
   : ! _Copied ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

_Myt & put ( _Elem _Ch )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputc ( _Ch ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & write ( const _Elem * _Str,
  streamsize _Count )

  {

  if ( 0 < _Count )
   _Debug_pointer ( _Str, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x6f\x73\x74\x72\x65\x61\x6d" L"", 549 );


  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else
   {
   try {
   if ( _Myios :: rdbuf ( ) -> sputn ( _Str, _Count ) != _Count )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & flush ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  if ( ! ios_base :: fail ( ) && _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
   _State |= ios_base :: badbit;
  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & seekp ( pos_type _Pos )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: out ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

_Myt & seekp ( off_type _Off, ios_base :: seekdir _Way )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: out ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

pos_type tellp ( )
  {
  if ( ! ios_base :: fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: out ) );
  else
   return ( pos_type ( _BADOFF ) );
  }
};


template < class _Elem,
 class _Traits > inline
 void swap ( basic_ostream < _Elem, _Traits > & _Left,
  basic_ostream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 667
template class __declspec(dllimport) basic_ostream< char, char_traits< char> > ;

template class __declspec(dllimport) basic_ostream< __wchar_t, char_traits< __wchar_t> > ;
#line 677
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const char * _Val )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) :: strlen ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  const ctype < _Elem > & _Ctype_fac = use_facet < ctype < _Elem > > ( _Ostr . getloc ( ) );
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  for (; _State == ios_base :: goodbit && 0 < _Count; -- _Count, ++ _Val )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( * _Val ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, char _Ch )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  const ctype < _Elem > & _Ctype_fac = use_facet < ctype < _Elem > > ( _Ostr . getloc ( ) );
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( _Ch ) ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr,
  const char * _Val )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, char _Ch )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const _Elem * _Val )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;

 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, _Elem _Ch )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;

 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, const signed char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, signed char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, const unsigned char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, unsigned char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }

template < class _Elem,
 class _Traits,
 class _Ty > inline
 basic_ostream < _Elem, _Traits > &
  operator << ( basic_ostream < _Elem, _Traits > && _Ostr, _Ty _Val )
 {
 return ( _Ostr << _Val );
 }


template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl endl ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Ostr . widen ( '\n' ) );
 _Ostr . flush ( );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl ends ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Elem ( ) );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl flush ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . flush ( );
 return ( _Ostr );
 }
#if !defined(CppTest_Stub_endl__ZSt4endlRSo) && defined(CPPTEST_USER_STUB__ZSt4endlRSo)
basic_ostream< char, char_traits< char> >  &__cdecl CppTest_Stub_endl__ZSt4endlRSo(basic_ostream< char, char_traits< char> >  & _Ostr); 
#endif

#if !defined(CppTest_Safe_Stub_endl__ZSt4endlRSo) && defined(CPPTEST_SAFE_STUB__ZSt4endlRSo)
basic_ostream< char, char_traits< char> >  &__cdecl CppTest_Safe_Stub_endl__ZSt4endlRSo(basic_ostream< char, char_traits< char> >  & _Ostr); 
#endif

#if !defined(CppTest_Auto_Stub_endl__ZSt4endlRSo) && defined(CPPTEST_AUTO_STUB__ZSt4endlRSo)
basic_ostream< char, char_traits< char> >  &__cdecl CppTest_Auto_Stub_endl__ZSt4endlRSo(basic_ostream< char, char_traits< char> >  & _Ostr); 
#endif
#line 1003
CPPTEST_IMP__ZSt4endlRSo inline basic_ostream< char, char_traits< char> >  &__cdecl endl(basic_ostream< char, char_traits< char> >  &_Ostr) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(77) 
_Ostr.put('\n'); CPPTEST_STACK_TRACE_STMT_INFO(78) 
_Ostr.flush(); CPPTEST_STACK_TRACE_STMT_INFO(79) 
return (_Ostr); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 


__declspec(dllimport) inline basic_ostream< __wchar_t, char_traits< __wchar_t> >  &__cdecl endl(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
_Ostr) 
{ 
_Ostr.put('\n'); 
_Ostr.flush(); 
return (_Ostr); 
} 



__declspec(dllimport) inline basic_ostream< unsigned short, char_traits< unsigned short> >  &__cdecl endl(basic_ostream< unsigned short, char_traits< unsigned short> >  &
_Ostr) 
{ 
_Ostr.put('\n'); 
_Ostr.flush(); 
return (_Ostr); 
} 



__declspec(dllimport) inline basic_ostream< char, char_traits< char> >  &__cdecl ends(basic_ostream< char, char_traits< char> >  &_Ostr) 
{ 
_Ostr.put('\000'); 
return (_Ostr); 
} 


__declspec(dllimport) inline basic_ostream< __wchar_t, char_traits< __wchar_t> >  &__cdecl ends(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
_Ostr) 
{ 
_Ostr.put('\000'); 
return (_Ostr); 
} 



__declspec(dllimport) inline basic_ostream< unsigned short, char_traits< unsigned short> >  &__cdecl ends(basic_ostream< unsigned short, char_traits< unsigned short> >  &
_Ostr) 
{ 
_Ostr.put('\000'); 
return (_Ostr); 
} 



__declspec(dllimport) inline basic_ostream< char, char_traits< char> >  &__cdecl flush(basic_ostream< char, char_traits< char> >  &_Ostr) 
{ 
_Ostr.flush(); 
return (_Ostr); 
} 


__declspec(dllimport) inline basic_ostream< __wchar_t, char_traits< __wchar_t> >  &__cdecl flush(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
_Ostr) 
{ 
_Ostr.flush(); 
return (_Ostr); 
} 



__declspec(dllimport) inline basic_ostream< unsigned short, char_traits< unsigned short> >  &__cdecl flush(basic_ostream< unsigned short, char_traits< unsigned short> >  &
_Ostr) 
{ 
_Ostr.flush(); 
return (_Ostr); 
} 




template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
   const error_code & _Errcode )
 {
 return ( _Ostr << _Errcode . category ( ) . name ( ) << ':' << _Errcode . value ( ) );
 }

}

/* Removed pragma: #pragma warning(pop)*/
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
/* Removed pragma: #pragma warning(push,3)*/

#pragma warning(disable: 4189) /* Removed pragma: #pragma warning(disable: 4189)*/
#line 1094 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
#pragma pack ( pop )
#line 8 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
#pragma pack ( push, 8 )




namespace std { 

template < class _Elem,
 class _Traits >
 class basic_istream
  : virtual public basic_ios < _Elem, _Traits >{ 


public: typedef basic_istream < _Elem, _Traits > _Myt; 
typedef basic_ios < _Elem, _Traits > _Myios; 
typedef basic_streambuf < _Elem, _Traits > _Mysb; 
typedef istreambuf_iterator < _Elem, _Traits > _Iter; 
typedef ctype < _Elem > _Ctype; 
typedef num_get < _Elem, _Iter > _Nget; 


explicit basic_istream ( _Mysb * _Strbuf,
  bool _Isstd = false )


  : _Chcount ( 0 )
  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

 basic_istream ( _Uninitialized )
  {
  ios_base :: _Addstd ( this );
  }

 basic_istream ( _Myt && _Right )
  : _Chcount ( _Right . _Chcount )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: move ( _Right ) );
  _Right . _Chcount = 0;
  }

_Myt & operator = ( _Myt && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

void swap ( _Myt & _Right )
  {
  _Myios :: swap ( _Right );
  :: std :: swap ( _Chcount, _Right . _Chcount );
  }

virtual ~ basic_istream ( )
  {
  }

typedef typename _Traits :: int_type int_type; 
typedef typename _Traits :: pos_type pos_type; 
typedef typename _Traits :: off_type off_type; 


class _Sentry_base { 


public:  _Sentry_base ( _Myt & _Istr )
   : _Myistr ( _Istr )
   {
   if ( _Myistr . rdbuf ( ) != 0 )
    _Myistr . rdbuf ( ) -> _Lock ( );
   }

 ~ _Sentry_base ( )
   {
   if ( _Myistr . rdbuf ( ) != 0 )
    _Myistr . rdbuf ( ) -> _Unlock ( );
   }

_Myt & _Myistr; 


private: _Sentry_base & operator = ( const _Sentry_base & );
}; 

class sentry 
  : public _Sentry_base { 


public: explicit sentry ( _Myt & _Istr, bool _Noskip = false )
   : _Sentry_base ( _Istr )
   {
   _Ok = this -> _Myistr . _Ipfx ( _Noskip );
   }

 operator :: std :: _Bool_type ( ) const
   {
   return ( _Ok ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
   }


private: bool _Ok; 

 sentry ( const sentry & );
sentry & operator = ( const sentry & );
}; 

bool _Ipfx ( bool _Noskip = false )
  {
  if ( ios_base :: good ( ) )
   {
   if ( _Myios :: tie ( ) != 0 )
    _Myios :: tie ( ) -> flush ( );

   if ( ! _Noskip && ios_base :: flags ( ) & ios_base :: skipws )
    {
    const _Ctype & _Ctype_fac = use_facet < _Ctype > ( ios_base :: getloc ( ) );

    try {
    int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

    for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
      {
      _Myios :: setstate ( ios_base :: eofbit );
      break;
      }
     else if ( ! _Ctype_fac . is ( _Ctype :: space,
      _Traits :: to_char_type ( _Meta ) ) )
      break;
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

   if ( ios_base :: good ( ) )
    return ( true );
   }
  _Myios :: setstate ( ios_base :: failbit );
  return ( false );
  }

bool ipfx ( bool _Noskip = false )
  {
  return ( _Ipfx ( _Noskip ) );
  }

void isfx ( )
  {
  }
#line 179
_Myt & operator >> ( _Myt & ( __cdecl * _Pfn ) ( _Myt & ) )
  {
  _Debug_pointer ( _Pfn, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x73\x74\x72\x65\x61\x6d" L"", 181 );
  return ( ( * _Pfn ) ( * this ) );
  }

_Myt & operator >> ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  _Debug_pointer ( _Pfn, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x73\x74\x72\x65\x61\x6d" L"", 187 );
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

_Myt & operator >> ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  _Debug_pointer ( _Pfn, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x73\x74\x72\x65\x61\x6d" L"", 194 );
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

_Myt & operator >> ( _Bool & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( short & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   long _Tmp = 0;
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Tmp );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }

   if ( _State & ios_base :: failbit
    || _Tmp < ( - 32768 ) || 32767 < _Tmp )
    _State |= ios_base :: failbit;
   else
    _Val = ( short ) _Tmp;
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }
#line 253
_Myt & operator >> ( unsigned short & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( int & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   long _Tmp = 0;
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Tmp );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }

   if ( _State & ios_base :: failbit
    || _Tmp < ( - 2147483647 - 1 ) || 2147483647 < _Tmp )
    _State |= ios_base :: failbit;
   else
    _Val = _Tmp;
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( unsigned int & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( long & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );
   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( unsigned long & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


_Myt & operator >> ( __int64 & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( unsigned __int64 & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


_Myt & operator >> ( float & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( double & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( long double & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );
   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( void * & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & operator >> ( _Mysb * _Strbuf )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  bool _Copied = false;
  const sentry _Ok ( * this );

  if ( _Ok && _Strbuf != 0 )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     try {
      if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
       _Strbuf -> sputc ( _Traits :: to_char_type ( _Meta ) ) ) )
       break;
     } catch ( ... ) {
      break;
     }
     _Copied = true;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( ! _Copied ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

int_type get ( )
  {
  int_type _Meta = 0;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   else
    {
    _Myios :: rdbuf ( ) -> sbumpc ( );
    ++ _Chcount;
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

_Myt & get ( _Elem * _Str, streamsize _Count )
  {
  return ( get ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

_Myt & get ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )

  {
  _Debug_pointer ( _Str, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x73\x74\x72\x65\x61\x6d" L"", 537 );
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (; 0 < -- _Count; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Traits :: to_char_type ( _Meta ) == _Delim )
     break;
    else
     {
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _Chcount == 0
   ? _State | ios_base :: failbit : _State );
  * _Str = _Elem ( );
  return ( * this );
  }

_Myt & get ( _Elem & _Ch )
  {
  int_type _Meta = get ( );
  if ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _Ch = _Traits :: to_char_type ( _Meta );
  return ( * this );
  }

_Myt & get ( _Mysb & _Strbuf )
  {
  return ( get ( _Strbuf, _Myios :: widen ( '\n' ) ) );
  }

_Myt & get ( _Mysb & _Strbuf, _Elem _Delim )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     try {
      _Elem _Ch = _Traits :: to_char_type ( _Meta );
      if ( _Ch == _Delim
       || _Traits :: eq_int_type ( _Traits :: eof ( ),
        _Strbuf . sputc ( _Ch ) ) )
       break;
     } catch ( ... ) {
      break;
     }
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  if ( _Chcount == 0 )
   _State |= ios_base :: failbit;
  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & getline ( _Elem * _Str, streamsize _Count )
  {
  return ( getline ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

_Myt & getline ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )

  {
  _Debug_pointer ( _Str, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x73\x74\x72\x65\x61\x6d" L"", 629 );
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   int_type _Metadelim = _Traits :: to_int_type ( _Delim );

   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Meta == _Metadelim )
     {
     ++ _Chcount;
     _Myios :: rdbuf ( ) -> sbumpc ( );
     break;
     }
    else if ( -- _Count <= 0 )
     {
     _State |= ios_base :: failbit;
     break;
     }
    else
     {
     ++ _Chcount;
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  * _Str = _Elem ( );
  _Myios :: setstate ( _Chcount == 0 ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

_Myt & ignore ( streamsize _Count = 1,
  int_type _Metadelim = _Traits :: eof ( ) )

  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   for (;; )
    {
    int_type _Meta;
    if ( _Count != 2147483647 && -- _Count < 0 )
     break;
    else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Meta = _Myios :: rdbuf ( ) -> sbumpc ( ) ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     ++ _Chcount;
     if ( _Meta == _Metadelim )
      break;
     }
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & read ( _Elem * _Str, streamsize _Count )
  {
  _Debug_pointer ( _Str, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x73\x74\x72\x65\x61\x6d" L"", 708 );
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   const streamsize _Num = _Myios :: rdbuf ( ) -> sgetn ( _Str, _Count );
   _Chcount += _Num;
   if ( _Num != _Count )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

streamsize readsome ( _Elem * _Str,
  streamsize _Count )

  {
  _Debug_pointer ( _Str, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x73\x74\x72\x65\x61\x6d" L"", 730 );
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );
  streamsize _Num;

  if ( ! _Ok )
   _State |= ios_base :: failbit;
  else if ( ( _Num = _Myios :: rdbuf ( ) -> in_avail ( ) ) < 0 )
   _State |= ios_base :: eofbit;
  else if ( 0 < _Num )
   read ( _Str, _Num < _Count ? _Num : _Count );

  _Myios :: setstate ( _State );
  return ( gcount ( ) );
  }

int_type peek ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  int_type _Meta = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Meta = _Myios :: rdbuf ( ) -> sgetc ( ) ) )
    _State |= ios_base :: eofbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

_Myt & putback ( _Elem _Ch )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputbackc ( _Ch ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

_Myt & unget ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sungetc ( ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

streamsize gcount ( ) const
  {
  return ( _Chcount );
  }

int sync ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  int _Ans;

  if ( _Myios :: rdbuf ( ) == 0 )
   _Ans = - 1;
  else if ( _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
   {
   _State |= ios_base :: badbit;
   _Ans = - 1;
   }
  else
   _Ans = 0;

  _Myios :: setstate ( _State );
  return ( _Ans );
  }

_Myt & seekg ( pos_type _Pos )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: in ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

_Myt & seekg ( off_type _Off, ios_base :: seekdir _Way )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: in ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

pos_type tellg ( )
  {
  if ( ! ios_base :: fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: in ) );
  else
   return ( pos_type ( _BADOFF ) );
  }


private: streamsize _Chcount; 
};


template < class _Elem,
 class _Traits > inline
 void swap ( basic_istream < _Elem, _Traits > & _Left,
  basic_istream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 910
template class __declspec(dllimport) basic_istream< char, char_traits< char> > ;

template class __declspec(dllimport) basic_istream< __wchar_t, char_traits< __wchar_t> > ;
#line 919
template < class _Elem,
 class _Traits >
 class basic_iostream
 : public basic_istream < _Elem, _Traits >,
  public basic_ostream < _Elem, _Traits >{ 


public: typedef basic_iostream < _Elem, _Traits > _Myt; 
typedef basic_istream < _Elem, _Traits > _Myis; 
typedef basic_ostream < _Elem, _Traits > _Myos; 
typedef basic_ios < _Elem, _Traits > _Myios; 
typedef _Elem char_type; 
typedef _Traits traits_type; 
typedef typename _Traits :: int_type int_type; 
typedef typename _Traits :: pos_type pos_type; 
typedef typename _Traits :: off_type off_type; 

explicit basic_iostream ( basic_streambuf < _Elem, _Traits > * _Strbuf )
  : _Myis ( _Strbuf, false ),
   _Myos ( _Noinit, false )
  {
  }

 basic_iostream ( _Myt && _Right )
  : _Myis ( _Right . rdbuf ( ), false ),
   _Myos ( _Noinit, false )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: forward < _Myt > ( _Right ) );
  }

_Myt & operator = ( _Myt && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   _Myios :: swap ( _Right );
  }

virtual ~ basic_iostream ( )
  {
  }
};


template < class _Elem,
 class _Traits > inline
 void swap ( basic_iostream < _Elem, _Traits > & _Left,
  basic_iostream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }



template class __declspec(dllimport) basic_iostream< char, char_traits< char> > ;
template class __declspec(dllimport) basic_iostream< __wchar_t, char_traits< __wchar_t> > ;
#line 985
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > && _Istr, _Elem * _Str )
 {
 _Debug_pointer ( _Str, L"\x63\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x56\x69\x73\x75\x61" L"\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x30\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69\x73\x74\x72\x65\x61\x6d" L"", 990 );
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef ctype < _Elem > _Ctype;
 ios_base :: iostate _State = ios_base :: goodbit;
 _Elem * _Str0 = _Str;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );

  try {
  streamsize _Count = 0 < _Istr . width ( ) ? _Istr . width ( ) : 2147483647;
  typename _Myis :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );
  _Elem _Ch;
  for (; 0 < -- _Count; _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Ctype_fac . is ( _Ctype :: space,
    _Ch = _Traits :: to_char_type ( _Meta ) )
     || _Ch == _Elem ( ) )
    break;
   else
    * _Str ++ = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 * _Str = _Elem ( );
 _Istr . width ( 0 );
 _Istr . setstate ( _Str == _Str0 ? _State | ios_base :: failbit : _State );
 return ( _Istr );
 }

template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > && _Istr, _Elem & _Ch )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;

 typename _Myis :: int_type _Meta;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  try {
  _Meta = _Istr . rdbuf ( ) -> sbumpc ( );
  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _State |= ios_base :: eofbit | ios_base :: failbit;
  else
   _Ch = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Istr . setstate ( _State );
 return ( _Istr );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > && _Istr, signed char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > && _Istr, signed char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > && _Istr, unsigned char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > && _Istr, unsigned char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }

template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem * _Str )
 {
 return ( :: std :: move ( _Istr ) >> _Str );
 }

template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem & _Ch )
 {
 return ( :: std :: move ( _Istr ) >> _Ch );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, signed char * _Str )
 {
 return ( :: std :: move ( _Istr ) >> ( char * ) _Str );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, signed char & _Ch )
 {
 return ( :: std :: move ( _Istr ) >> ( char & ) _Ch );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char * _Str )
 {
 return ( :: std :: move ( _Istr ) >> ( char * ) _Str );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char & _Ch )
 {
 return ( :: std :: move ( _Istr ) >> ( char & ) _Ch );
 }

template < class _Elem,
 class _Traits,
 class _Ty > inline
 basic_istream < _Elem, _Traits > &
  operator >> ( basic_istream < _Elem, _Traits > && _Istr, _Ty & _Val )
 {
 return ( _Istr >> _Val );
 }


template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > &
  __cdecl ws ( basic_istream < _Elem, _Traits > & _Istr )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef ctype < _Elem > _Ctype;

 if ( ! _Istr . eof ( ) )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const typename _Myis :: sentry _Ok ( _Istr, true );

  if ( _Ok )
   {
   const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );

   try {
   for ( typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );;
    _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( ! _Ctype_fac . is ( _Ctype :: space,
     _Traits :: to_char_type ( _Meta ) ) )
     break;
   } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
   }

  _Istr . setstate ( _State );
  }
 return ( _Istr );
 }


__declspec(dllimport) inline basic_istream< char, char_traits< char> >  &__cdecl ws(basic_istream< char, char_traits< char> >  &_Istr) 
{ 
typedef char _Elem; 
typedef char_traits< char>  _Traits; 

if (!_Istr.eof()) 
{ 
ios_base::iostate _State = (_Iosb< int> ::goodbit); 
const basic_istream< char, char_traits< char> > ::sentry _Ok(_Istr, true); 

if (_Ok) 
{ 
const ctype< char>  &_Ctype_fac = use_facet< ctype< char> > (_Istr.getloc()); 


try { 
for (char_traits< char> ::int_type _Meta = _Istr.rdbuf()->sgetc(); 1; _Meta = _Istr.rdbuf()->snextc()) 

if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
{ 
_State |= _Iosb< int> ::eofbit; 
break; 
} else 
if (!_Ctype_fac.is(ctype< char> ::space, _Traits::to_char_type(_Meta))) 

break;       
} catch (...) { (_Istr).setstate(_Iosb< int> ::badbit, true); }  
}  

_Istr.setstate(_State); 
}  
return (_Istr); 
} 


__declspec(dllimport) inline basic_istream< __wchar_t, char_traits< __wchar_t> >  &__cdecl ws(basic_istream< __wchar_t, char_traits< __wchar_t> >  &_Istr) 
{ 
typedef __wchar_t _Elem; 
typedef char_traits< __wchar_t>  _Traits; 

if (!_Istr.eof()) 
{ 
ios_base::iostate _State = (_Iosb< int> ::goodbit); 
const basic_istream< __wchar_t, char_traits< __wchar_t> > ::sentry _Ok(_Istr, true); 

if (_Ok) 
{ 
const ctype< __wchar_t>  &_Ctype_fac = use_facet< ctype< __wchar_t> > (_Istr.getloc()); 


try { 
for (char_traits< __wchar_t> ::int_type _Meta = _Istr.rdbuf()->sgetc(); 1; _Meta = _Istr.rdbuf()->snextc()) 

if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
{ 
_State |= _Iosb< int> ::eofbit; 
break; 
} else 
if (!_Ctype_fac.is(ctype< __wchar_t> ::space, _Traits::to_char_type(_Meta))) 

break;       
} catch (...) { (_Istr).setstate(_Iosb< int> ::badbit, true); }  
}  

_Istr.setstate(_State); 
}  
return (_Istr); 
} 



__declspec(dllimport) inline basic_istream< unsigned short, char_traits< unsigned short> >  &__cdecl ws(basic_istream< unsigned short, char_traits< unsigned short> >  &_Istr) 
{ 
typedef unsigned short _Elem; 
typedef char_traits< unsigned short>  _Traits; 

if (!_Istr.eof()) 
{ 
ios_base::iostate _State = (_Iosb< int> ::goodbit); 
const basic_istream< unsigned short, char_traits< unsigned short> > ::sentry _Ok(_Istr, true); 

if (_Ok) 
{ 
const ctype< unsigned short>  &_Ctype_fac = use_facet< ctype< unsigned short> > (_Istr.getloc()); 


try { 
for (char_traits< unsigned short> ::int_type _Meta = _Istr.rdbuf()->sgetc(); 1; _Meta = _Istr.rdbuf()->snextc()) 

if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
{ 
_State |= _Iosb< int> ::eofbit; 
break; 
} else 
if (!_Ctype_fac.is(ctype< unsigned short> ::space, _Traits::to_char_type(_Meta))) 

break;       
} catch (...) { (_Istr).setstate(_Iosb< int> ::badbit, true); }  
}  

_Istr.setstate(_State); 
}  
return (_Istr); 
} 

}

/* Removed pragma: #pragma warning(pop)*/
#line 9 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\iostream"
/* Removed pragma: #pragma warning(push,3)*/
#line 1279 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
#pragma pack ( pop )
#line 8 "c:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\include\\iostream"
#pragma pack ( push, 8 )

namespace std { 
#line 25
__declspec(dllimport) extern istream cin, *_Ptr_cin; 
__declspec(dllimport) extern ostream cout, *_Ptr_cout; 
__declspec(dllimport) extern ostream cerr, *_Ptr_cerr; 
__declspec(dllimport) extern ostream clog, *_Ptr_clog; 

__declspec(dllimport) extern wistream wcin, *_Ptr_wcin; 
__declspec(dllimport) extern wostream wcout, *_Ptr_wcout; 
__declspec(dllimport) extern wostream wcerr, *_Ptr_wcerr; 
__declspec(dllimport) extern wostream wclog, *_Ptr_wclog; 


class __declspec(dllimport) _Winit { 

public: __thiscall _Winit(); 
__thiscall ~_Winit(); 

private: static int _Init_cnt; 
}; 


}
/* Removed pragma: #pragma warning(pop)*/
#pragma pack ( pop )
#line 3 "C:\\gitfile\\msgTest\\doTest\\doTest\\main.cpp"
class CTest { 


public: int add(int x, int y) 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() unsigned int _Insure_funcID = cpptestCoverageFunction(__CPTR_cui, _cpptest_strdata[2], 1);cpptestCoverageStmt(1U, 0U, __CPTR_cui, _Insure_funcID, 1);CPPTEST_STACK_TRACE_STMT_INFO(80) 
return x + y; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 
#if !defined(CppTest_Auto_Stub_add__ZN5CTest3addEii) && defined(CPPTEST_AUTO_STUB__ZN5CTest3addEii)
int CppTest_Auto_Stub_add__ZN5CTest3addEii(int x, int y); 
#endif

#if !defined(CppTest_Safe_Stub_add__ZN5CTest3addEii) && defined(CPPTEST_SAFE_STUB__ZN5CTest3addEii)
int CppTest_Safe_Stub_add__ZN5CTest3addEii(int x, int y); 
#endif

#if !defined(CppTest_Stub_add__ZN5CTest3addEii) && defined(CPPTEST_USER_STUB__ZN5CTest3addEii)
int CppTest_Stub_add__ZN5CTest3addEii(int x, int y); 
#endif
#line 10
}; 

void newMain() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() unsigned int _Insure_funcID = cpptestCoverageFunction(__CPTR_cui, _cpptest_strdata[3], 2);cpptestCoverageStmt(1U, 1U, __CPTR_cui, _Insure_funcID, 2);
CTest obj; CPPTEST_STACK_TRACE_STMT_INFO(81) cpptestCoverageStmt(2U, 1U, __CPTR_cui, _Insure_funcID, 2);

for (int i = 0; (cpptestCoverageStmt(3U, 1U, __CPTR_cui, _Insure_funcID, 2), i < 100); (cpptestCoverageStmt(4U, 1U, __CPTR_cui, _Insure_funcID, 2), ++i)) 
{ CPPTEST_STACK_TRACE_STMT_INFO(82) cpptestCoverageStmt(5U, 1U, __CPTR_cui, _Insure_funcID, 2);
for (int j = 0; (cpptestCoverageStmt(6U, 1U, __CPTR_cui, _Insure_funcID, 2), j < 100); (cpptestCoverageStmt(7U, 1U, __CPTR_cui, _Insure_funcID, 2), ++j)) 
{ cpptestCoverageStmt(8U, 1U, __CPTR_cui, _Insure_funcID, 2);CPPTEST_STACK_TRACE_STMT_INFO(83) 

((std::cout << obj.CppTest_Stub__Call_add__ZN5CTest3addEii(i, j)) << (std::CppTest_Stub__Call_endl__ZSt4endlRSo)); CPPTEST_STACK_TRACE_BLOCK_END_INFO(84) 
}  CPPTEST_STACK_TRACE_BLOCK_END_INFO(85) 
}  cpptestCoverageStmt(9U, 1U, __CPTR_cui, _Insure_funcID, 2);CPPTEST_STACK_TRACE_STMT_INFO(86) 

CppTest_Stub__Call_system_system("pause"); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} ;
#line 6 "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"
class TestSuite_main_cpp_50199427 : public CppTest_TestSuite { 


public: typedef TestSuite_main_cpp_50199427 ThisTestSuite; static void (TestSuite_main_cpp_50199427::*call_slave_ptr)(void); static void call_slave() { CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_7, 87) TestSuite_main_cpp_50199427 s; CPPTEST_STACK_TRACE_STMT_INFO(88) cpptestIgnoreCurrStackElement(); CPPTEST_STACK_TRACE_STMT_INFO(89) s.setUp(); CPPTEST_STACK_TRACE_STMT_INFO(90) (s.*call_slave_ptr)(); CPPTEST_STACK_TRACE_STMT_INFO(91) s.tearDown(); CPPTEST_STACK_TRACE_EXIT_ROUTINE() } static void testSuiteBegin() { CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(92) cpptestTestSuiteBegin(_cpptest_strdata_var(4, "TestSuite_main_cpp_50199427"), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 9); CPPTEST_STACK_TRACE_EXIT_ROUTINE() } static void cpptest_test_no_exception(void (TestSuite_main_cpp_50199427::*testcase_ptr)(void)) { CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(93) cpptestIgnoreCurrStackElement(); CPPTEST_STACK_TRACE_STMT_INFO(94) try { CPPTEST_STACK_TRACE_STMT_INFO(95) try { CPPTEST_STACK_TRACE_STMT_INFO(96) call_slave_ptr = testcase_ptr; CPPTEST_STACK_TRACE_STMT_INFO(97) cpptestTestCaseSlave(&call_slave); CPPTEST_STACK_TRACE_BLOCK_END_INFO(98) } catch (std::exception &except) { CPPTEST_STACK_TRACE_EXCEPTION_HANDLER_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(99) cpptestIgnoreCurrStackElement(); CPPTEST_STACK_TRACE_STMT_INFO(100) cpptestUnhandledStdExceptionInTestCase(except.what()); CPPTEST_STACK_TRACE_BLOCK_END_INFO(101) CPPTEST_STACK_TRACE_EXIT_EXCEPTION_HANDLER() } catch (...) { CPPTEST_STACK_TRACE_EXCEPTION_HANDLER_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(102) cpptestIgnoreCurrStackElement(); CPPTEST_STACK_TRACE_STMT_INFO(103) cpptestUnhandledCppExceptionInTestCase(); CPPTEST_STACK_TRACE_BLOCK_END_INFO(104) CPPTEST_STACK_TRACE_EXIT_EXCEPTION_HANDLER() }  CPPTEST_STACK_TRACE_BLOCK_END_INFO(105) } catch (...) { CPPTEST_STACK_TRACE_EXCEPTION_HANDLER_START_INFO() CPPTEST_STACK_TRACE_BLOCK_END_INFO(106) CPPTEST_STACK_TRACE_EXIT_EXCEPTION_HANDLER() }  CPPTEST_STACK_TRACE_EXIT_ROUTINE() } static int call(const char *name) { CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(107) cpptestIgnoreCurrStackElement(); CPPTEST_STACK_TRACE_STMT_INFO(108) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(109) , cpptestStrCmp(name, "test_add_1") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(110) cpptestTestCaseBegin(_cpptest_strdata_var(6, "test_add_1"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 10); CPPTEST_STACK_TRACE_STMT_INFO(111) cpptest_test_no_exception(&ThisTestSuite::test_add_1); CPPTEST_STACK_TRACE_STMT_INFO(112) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(113) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(114) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(115) , cpptestStrCmp(name, "test_add_10") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(116) cpptestTestCaseBegin(_cpptest_strdata_var(7, "test_add_10"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 11); CPPTEST_STACK_TRACE_STMT_INFO(117) cpptest_test_no_exception(&ThisTestSuite::test_add_10); CPPTEST_STACK_TRACE_STMT_INFO(118) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(119) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(120) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(121) , cpptestStrCmp(name, "test_add_2") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(122) cpptestTestCaseBegin(_cpptest_strdata_var(8, "test_add_2"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 12); CPPTEST_STACK_TRACE_STMT_INFO(123) cpptest_test_no_exception(&ThisTestSuite::test_add_2); CPPTEST_STACK_TRACE_STMT_INFO(124) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(125) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(126) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(127) , cpptestStrCmp(name, "test_add_3") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(128) cpptestTestCaseBegin(_cpptest_strdata_var(9, "test_add_3"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 13); CPPTEST_STACK_TRACE_STMT_INFO(129) cpptest_test_no_exception(&ThisTestSuite::test_add_3); CPPTEST_STACK_TRACE_STMT_INFO(130) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(131) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(132) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(133) , cpptestStrCmp(name, "test_add_4") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(134) cpptestTestCaseBegin(_cpptest_strdata_var(10, "test_add_4"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 14); CPPTEST_STACK_TRACE_STMT_INFO(135) cpptest_test_no_exception(&ThisTestSuite::test_add_4); CPPTEST_STACK_TRACE_STMT_INFO(136) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(137) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(138) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(139) , cpptestStrCmp(name, "test_add_5") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(140) cpptestTestCaseBegin(_cpptest_strdata_var(11, "test_add_5"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 15); CPPTEST_STACK_TRACE_STMT_INFO(141) cpptest_test_no_exception(&ThisTestSuite::test_add_5); CPPTEST_STACK_TRACE_STMT_INFO(142) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(143) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(144) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(145) , cpptestStrCmp(name, "test_add_6") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(146) cpptestTestCaseBegin(_cpptest_strdata_var(12, "test_add_6"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 16); CPPTEST_STACK_TRACE_STMT_INFO(147) cpptest_test_no_exception(&ThisTestSuite::test_add_6); CPPTEST_STACK_TRACE_STMT_INFO(148) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(149) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(150) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(151) , cpptestStrCmp(name, "test_add_7") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(152) cpptestTestCaseBegin(_cpptest_strdata_var(13, "test_add_7"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 17); CPPTEST_STACK_TRACE_STMT_INFO(153) cpptest_test_no_exception(&ThisTestSuite::test_add_7); CPPTEST_STACK_TRACE_STMT_INFO(154) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(155) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(156) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(157) , cpptestStrCmp(name, "test_add_8") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(158) cpptestTestCaseBegin(_cpptest_strdata_var(14, "test_add_8"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 18); CPPTEST_STACK_TRACE_STMT_INFO(159) cpptest_test_no_exception(&ThisTestSuite::test_add_8); CPPTEST_STACK_TRACE_STMT_INFO(160) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(161) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(162) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(163) , cpptestStrCmp(name, "test_add_9") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(164) cpptestTestCaseBegin(_cpptest_strdata_var(15, "test_add_9"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 19); CPPTEST_STACK_TRACE_STMT_INFO(165) cpptest_test_no_exception(&ThisTestSuite::test_add_9); CPPTEST_STACK_TRACE_STMT_INFO(166) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(167) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(168) ; 
if ((CPPTEST_STACK_TRACE_IF_COND_INFO(169) , cpptestStrCmp(name, "test_main_1") == 0)) { CPPTEST_STACK_TRACE_STMT_INFO(170) cpptestTestCaseBegin(_cpptest_strdata_var(16, "test_main_1"), 0U, 0xffffU, 1, _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 20); CPPTEST_STACK_TRACE_STMT_INFO(171) cpptest_test_no_exception(&ThisTestSuite::test_main_1); CPPTEST_STACK_TRACE_STMT_INFO(172) cpptestTestCaseEnd(); CPPTEST_STACK_TRACE_STMT_INFO(173) return 0; }  CPPTEST_STACK_TRACE_STMT_INFO(174) ; CPPTEST_STACK_TRACE_STMT_INFO(175) 
return 1; CPPTEST_STACK_TRACE_EXIT_ROUTINE() } 

virtual void setUp(); 
virtual void tearDown(); 

void test_add_1(); 
void test_add_10(); 
void test_add_2(); 
void test_add_3(); 
void test_add_4(); 
void test_add_5(); 
void test_add_6(); 
void test_add_7(); 
void test_add_8(); 
void test_add_9(); 
void test_main_1(); 
}; 

void (TestSuite_main_cpp_50199427::*TestSuite_main_cpp_50199427::call_slave_ptr)(void); extern "C" void TestSuite_main_cpp_50199427_testSuiteBegin() { CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(176) TestSuite_main_cpp_50199427::testSuiteBegin(); CPPTEST_STACK_TRACE_EXIT_ROUTINE() } extern "C" int TestSuite_main_cpp_50199427_callTest(const char *name) { CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(177) cpptestIgnoreCurrStackElement(); CPPTEST_STACK_TRACE_STMT_INFO(178) return TestSuite_main_cpp_50199427::call(name); CPPTEST_STACK_TRACE_EXIT_ROUTINE() } ;

void TestSuite_main_cpp_50199427::setUp() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 

void TestSuite_main_cpp_50199427::tearDown() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 



void TestSuite_main_cpp_50199427::test_add_1() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_8, 179) int _x = cpptestLimitsGetMaxInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_9, 180) int _y = cpptestLimitsGetMaxInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_10, 181) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(182) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 63); CPPTEST_STACK_TRACE_STMT_INFO(183) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_add_10() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_11, 184) int _x = (-1); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_12, 185) int _y = 0; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_13, 186) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(187) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 81); CPPTEST_STACK_TRACE_STMT_INFO(188) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_add_2() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_14, 189) int _x = cpptestLimitsGetMinInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_15, 190) int _y = cpptestLimitsGetMaxInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_16, 191) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(192) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 99); CPPTEST_STACK_TRACE_STMT_INFO(193) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_add_3() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_17, 194) int _x = 1; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_18, 195) int _y = cpptestLimitsGetMaxInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_19, 196) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(197) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 117); CPPTEST_STACK_TRACE_STMT_INFO(198) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_add_4() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_20, 199) int _x = cpptestLimitsGetMaxInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_21, 200) int _y = cpptestLimitsGetMinInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_22, 201) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(202) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 135); CPPTEST_STACK_TRACE_STMT_INFO(203) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_add_5() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_23, 204) int _x = (-1); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_24, 205) int _y = cpptestLimitsGetMinInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_25, 206) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(207) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 153); CPPTEST_STACK_TRACE_STMT_INFO(208) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_add_6() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_26, 209) int _x = cpptestLimitsGetMaxInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_27, 210) int _y = (-1); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_28, 211) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(212) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 171); CPPTEST_STACK_TRACE_STMT_INFO(213) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_add_7() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_29, 214) int _x = 1; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_30, 215) int _y = (-1); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_31, 216) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(217) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 189); CPPTEST_STACK_TRACE_STMT_INFO(218) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_add_8() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_32, 219) int _x = cpptestLimitsGetMinInt(); 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_33, 220) int _y = 1; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_34, 221) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(222) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 207); CPPTEST_STACK_TRACE_STMT_INFO(223) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_add_9() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() 


CTest _cpptest_TestObject; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_35, 224) int _x = 0; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_36, 225) int _y = 1; 

CPPTEST_STACK_TRACE_VARIABLE_INFO(anonymous__CPTR_37, 226) int _return = _cpptest_TestObject.add(_x, _y); CPPTEST_STACK_TRACE_STMT_INFO(227) 

cpptestPostConditionInteger("int _return", (_return), _cpptest_strdata_var(5, "C:\\gitfile\\msgTest\\doTest\\doTest\\tests\\autogenerated\\\324\264\316\304\274\376\\TestSuite_main_cpp.cpp"), 225); CPPTEST_STACK_TRACE_STMT_INFO(228) ; CPPTEST_STACK_TRACE_EXIT_ROUTINE() 
} 




void TestSuite_main_cpp_50199427::test_main_1() 
{ CPPTEST_STACK_TRACE_FUNC_START_INFO() CPPTEST_STACK_TRACE_STMT_INFO(229) 


::newMain(); CPPTEST_STACK_TRACE_EXIT_ROUTINE() 

} 
#line 1 "__TEST_HARNESS__"
;

